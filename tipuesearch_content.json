{"pages":[{"url":"/about","text":"列夫·托尔斯泰《家庭幸福》 我曾经历了许许多多，现在，我似乎明白了什么是幸福，在乡下恬静的隐居，尽可能对人们做些简单而有用的善事，尽管那些人们并不习惯我为他们做了这些，做一份真正有用的工作，最后休息，享受大自然，读书，听音乐，爱周围的每一个人。 对于软件以及IT行业的思考 重脑力劳动，仅仅完成翻译业务规则的程序员必将消失 软件架构的多样性，源于上层以及顶层标准的缺失，也源于底层硬件设施的持续发展。上层以及顶层的标准，又难以统一，因为这是源于不同的人对世界的认知，我们无法以标准的形式去统一每个人的知识背景、思考的过程、以及积累的知识；底层硬件的持续离散化，影响着软件的物理集成形态、复杂程度以及软件行业的分工协作。","tags":"pages","title":"关于"},{"url":"/copyright","text":"Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License 您可以自由地 分享 — 在任何媒介以任何形式复制、发行本作品 只要你遵守许可协议条款，许可人就无法收回你的这些权利。 唯须遵守下列条件 署名 — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. 非商业性使用 — 您不得将本作品用于商业目的。 禁止演绎 — If you remix, transform, or build upon the material, you may not distribute the modified material. 没有附加限制 — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits. 声明 You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation. No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material.","tags":"pages","title":"版权"},{"url":"/articles/hhkb-pro2-type_s-cheat-sheet","text":"键帽 空格键的键帽，最好拆卸来之后反装，否则容易伤到大拇指 光标移动组合键 其实下面这些快捷键，都是macOS自带的快捷键 一上行 CTRL + p 下一行 CTRL + n 行首 CTRL + a 行末 CTRL + e 删除后一个字符 CTRL + d 删除前一个字符 CTRL + h 删除光标之后的所有内容 CTRL + k 交换光标左右两个字符 CTRL + t 移到下一个字符 CTRL + f 移到下一个字符 CTRL + b 参考资料 http://kaochenlong.com/2013/06/29/about-hhkb-pro2/ https://support.apple.com/en-us/HT201236","tags":"experiences","title":"Happy Hacking Keyboard Professional 2 Type-S"},{"url":"/articles/10-basic-concepts-of-software-structure","text":"概念的意义 概念的初衷，是为了沟通，为了加速理解。 如今的这个社会，概念的定义，一部分变成了「市场宣传」的「洗脑行为」。 比如，各大汽车厂商，都会定期面向市场发布「概念车」，向广大的消费者宣传品牌理念，技术趋势，营造诸如「高科技」、「人性化」、「环保节能」的品牌形象。 人的差异，是源于天生对于概念的不同认识、理解，这和其经历过的环境，接受的教育，传承的文化息息相关。不同文化和理念，会对相同概念产生不同的诠释，并体现在对相关事物进行选择的各个方面。 概念的定义 一个好的概念，一定是面向目标受众，指代清晰，便于理解的。 非普适的、专业领域的概念，有另外的称呼——术语。 越抽象的概念，其内涵越小，外延越大，也就是可以解释的范围越大，可以根据实际情况解释出不同的内涵。 越具象的概念，其内涵越大，外延越小，也就是没有太多解释的必要，有特指的效果。 聚合概念 一般的概念定义，是基于一些已经存在、被广泛接受的概念，进行缩略和重组，赋予新的内含，这种类型概念在理解时，一般可以通过「望文生义」的想象，由受众自行解释内涵。 以「手机」这个概念，举个例子。 手机 —— 可以拿在手里的电话机（当然，手机在别处也成为「行动电话」） = 手持 + 电话机 = 手持 + （用电 +可以通话 + 机器） 可是，「无绳电话」又是另外一个截然不同的解释了。概念的诞生，有时会带着时代的烙印。 借用概念 当事物的内涵发生质变的清下，外形不变，人们就又会对概念进行升级。有时，会借用一些概念，以示区分。 以「功能手机」和「智能手机」这两个概念，再举个例子。 功能手机 —— 拥有不同外壳，但仅仅可以拨打电话，发送短信的手机 智能手机 —— 可以连接数据网络，自行安装App应用，满足每个人个性化需求的手机 「智能手机」其实是借用了「智能」这个概念，其实远远没有达到「智能」，任何手机目前都没有「先于人类思考、归纳、演绎」的能力，事实上是由无数的程序员，通过代码，以软件的形式，把预设好的场景、规则植入了硬件之上，使之产生了「智能」的假象。 人们同样喜欢在从其他完全不相关的行业、生活场景中，借用概念。 同样的，在英文中，人们习惯于对词根进行重组，将单词进行拼接。 所以，借用概念，有时也是偷换概念。 创造概念 创造一个全新的概念，是需要大量的文字、图片、语音、视屏，多维度进行阐释。更多的情况下，全新的概念，太过于抽象，而被定义成了品牌。 全新的概念，其实没有那么容易被创造。 概念的根源，是宗教和信仰，是看上去不证自明的公理。（科学,也是一种宗教） 概念的演变 大部分的概念，是通过组合或者借用的方式形成的。 当这些被重组的概念的内涵，作为顶层概念的根基，随着社会发展产生变化的时候，会逐渐与定义时偏差的解释，这导致了顶层的概念同样需要进行重新的定义和解释。 十个基本概念 软件只有被运行，才能产生使用价值。它始于硬件，终于用户交互，是具备「层叠集成」特性的产物。 代码 代码，可以用来表示与计算机无关的实体、关系、逻辑，也可以用来协调和控制计算机的运行时逻辑。 代码，简单而言，至少应该被分为源代码和机器码。 源代码和机器码，是代码的两种形态，前者用于和人的交互，后者用于和机器的交互。两者的相互转换的方法，是编译和反编译，当然这两个过程会产生失真，反编译比较严重。 版本 代码是对客体，用特定的计算机语言进行的「结构化描述」，也是阶段性认知的产物。 版本，则是对代码进行了「不可变的固化」，形成一个暂时地「附属代号」。 版本的意义在于，容易让受众理解，一个新的版本是进行了部分优化、正向修正的结果，但代码主体没有发生太大的变化。 数据 数据，是特定的计算机处理逻辑能够处理的「结构化信息」。它可以存在于内存或者处理器中，也可以存在于存储介质上，还可以存在于网络中。 数据，是代码的血液，使运行中的代码产生实际价值。 资源 资源，是个广义的、相对的概念。 正因为软件在运行时，是具备层叠集成的特性，所以不管采用哪种分层方法，都能为某一层的软件，找到它的运行时依赖——资源。 资源，既包括用代码描述的可被处理的数据，也包括通过代码定义的逻辑处理能力。 环境 环境，也是一个广义的、相对的概念。 软件需要被运行，环境是软件的物理运行时基础。不同层面的软件，具有不同的运行环境。 例如，操作系统的运行环境则是硬件，而浏览器中的脚本代码，运行时环境则是脚本解释器。 容器 容器，同样是个广义的、相对的概念。 容器，是对运行时环境的进一步虚拟划分的结果。 隔离受控是容器的特性 ，两个不同容器中的代码，其对资源的操作是严格受到容器控制的。 提供组件（即容器中的内容）的运行环境。 一种容器，面向不同内容，是同质的。 容器保证运行期不同内容的隔离。 不同层面的软件，可以有不同的实现。例如，在操作系统层面的虚拟化（Docker）、服务与应用层面的运行时环境（OSGi Bundle）等等。 组件 组件，是一组能够独立部署于容器内，提供有效功能的代码，是模块的物理集合。组件在设计时，可以申明运行时的资源依赖，并由容器在运行时为期加载所申明的资源。 一个容器内可以有 m 个组件，且 m ≥ 1 。当 m > 1 时，实现了组件化。 组件化，是软件设计中常用的设计方法。 模块 模块，是一些独立具备有效功能的代码，但模块不能在运行时环境中独立运行。一个组件在设计期申明的运行期资源依赖，可以被多个模块所共享。 一个组件可以有 n 个模块，且 n ≥ 1 。当 n > 1 时，实现了模块化。 模块化，也是软件设计中常用的设计方法。 插件 插件，一般不具备独立的功能，直接依赖于运行环境所提供的资源，不能在设计期向运行环境声明外部的依赖资源。插件中包含的逻辑功能，更多的是以「插入」的方式，嵌入到预先设定的逻辑中，以此适应和增强不同的应用场景。 Filter Chain 是一种典型的插件化设计模式。 插件化，同样是软件设计中常用的设计方法。 配置 配置，同样不具备独立的功能，更多的使用场景，是由用户在使用过程中，自行设定的逻辑或者参数值。配置一般不需要编译。","tags":"ideas","title":"软件结构的十个基本概念"},{"url":"/articles/software-is-not-simple","text":"软件的鸿沟 并不是每个人，都可以制造一个软件，它可能是一个简单的应用，目的是让计算机为我所用。 人们在生活中，所使用的自然语言中的很多 普适 的「形容词」，一般都在人与人的沟通中，由客体根据自身特点和实际场景进行 解释 。 例如，「好看」，每个人的解释都不一样。 计算机也有语言和各种方言，人们习惯性的称之为「代码」，并一般用「代码」来指代「源代码」。计算机语言，是「程序员」发起的与计算机沟通的「单向语言」（计算机和「程序员」沟通并不这样「说话」）。而在计算机的代码中，从来没有出现过「好看」，这样的形容词。 代码，代码，到底用码代表了什么？ 与硬件交互的代码，更多的是指挥硬件，如何进行逻辑运算、管理内存、读写硬盘——毫无面向普通人的「应用价值」。 与生活应用相关的代码，更多的解决人们的实际问题——社交、购物、出行等等等等。 软件和普通人，存在着巨大的鸿沟。 一般人无法理解，在软件领域里：架构，是骨架；场景，是肌肉；数据，是血液；界面，是皮肤；体验，是外衣。 这一切，都需要代码表达。 跨越鸿沟的程序员 黑客也是创造者，与画家、建筑师、作家一样。—— Paul Graham: Hackers and Painters: Big Ideas from the Computer Age 优秀的程序员，既是自然语言的翻译师，又是复杂软件系统的建筑师，还得是懂得体验的交互设计师。 拥有系统性认知的能力 「盲人摸象」的故事，是说在缺乏整体的「系统性大局观」的条件下，每个人都用自己的手，去感受大象的外形。 现如今，面对更为复杂的世界，每个人获取信息的带宽，却是有限的。有限的时间和精力，不可能认知无限的未知。碎片化与社交化所形成的认知方式，使得每个个体，更难以形成系统化的知识脉络。 系统性认知，是从已知中找到一个全面且条理性强的普适规律——知识，并能够用规律，有效地推理未知。系统性，是全面性和条理性的综合体现。 对特定场景的系统性认知，是软件在此类场景下产生应用价值的前提。其中，包含两个要素：抽象和建模。 抽象——提炼概念 场景的参与者是多视角的，通过简单的几个现象或者场景，就能够迅速捕获、提炼出关键概念，这是一项典型的「认知技能」。为一个正确的概念取名，是沟通的前提——名不正则言不顺。对于新生事物，新概念的出现，需要大量的传播成本，才能使得每个受众——人，产生 与期望相符 的「正确理解」。 建模——理清关系 通过场景之间、参与者之间的关联分析，能够找出多个视角各自的关注点，是建模的基础。缺乏实际经验，缺乏站在人性角度的思考，是难以建立一个让多方认可的模型。 深刻理解软件的局限性 在克服了硬件的局限性之后，还需要通过三类最基本的数据处理方式，建造出五花八门的应用软件。 条处理 典型以表单交互为源，逐级驱动 异步调用为主，异步中断比较困难 容易产生分布式事务 处理时长为秒级以内 流处理 典型以多维、高维事件为源，内存计算为主 单点故障较容易产生，多实例并行计算一致性较难保证 计算前，采用数据字典进行压缩编码，有利于提高降低内存开销 处理时长为毫秒级或者更短 批处理 典型以数据库或文件中的批量数据为源，以并行计算任务为主 一般由集中的调度器，进行任务的调度 处理时长为秒级以上，分钟级较为常见 软件为什么变复杂 提高单个硬件的稳定性 大部分的硬件的「工况」都是不可靠的，导致软件也缺乏了必要的「工作环境」： 断电会无法工作 过热会自燃烧毁 遇水会短路烧毁 摔打会自燃解体 光纤被铲车挖断 电线被老鼠咬断 … 因此，世上也没有谁，能够保证硬件至软件的100%可靠，不同的可靠性，所带来的成本开销，肯能是指数级增长的。 硬件的品类与品质越多，其稳定性提升的「高可用软件方案」也越多、越复杂。 ——软件变复杂了。 为应用场景提供更多的基础能力 人类社会的发展，是通过知识的积累和传承。而认知这个「实验过程」，永远不会停下脚步。为了让硬件产生「应用价值」，软件则需要在不断克服「硬件稳定性不足」的条件下，虚拟化出「人、财、物、事」的社会镜像，以满足各种各样的「成熟的旧规则」和「不成熟的新想法」。 人类有记忆，所以寄希望于用硬件存储，来模拟一个「永不遗忘」的虚拟记忆。 人类有沟通，所以寄希望于用通信网络，来模拟一个「万物相连」的虚拟沟通。 人类有逻辑，所以寄希望于用逻辑规则，来模拟一个「适时而变」的虚拟规则。 ——软件变复杂了。 要满足定性和定量的双重要求 软件的底层——硬件——是机械性的，不管归结于基因或是传承，各个层面的软件，都体现着这样的「非黑即白的逻辑性」。也就是说，「天生丽质」的软件，自然而然的具备了定量条件下逻辑计算的能力。 没有任何一门软件语言，具备原生的「定性关键词」。相比于「好与坏」，软件其实只懂得「合适」。也就是说，给定一个标准，软件可以告诉你，给定的对象与标准之间的差距有多少，并根据这个差距，再通过一个给定的公式，得出是否合适的结论。 社会中的沟通，很多场景下都是基于不太确定的概念以及定性的形容词，人们需要解释，或者自行解释。比如， XXXX 的解释权，归YYY所有；请 拉好 扶手。 ——软件变复杂了。 要满足人的无限的心理预期 人性的弱点之一，在于「外貌协会」。 响应，布局，配色，文案，手势，一切都要符合用户的心理预期。 无需解释的表达，才能不需要说明书。 人们还希望计算机理所应当的具备： 永不丢失的记忆 呼之即来的速度 因需即变的更新 ——软件变复杂了。 无数个我们 我们在虚拟的世界里，制造了无数个我们的影子。 我们希望在虚拟的世界里，我们的记忆永远不会被忘记。 我们希望在虚拟的世界里，实现我们的奇思妙想。 我们还不希望其他人通过这些影子，拼凑出现实世界中的自己。 我们还希望计算机帮助我们加速认知...","tags":"ideas","title":"软件，不简单"},{"url":"/articles/id-and-unique-id-overview","text":"无处不在的标识 名称是一种相对唯一的标识 在世界里，「相对的唯一标识」是普遍存在，例如： 每个人出生的时候，就获得了一个「相对的唯一标识」——姓名。 城市的道路，都基本上采用了唯一的命名（当然这也需要一个 过程 ）。 显然，对于每个标识，都需要有一个命名空间（namespace），来保证其相对唯一性。 可以说，在人的意识里，对于的实体的描述是基于名字进行的，人们并不希望同名的出现太多，这会在沟通过程中的产生理解困难。 实体在不同命名空间的标识 对于人来说，在家庭里会有小名，在社会中会有正式名字，在社交过程中还会产生绰号。 在中国，对于企业来说，除了企业有名称之外，还有组织机构代码证、有税务登记证、有工商营业执照，并分别对应三个编号。（当然，目前三证合一也在进行中）。 回到计算机领域，围绕主机在网络上的地址，在不同的命名空间中，都会存在一个「相对的唯一标识」用来描述一个实体 每个以太网网卡，都有一个48-bit 的MAC地址 每个MAC地址，可能有一个或者多个IP地址 每个网卡，都可能有一个或者多个IP地址 每个IP地址，都可能有多个域名 当然，每个主机，都会有一个主机名 接续上面的例子，事实上，MAC地址是由 IEEE Standards Association Registration Authority 完成地址段的分配。 对于目前的 1530 个顶级根域（gTLD），以及 IPv4 / IPv6 地址，都由IANA对其进行管理。 小结 标识是从一个典型的场景，对客观事物进行统一编码的过程。 采用 半集中与半自主相结合 的方法，是一种实现「分而治之」十分普遍和有效的设计模式。 标识的唯一性是根据命名空间紧密相关的。 标识的使用 在不同命名空间中实现标识的转换 在中国，对于人名，通常是由公安局出入境管理局完成中文至英文的翻译，同时，他们会把翻译结果写到数据库中，印到护照上。 这中间的翻译规则，通常是根据中文与汉语拼音、汉语拼音与英文字母的两次转换关系完成的。 对于计算机网络，则会有 NAT完成IP地址间的转换，RAP/RARP完成IP地址与MAC地址的双向转换，DNS完成域名至IP地址的转换。 可是，为什么需要那么多不同命名空间的标识标识一个实体？可能最直观的回答通常是这样： 域名为了方便人的记忆与使用 IP地址是为了更广范围的计算机互联 MAC则是为了在物理上保证唯一 OSI开放系统互联7层模型决定的 人们会在不同的领域（也是命名空间）中定义自己的命名规范，这可以认为是领域主权的体现，同时伴生的会是一套与相关领域标识的转换协议。 结构化与别名效应 结构化是把数据的元信息以位置的方式固化是数据中。也就是说，代表某个意义的信息，一定会出现在一个约定好的位置上。 由于标识是被人经常使用的，那么在使用过程中会对大脑形成一定的训练。 人在看到了010-XXXXXXXX，021-XXXXXXXX号码之后，自然而言会产生条件反射，认为两者分别代表了北京和上海；同样的人在看到了139和186之后，分别产生了中国移动以及中国联通的运营商联想。 对于使用者，这种场景，数字类似是一个名称别名。对于程序员，这十分接近「数据字典」的设计模式。 标识转换过程的两面性 别名和正名，同样是来自于两个不同命名空间的标识，之间自然而然的会进行转换。 当然，人们也不会忘记去Hack这些转换协议的设计。 一些是有益的，是实现了更为便利的应用场景。例如：将不同的域名指向相同的IP地址（使用A或者CNAME记录），并结合相关软硬件实现「虚拟主机」，达到资源复用的目的。 一些却是有害的，例如，诈骗电话也经常采用改号的方法，让接听者误以为那是来自某个官方的外呼电话。 同样的，在计算机领域，一样有DNS劫持、DNS污染。 有矛就有盾，进行安全性扩展的 DNSSEC 就是为了对DNS结果，验证不存在性和校验数据完整性验证，不过依然没有实现全面部署。 小结 不同命名空间的标识，在互通时需要进行转换 转换的过程，可能是一个简单的规则，也可能是一个独立第三方服务 标识需要有数据标准的规范指导，以及辅助的易用性工具支撑 标识的生成 标识的生成方法有很多，有集中式的，分布式的；有后端的，前端的，当然还有人工的。 并没有一种通用的生成方法来适应各种应用场景。 人工生成 人工生成的确是一种方式，比如电子邮箱，微信ID，各种论坛的账号。 在人想出标识的那一刻，是无法判断是否是唯一的，对这种生成方式的结果，显然在录入时都需要进行唯一性校验。 所以，下面描述的几种生成方式，是在生成的那一刻就在一个命名空间内唯一，而不再需要进行唯一性校验。 基于数据库生成 MySQL(5.6) AUTO_INCREMENT 特性 Postgres(REL 9.6 Stable) SEQUENCE 特性 Oracle 数据库的 SEQUENCE 特性，有知道这一特性如何实现的，可以在 知乎 做一下解答。 Flickr Ticket Servers ，同时支持Sharding (文章发表于2010年2月8日，算法上线于2006年1月13日)。 一般地，这种类型的生成方案，都可以设置其实初始值，以及增量步长。 基于协调器生成 在不使用数据库的情况下，通过一个后台服务对外提供高可用的、固定步长标识生成，则需要分布式的集群协调器进行。 一般的，主流协调器有两类： 以Paxos为代表的：ZooKeeper 以Raft为代表的：Consul / Etcd ZooKeeper的强一致性，是由Paxos协议保证的；Consul的一致性，官方用subtle(微妙的)来形容。它既采用了Gossip管理集群Membership，也采用了Raft管理Service Catalog。Consul的写一致性通过Raft保证，但Consul的读一致性有三种模式，default / consistent / stale， 其中consistent是强一致的。 在步长累计型生成算法中，最核心的就是保持一个累计值在整个集群中的「强一致性」。同时，这也会为唯一性标识的生成带来新的形成瓶颈。 基于服务内置生成 似乎对于分布式的ID生成，以Twitter Snowflake为代表的， Flake 系列算法，经常可以被搜索引擎找到，但似乎MongoDB的ObjectId算法，更早地采用了这种思路。MongoDB 1.0 是在2009年8月27日 发布 的，并且0.9.10(2009年8月24日发布)和1.0两个版本没有差异。 在StackOverflow上， 最早的一个关于ObjectId的问题 ，时间是2010年1月27日。不知道Twitter的同学，是不是受此启发呢？ MongoDB ObjectId 12-byte MongoDB ObjectId 的结构是： a 4-byte value representing the seconds since the Unix epoch, a 3-byte machine identifier, a 2-byte process id, and a 3-byte counter, starting with a random value. 可以看出，这个方案所支持的最小划分粒度是「秒 * 进程实例」，单进程实例的每秒容量是 3-byte (24-bit)，也就是接近16777216个ID。 有兴趣的，还可以进一步 看代码（MonogoDB 3.3.x Java Driver） 研究：Timestamp, Machine Identifier、Process Identifier、计数器的初始值分别是如何获得的: Timestamp private static int dateToTimestampSeconds(final Date time) { return (int) (time.getTime() / 1000); } Machine Identifier StringBuilder sb = new StringBuilder(); Enumeration<NetworkInterface> e = NetworkInterface.getNetworkInterfaces(); while (e.hasMoreElements()) { NetworkInterface ni = e.nextElement(); sb.append(ni.toString()); byte[] mac = ni.getHardwareAddress(); if (mac != null) { ByteBuffer bb = ByteBuffer.wrap(mac); try { sb.append(bb.getChar()); sb.append(bb.getChar()); sb.append(bb.getChar()); } catch (BufferUnderflowException shortHardwareAddressException) { //NOPMD // mac with less than 6 bytes. continue } } } machinePiece = sb.toString().hashCode(); Process ID try { String processName = java.lang.management.ManagementFactory.getRuntimeMXBean().getName(); if (processName.contains(\"@\")) { processId = (short) Integer.parseInt(processName.substring(0, processName.indexOf('@'))); } else { processId = (short) java.lang.management.ManagementFactory.getRuntimeMXBean().getName().hashCode(); } } catch (Throwable t) { processId = (short) new SecureRandom().nextInt(); LOGGER.log(Level.WARNING, \"Failed to get process identifier from JMX, using random number instead\", t); } COUNTER private static final AtomicInteger NEXT_COUNTER = new AtomicInteger(new SecureRandom().nextInt()); 此处需要注意的是MongoDB的 NEXT_COUNTER 其初始值是一个随机数，这是有利于分库分表的。因为在小并发的条件下，非随机数的初始值，容易产生 偏库偏表 ， 不均匀的现象。 Twitter Snowflake Twitter在2010年6月1日（在Flickr那篇文章发布不到4个月之后），Ryan King 在Twitter的Blog 撰文 写道： Ticket Servers方案缺乏顺序的保证 考虑过采用UUID，不过128-bit太长了 也考虑过采用ZooKeeper的 Seq 所提供的 *Unique Naming* uence Nodes 所提供的 Unique Naming 特性，但是性能不能满足。(个人认为，Sequence Nodes的设计目标是解决分布式锁的问题，但不解决性能要求极高的ID生成问题，直接应用是一种Hack行为) 在这种情况下，Twitter给出了 64-bit 长的 Snowflake ，它的结构是： 1-bit reserved 41-bit timestamp 10-bit machine id 12-bit sequence 在过了不到4年，2014年的5月31日，Twitter 更新了 Snowflake 的 README，其中陈述了两个容易被忽视的事实: \"We have retired the initial release of Snowflake ...\" \"... heavily relies on existing infrastructure at Twitter to run. \" 可以看出，这个方案所支持的最小划分粒度是「毫秒 * 线程」，单线程（Snowflake 里对应的概念是 Worker）的每秒容量是12-bit，也就是接近4096。 翻一下Snowflake的 归档代码 (Scala) ，可以看到： 关于初始化Sequence的处理 if (lastTimestamp == timestamp) { sequence = (sequence + 1) & sequenceMask if (sequence == 0) { timestamp = tilNextMillis(lastTimestamp) } } else { sequence = 0 } 可以看到此处Snowflake对于 sequence``的赋值为 ``0 。 关于每秒超过4096个ID生成请求的处理 protected def tilNextMillis(lastTimestamp: Long): Long = { var timestamp = timeGen() while (timestamp <= lastTimestamp) { timestamp = timeGen() } timestamp } protected def timeGen(): Long = System.currentTimeMillis() noeqd 2011年11月23日，用Go语言实现的，基于Snowflake的 neoqd 出现了。 它的特点是，除了使用Go语言进行了实现，更是把ID生成做成了一个网络服务。支持客户端向ID生成服务申请ID。它还支持： 简单预共享Token的客户端身份证认证（只是加强了那么一点点的安全性，可以忽略） 支持批量获取ID，最多256个（因为使用一个byte表示申请个数） 同时，作者还建议使用 Doozerd 一个用Go语言写的 -- a highly-available, completely consistent store for small amounts of extremely important data. 进行Machine ID的分配。 (关于 ZooKeeper / Etcd / Consul / Doozerd 的比较，也是可以期待下) Boundary Flake 2012年1月， Boundary Flake 同样的，用Erlang语言把Snowflake，变成了一个网络服务，提供128-bit长的ID生成服务。 不过，根据其RoadMap的描述，这个项目并没100%完成。例如，批量的ID生成，HTTP 接口，客户端Library都列在里面待实现。 CruftFlake 2012年7月， CruftFlake 更显然的，是想以一个PHP变种身份出现。 它在结构上与Snowflake基本一致，存在两个区别： 在timestamp上的取值略有区别 可以自行决定是否采用ZooKeeper作为协调器 LableOrg/java-uniqueid 2014年7月18日，LableOrg 写了一个通过ZooKeeper进行协调的，128-bit长的算法 java-uniqueid 。其 结构组成 依然十分相似： Timestamp Sequence counter Generator IDs Cluster IDs 前台浏览器生成 这里的前台，主要是指以「浏览器」为代表的客户端。 2015年2月16日， Sudhanshu Yadav (看面相像印度人)，用Javascript写了Flake的又一个变种实现 FlakeId 。其核心代码是： if (this.lastTime == time) { this.seq++; if (this.seq > 4095) { this.seq = 0; //make system wait till time is been shifted by one milisecond while (Date.now() <= time) {}; } } else { this.seq = 0; } 它的Machine Identifier则是作为构造函数的选项参数 options.mid 传入。 function FlakeId(options) { options = options || {}; this.seq = 0; this.mid = (options.mid || 1) % 1023; this.timeOffset = options.timeOffset || 0; this.lastTime = 0; } 全自主随机生成 可以说，成熟的、全自主生成方案，可能只有 128-bit UUID 一种，具体的说，是UUID Version 4。另外，微软对它实现，称之为 GUID 。 一般的，使用的最多的是UUID Version 4，很大程度上是因为其依赖的其他服务最少。 这里，通过python (2.5+) 对UUID的实现，体验一下UUID的生成效果： $ python Python 2.7.12 (default, Jun 29 2016, 14:05:02) [GCC 4.2.1 Compatible Apple LLVM 7.3.0 (clang-703.0.31)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import uuid >>> uuid.uuid1() UUID('d17c4397-830d-11e6-b62d-985aeb899615') >>> uuid.uuid3(uuid.NAMESPACE_DNS, 'yanjiong.wang') UUID('363053e8-e02d-3b9d-b18b-83da99d5a684') >>> uuid.uuid4() UUID('59cfe861-a6b1-45ff-9522-2e780adf491a') >>> uuid.uuid5(uuid.NAMESPACE_DNS, 'yanjiong.wang') UUID('25d4e194-0404-5c64-8695-c547f98ccde1') 另外，我们看一下网卡的MAC地址 $ ifconfig lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> mtu 16384 options=1203<RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP> inet 127.0.0.1 netmask 0xff000000 inet6 ::1 prefixlen 128 inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1 nd6 options=201<PERFORMNUD,DAD> gif0: flags=8010<POINTOPOINT,MULTICAST> mtu 1280 stf0: flags=0<> mtu 1280 en1: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500 ether 98:5a:eb:89:96:15 inet6 fe80::8d7:fea6:2ec2:ea55%en1 prefixlen 64 secured scopeid 0x4 inet 10.0.3.22 netmask 0xffffff00 broadcast 10.0.3.255 nd6 options=201<PERFORMNUD,DAD> media: autoselect status: active (因为UUID Version 1会泄露网卡的MAC地址，所以我对MAC地址做了下小手术) 可以看到UUID Version 1 最后一组数值 985aeb899615 与网卡的 MAC地址是一样一样的 98:5a:eb:89:96:15 。 个人一直认为，采用UUID Version 4是一种偷懒的，缺乏必要设计的做法。 一方面，它是依据概率确保无碰撞的，计算的过程与概率上的「生日问题」是一样的，不再展开。 另一方面，从使用的角度，UUID还有以下缺点： 太长，即便是转换成36个字符，不利于输入 过于随机，没有规律，在开发调试、线上故障定位，都容易看花眼。 如果作为数据库主键，对索引不利。 小结 人工生成的标识，在相同的命名空间里，需要后续唯一性验证才能保证唯一 由计算机生成，在低并发的场景下，适合通过一个服务集中生成，并保障此服务的高可用性 由计算机生成，在高并发的场景下，适合通过一个保障命名空间独立的命名规范下，由多个服务并行生成。 采用步长和增长相结合的生成算法，本质上都是对某个状态进行累积的结果。 对于取模进行分库分表的场景，初始化值随机有利于均匀分布。 （MongoDB 的 ObjectId 更是Flake系列算法的鼻祖，并在初始值上进行了随机化处理） 设计一个「合适」的标识 区分实体和关系 实体是点，而关系是线。 一般而言，面向实体的标识生成速度，要小于面向关系的生成速度。 具体的例子，以电商为例：买家、卖家、商品这些实体的录入速度，要远比订单生成小的多。也因此，主数据要比交易数据稳定的多。 并且，关系还可能包含层次关系，进而体现为一个依赖树。 面向实体的标识 面向实体的标识，更多的与概念相关（名称）、与形态相关（型号），有很多的人为因素参与，随机因素有限，命名的主体也来自于人。 对于实体制造，为任意一个产品进行标识，大致会分为六个方面：品牌、品类、品名，型号、批号、产品序列号。 对于前四者，更多的是人为的进行命名。 例如，给定中文，找到对应英文，再进行缩写。 对于批号，则会增加一些时间因素，以关联到产品的生产时间。 例如，采用20160925表示具体某一天，或者采用201640表示具体某一周。（一般来说，同一个批号的产品，所使用的原材料是也是同一批。） 对于产品序列号，最简单的是采用自然数法进行编号。 这一类的标识，在分布式系统下，在系统并发量小，集群规模小的情况下，可以采用基于数据库或者协调器的生成方案。 面向关系的标识 自然的，关系源于两个或两个以上的实体之间所进行的某一个活动，并且具有一定的时效性。 常见的关系的表现形式有：交易流水号，会话标识等等。 这一类的标识，在分布式系统下，在系统并发量大，应当采用基于服务的内置生成方案。唯一依赖的是在实例部署时、启动前，为期分配唯一的Machine Identifier。这个Machine Identifier可以交由以强一致性保证的协调器完成。 当然，在系统并发量小的情况下，任然可以采用基于数据库的生成方案，因为没有协调器集群的参与，系统整体的复杂度更低，更利于维护。 标识的容量 任何采用文字所表达的标识，最终在计算机里，都会根据一定的格式，被转换为字节byte进行处理，这个过程称之为「序列化」。 这种序列化方式，本质上是一种编码方式。 变长编码 一般来说，采用变长的编码方式，主要的目的是为了应对不可预期大小的信息量。 常见的有 TLV(Type-Length-Value) 方式。 Google的 Protocol Buffers 非常有意思地采用了 Base 128 Varints 的编码方式。 本质上，一个 URI 也是对一个标识，它可以标识一个功能，也可以标识一个虚拟实体。 RESTful是对此类命名方式的一种实践方式，也是对 URI和HTTP协议组合之后，「表征力」的一个深入挖掘。 定长编码 在回顾一下前文所提到的IPv4地址，它似乎、可能、或许会在2019年 完全枯竭 ， 因为它只有32-bit。相比之下，MAC地址有48-bit，IPv6有128-bit。即便是它们都没那么容易枯竭，但也不代表由于人为因素，导致无法有效使用。 再回想下，每个人的身份证、手机号码，都是采用定长的形式进行编码。 选择定长有利于预先分配计算机资源，不管是内存、文件系统，还是数据库。同时，对于人的心理来说，可预期性大大增强了。 标识的命名空间 命名空间有三个层面： 异构切分：对于不同的场景和视角，以树形进行层次划分。 同构切分：对于异构切分的结果，切分出不同的分片。 时间切分：对于同一个分片，在不同时间点上的状态。 一般地： 首先，采用并行无状态的生成算法，一般都采用时间作为首要的命名空间，并且此命名空间的实效性小于生成者的重启时间 其次，采用生成器实例自身的标识作为次要命名空间，以保证各个生成器的时间即便是不同步也不会产生重复标识 同时，需要注意的是，这可能导致唯一标识产生，大段跳跃，原因有： 单位时间的并发量远小于子命名空间的容量 生成器重启 标识的冗余 不管标识是在运行时的内存出现，还是记录到数据库中或者文件里，它都需要占用硬件资源。 还是拿身份证举例，一方面，一个18个字符长度的身份证，那么需要18个字节进行存储。18个字节意味着144-bit，比IPv6的128bit还长。 如果简单的标识全世界每个人，以目前全地球60亿人口的总量，那么33个bit就足够了。 采用这种冗余设计的原因，一方面是「半集中，半自主」和现实的行政、地域结构对齐，另一方面是实现关联信息的集成。 小结 标识编码后的长度，则决定了一个标识方案的整体容量。 在一个统一的命名空间内，有多个标识生成者并行生成时，需要划分独立的子命名空间，以保证生成的标识在整个命名空间内唯一。 单个命名空间的标识，承载的信息量有限，在标识的使用过程中，需要扩展与包含一些其他视角的信息以进行冗余。 标识的文本兼容 和人工取名字不一样，自动生成ID的主体，是计算机本身，但使用这个ID的主体，有两个：人和计算机。 对于计算机，最擅长处理的是结构化数组、条形码或者二维码；而对人，最擅长使用的是文本、图形或者视频。 一般而言，在大量的RESTful设计的应用，其URI中会包含大量的ID，用来标识用户、商品、订单等等，它们经常会出现在URI中。 以ASCII编码为基础的各种文本化编码算法，从Base16开始，正常的有Base32，Base64，Base58，Base85等等，不太正常的，在本文最后的扩展阅读里有列举。 其中，Base16是最为「字节友好」的，因为不需要进行任何Padding操作，就可以以把 4-bit/half-byte 转换为 [0-9a-f] 这十六个字符，因此Base16还有别名：Hex。另外对于键盘输入，这16个英文字母，又是相对纯数字之外，最方便的。 而Base32, Base64等等，都需要Padding。因为Base32是每 5-bit 进行分组编码，Base64则是 6-bit ，都无法直接对齐一个 byte(8-bit)。 另外，Base16还对 URI 友好，不需要进行任何的 URLEncode/Decode操作。 以64-bit长的ID为例，它既可以转化为 long ，也可以Base16成为16个字符的``HexString``，同时它大小写不敏感。 相比之下，如果采用Base64的文本化方案，其长度虽然少了5个字符，为11个，但其大小写敏感，不利于人机交互的输入，还会包含URI不友好，还会被转义为「 %3D 」的符号「 = 」。 一个精巧的标识文本化算法，并不应该简单的把一个二进制值转为HexString。在日志里，应该有相应的解码算法，解析出符合人类阅读的字符，比如：精确到秒、且带格式时间，生成改标识的主体，等等。 标识的安全性 标识的信息泄露 采用连续，或者固定步长的标识，容易从一个标识猜测其他标识的存在性。 常见的例子有： * 通过局域网扫描工具，扫描某个子网的活动的IP地址 * 通过端口扫描工具，扫描一个目标主机开放的端口，以初步确定主机操作系统类型 另外，在物联网领域，如果采用的EPC编码，那么很容易通过连续编码，估计某个产品的具体产量。 标识的自校验能力 还是使用身份证号这个例子，根据国家标准（GB11643-1999），身份证号的前17位为本体码，最后1位为校验码。也就是说，它是通过前17位进行数学公式计算之后获得，主要目的是用于检验录入过程是否产生差错。 这样设计的好处是，每当输入完18位身份证号后，可以直接判断一个身份证号，是否在逻辑上是「合规的」，对于系统而言不用查询数据库，可以减少IO操作。不过，这不代表这个身份证号是有效的，也有可能是一个无效，但符合校验规则的身份证号。 由于标识的长度有限，能够加入的冗余信息较少，一般的基于公钥密码体制的签名机制，都难以在一个短标识中嵌入。 扩展阅读 Distributed System Building Block: Flake Ids Roughly sorting: Sequential and parallel approach , 1989 Base1 HexagramEncode (六十四卦编码) BrailleEncode (盲文编码) 更新历史 2016-11-02 13:34, 更新基于协调器生成的内容","tags":"ideas","title":"标识与唯一标识概览"},{"url":"/articles/arch-is-to-solve-the-problem","text":"计算机是个复杂的机器，相比普通的机器（比如小家电、汽车），它可以在使用过程中对其「工作行为」进行「再定义和场景适配」，以解决不同场景下的人的需求和问题，这种「定义的结果」，对于机器的最终用户来说，是「应用 / Application」。 对于非计算机相关的普通人而言，即便是有诸多对于职位头衔的描述：「程序员」、「软件工程师」、「架构师」、「首席技术官」，也离不开一个潜意识的印象：「做网站的」或者是「修电脑的」。 很多「架构师」，都是从「软件工程师」开始，不知不觉的变成了一个「架构师」。对于我个人而言，当我还是一个实习生，被「升」为一个部门架构师带领一些正式员工干活的时候，对「架构师」这个概念居然是一片空白，甚至于不知道这是个「好消息」，还是个「坏消息」，当然也不知道「架构师」是干嘛的。 所以，我一直以 最简单的方式 对架构进行定义：** 架构是一种用计算机解决问题的综合能力，与头衔无关** 架构源于对实践的总结 架构能力并不是与生俱来的，而是和具体经历强相关的，丰富的经验是形成架构能力的基础。 很多时候我们强调「系统性思考」对于架构设计的重要性，希望从方法论上能够对正在从事或者即将从事架构工作的程序员在专业能力上进行提升。教条式、填鸭式的培训，是教不出架构能力的。理论的价值是能够帮助应用理论的人少走一部分的弯路，但不能够解决眼前的现实问题。 在企业里，架构是一个实践结合非常紧密的领域，一切以解决实际问题为目标。由于问题是多种多样的，导致解决的方法也是多种多样的。踩过的雷，填过的坑，都需要进行总结和抽象，才能提升到架构层的高度，防止重蹈覆辙。 架构是一个建模的过程 对于一个复杂问题，通常会对复杂问题按照能力领域进行分解，其目的是能够找到与现有能力相匹配的映射。这个映射，就是解决方案。它，不开人的「知识型劳动」，主要分解为三个方面： 对于已知问题的抽象和建模 对于已知能力的抽象和建模 对于解决方案和工具的设计 其中前两个方面，都提到了「建模」。建模本身是对客观事物的一种抽象，客观事物越复杂，那建模的结果变成「盲人摸象」的概率就越高。 然而，「盲人摸象」在IT领域其实不能算是个「贬义词」，因为这个现象十分的常见。究其原因，解决实际问题信息系统，更多程度是面向于「典型」应用场景，而不是「任意」应用场景的。 场景即是对客观事物的认知视角，信息系统做不到、也不需要对一个完整的客观事物进行全面（360°无死角）建模。 举个具体的例子：对于人这个客观事物，银行系统里，可能会关心这个人财务指标，例如「收入」、「支出」和「存款余额」，但在医院的重症监护病房里，可能就会关心这个人的生命指标，例如「血压」、「心跳」。 从例子里可以看出，一个面向具体问题的场景化应用系统，都是对一个客体进行「片面的」场景化建模。 说到底，建模是一种抽象能力，具体的说，是人对客观事物认知结果的理性提炼和总结，不可否认感性的部分太难以刻画和描述。很符合「庄子·天道」中所述：「意之所随者，不可以言传也」。 如果要拿数学语言进行描述「建模的能力」，就是找到一组尽可能少的「特征向量」去表述这个空间，而找这组「特征向量」的能力，就是建模的能力。 架构工作的核心是设计 没有软件的计算机，是「无法使用」的，因为没有办法帮助我们解决任何问题。计算机原本很「生硬」，无法很「柔软」的去直接适配所需要解决的问题。 架构的核心工作是「设计」，设计计算机如何按照预期进行工作。 架构设计中，建模的结果，是模型，它有着结构化、棱角分明的特质，因为这是计算机进行计算的最高效的方式：严格的告诉我们——两个数是相等还是不相等，及其衍生。正由于严格匹配，所以在很长的一段时间里，解决方案的制定和后续系统的交付运行，都围绕着如何严格按照实际场景进行模拟和落地。 很少以「按概率成功」对系统的业务功能进行设计和实现，一切都必须「绝对正确」。因为绝大部分的计算机系统，无法理解自然语意。只能根据人为设计的结构化信息，「按部就班」地完成重复性劳动。 人工智能、机器学习，在解决自动化建模领域的成熟度还是远远达不到人的能力，如果达到了，那么软件就不需要人进行「架构设计」了。简单的从架构设计的结果（当然也是结构化的），生成代码，这方面目前的计算机还是有能力胜任的。 任何不符合实际场景的计算结果，用户都认为是「缺陷 」，而在系统中产生此类异常结果，往往需要「程序员」为此承担相应的责任。呐，回想一下，在没计算机的时代，反而往往都是店小二算错了帐自己赔，没有人会去责怪算盘。这是为什么，因为算盘足够简单，简单到不需要做任何的监控系统、不需要记录任何的日志，连「三下五除二」这样的操作规则，都已经被社会化学习消除了使用成本。最终，一切出错的原因只有一个：用键盘的人。 是的，计算机系统生来就是是不可靠的，它不可能像「算盘」一样在运行期不依赖任何的自然资源。断电了，会引发故障；光纤断了，会引发故障；磁盘满了，会引发故障。。。一系列的不确定因素，导致「分布式系统」架构设计比「主机系统」的架构设计复杂的多，原本不需要操心的事情，都需要从更上层的软件层加以解决了。 所以，当前架构工作的很大一块，都随着分布式系统规模的增大而加大了比重。也许，导致世界上最聪明的一伙人都去解决计算机的问题了。 架构需要作出一系列非技术选择 架构既然是个解决方案，自然有很多可以自由选择的领域，有很多的受限的前提条件。这些外围因素，往往还系统背后的个人、团队、企业的价值观、以及非IT能力有关，这是一个很容易被忽视的点。 与人和团队的关系 架构往往是与个人或者团队的能力有关的，因为架构前一部分是设计工作，后一部分是代码框架的落地工作。可以没有一个十全十美、满足各方需求的方案，架构过程中有很多都是妥协的结果，有的是向需求妥协，有的是向运维妥协，有的是向个人英雄主义妥协。另外，绝大部分的选择都是人作出的，这导致了和人、团队的水平形成了很大的耦合关系。 早在1895年，法国心理学家 勒庞 在他的心理学名著「 乌合之众（The Crowd） 」就早已经说过： 一群精英所作出的群体决定，很有可能是最愚蠢的决定 。有时候，技术团队不能太强调民主；有时候，技术团队中的强强产生的效果是「1 + 1 < 1」。一个良好的、强弱结合的组织结构，才有可能孵化出优秀的工具，再进阶为一个优秀的产品，也有利于成员梯队的培养。 团队越大，一个优秀的架构设计方案被严格执行下去的可能性越小。第一，制定方案的人和落地方案的人大多数情况下都有脱节，很多设计精巧的方案细节到了执行者的手里，会被忽视。第二，为了统一一个团队的认识结构、设计理念，这部分的培训成本往往都是各个雇主不愿意付出的。第三，方案的描述本省是「不精确」的，还很容易存在文档过期的情况，在软件及交付的各个环节，任何参与者都有机会以自己的知识背景作为出发点进行理解，并自豪地加上自己的「杰作」。 与企业的价值观相关 企业的价值观，最直接的体现，就是企业的投资组合。 在大型的企业里，软件产品的采购往往会受制于「采购部」，也会受制于不懂IT的公司级领导所下达的行政干预，有些理由好像听上去也「很有道理」：采购过为什么还要采购，要「保护投资」。往往到了这个层面，程序员、架构师都纷纷表达了无奈。 软件，包含代码和数据。它不是一个简单的能够按照「固定资产折旧」进行的固定资产。它透射的是使用者对客观世界的认识，也需要随着对客观世界认知的变化而变化，因此版本对于软件来说就是一个时刻认知的快照沉淀。 行业的快速发展，企业的快速发展，势必推动企业信息系统的快速发展。对于企业而言，其价值是能够找到感知行业、感知产品、感知用户、感知企业内部运营的触角，每个社会中的实体不管是个人，还是产品都能够在系统中找到它的影子。 对企业主而言，IT是一个长期的投资行为。陈旧的、不符合时代背景的软件，是会变成降低企业生产力的绊脚石。 代码是架构设计的落地实现 现今任何的计算机高级编程语言，例如Java/C/C++，或者更高层的DSL，都是人与计算机之间的「单向语言」。这些「单向语言」，并非自然语言，大多数由程序员编写，再交由计算机进行执行，在很长的一段时间内，信息系统都是以这种方式与人进行交互。 （当然，也可以慢慢的等待「Siri」之类的助手长大成人，成为一名架构师，也许那个时候，广大架构师需要转行了。） 代码是架构实现的核心，通过代码可以完成对现实世界的「虚拟化」： 概念的虚拟化 能力的虚拟化 实体的虚拟化 记忆的虚拟化 协作的虚拟化 通过一些例子，有助于理解： 概念的虚拟化：一个业务概念的类定义 能力的虚拟化：一个方法对多个输入数据进行加工并返回结果 实体的虚拟化：一个类的实例，即具体的数据 记忆的虚拟化：一条关系型数据库的行记录 协作的虚拟化：远程方法调用 是的，代码是计算机的指挥者，代码是把人类智慧「赋能」给计算机的一种语言。 代码到不到位，写的好不好，对设计的落地实现会产生很大的影响。 其实，架构是一种用计算机解决问题的综合能力 很多时候我们看到的「系统架构图」，其实是针对目标问题所设计的「计算机领域的解决方案」，是一种设计图纸。 可以说，「架构工作」不仅要能够交付「设计图纸」，还要能够「建地基、搭房梁」。 宏观层面：对特定问题，进行解决方案的设计 微观层面：对后续的编码工作，形成与解决方案核心相一致的代码框架 做好「架构工作」有很多非技术的「软实力」，比如： 对于团队中成员职能的正确定位，知道他们真正擅长什么 深挖至本质的问题分析 多视角、符合人性的换位思考 舍弃一些力所能及，但影响专注的「杂事」，合理的说「不」 具备一定的投资意识，从更高、更长远的视角，看待投入与产出 发散性思考 在互联网公司出现之前，有没有「互联网公司」呢？他们和现如今的互联网公司的差别是什么？ 其实是有的，例如「电网」、「电信运营商」、「股份制商业银行」、「快递物流公司」。在人类社会中最基本的两个元素，就是「实体」和「连接」，一切和连接有关的行业，都可以认为是「互联」，只不过信息系统在企业中的价值是由「生产关系」决定了其价值。 机器学习能够帮助架构设计吗？ 机器学习很长一段时间之内都停留在参数调优上，而不具备对于一般事物进行建模的能力。前文也阐述过「概念的虚拟化」和「实体虚拟化」之间的关系，实体虚拟化就是数据，而数据本身已经是类的实例了， 互联网公司大谈「大数据」以及「数据驱动DT」的原因是什么？ 前面提到，数据是对客观实体的虚拟化，客观实体并不是无中生有的，他们是自然世界的产物，数据驱动的本质是客观事物驱动，退一步讲，本质仍然是「业务驱动」。当然，打通多个场景化的数据，对客体进行360°的建模，是「大数据」真正价值所在。 需要注意的是，剑总是双刃的，当在计算机系统这个虚拟世界里，找到了360°、包含衣食住行的你，生活是便利了，因为可以预测你的需求，不过你的隐私还存在多少？ 对开源软件实施「拿来主义」是否可行？ 很多开源软件，直接的「拿来主义」，会导致「后患无穷」。很大程度上，开源代码是一个个人、一个团队整体能力的映射，并且和运行这些代码所需要的环境息息相关。开源代码也是挑人、挑环境的，在一个团队没有想匹配的能力进行正确的使用之前，很多时候都是一匹「天生野马」，在驯服之后才会变成自己的「血汗宝马」，驯服的过程其实就是和自己团队以及周边环境相适配、磨合的过程。 重复造轮子真的是浪费吗？ 一个健康的IT团队，应当建立起一套评估「现有轮子」是否产生实际效益的体系，比如能够监控代码在生产环境的实际使用率、故障率，适时的下线一些「低效益」的代码。不要简单的否定和阻止「重新造轮子」，这是与企业内部人的能力对齐、外部大环境对齐的过程，更是企业不断新陈代谢的「投资型基因」。 结构化的数据到底意味着什么？ 所谓结构化，其实是面向数据的下游处理者，可以与其内置的概念（数据模型）进行映射和处理。结构是一种「元信息」。 举个具体的例子，一张bitmap图片，它本身是有结构的。bitmap的图片是标明了每个像素点上的RGB颜色值具体是多少，这个数据结构，对于图片浏览器来说，是可以识别和解析成为一张人眼能够识别的图片的，而浏览器本身只负责每个像素点上的颜色还原。倘若这张图片里是一张「用户」写实头像，那么图片浏览器并不能够分析出这张头像具体是哪个自然人，也无法将这张图片作为一个API的入参，联合其他该用户的入参，进行内部业务逻辑的处理。","tags":"ideas","title":"架构是一种解决问题的能力"},{"url":"/articles/api-is-not-suitable-for-microservice-data-sync","text":"API SPI 的调用，有很大的一部分比例，都是为了做数据同步。 API / Application Programming Interface（应用程序接口） SPI / Service Provider Interface (服务提供者接口) 软件要解决的是两部分的事情： 信息的共享 信息的加工 信息的加工时会对信息产生「增值的效果」，最终导致信息在形态上发生「形变」。 API和SPI的设计，如果没有进行任何加工（就是进行了业务逻辑，导致信息在结构上发生改变，变成另外一类的信息），那么之类的数据本质上是应该进行同步的操作。 导致不对数据进行直接同步的原因，有这些： 信息的一侧没有持久化能力 比如，浏览器侧是不提供持久化的能力的，那么就需要另外一方（有持久化能力的）提供API（一般也就是服务端），方便浏览器实时获取信息。 避免出现多份数据的一致性问题 一个数据实体，映射的是一个物理上的实体，物理实体的复制是困难的，但相比之下，数据实体的映射是简单的，特别特别简单的。这也导致了，数据在经过多个处理环节的时候，每个环节都可以对其进行持久化（这里不考虑安全性的问题）。","tags":"ideas","title":"API不适合做微服务数据同步"},{"url":"/articles/key-of-platform-operation","text":"平台要服务于内容 「平台」，在感官视觉上是一个「平的台子」，发音也有一部分也来自于英语的「Platform」，不管怎样，时下的平台自身应当包含两个基本能力： 承载内容 平台上承载内容的多样性和时效性，是平台生命力的核心指标。 关联内容 事物是普遍联系的，不同种类的内容之间，会存在潜在的联系。 以内容为核心的多边关系平台 一个健康的平台，应该是三边或者多边的，会包含： 平台运营方 内容供给方 内容需求方 更多的，还会出现第四方，比如： 平台监管方 正因为平台是服务于内容的、平台是由多边参与的，平台能够体现两个维度的关系： 横向上，平台体现的是供给和需求的关系 纵向上，平台体现的是运营和监管的关系 所以，平台本质上应当是多边市场化的。在横向上，供给与需求的在数量上的平衡，是决定某个内容市场能否持续繁荣的决定性因素。 市场犹如天平，架起的是某个内容的「供给」和「需求」两端。 平台运营的核心理念 平台运营首先需要帮助每个用户弥补短板，鼓励每个平台的参与者向平台贡献内容并得到广泛的认可、体现他们的价值，从而重点激发平台上的每个用户的自身潜力，同时也需要严格监管平台上的不良用户，保障一个健康、有序的生态环境。 弥补短板 现如今，任何单个个体的能力是渺小的，向市场上不断提供内容，仅凭一己之力，难以、或者需要耗费大量时间来提供一个完整的内容，慢节奏的内容推陈出新是无法满足这个时代挑剔的眼光，更难以激起波澜，甚至是难以获得注意。 平台运营方，自身要懂得某个领域内容的特点，帮助小微个体使用平台上的综合能力，使其提供完整的内容。 内容价值的多视角 需求方视角 内容需求方，更多的关心市场中的内容与自身状态的匹配程度，合适自身特点的内容，才是主观意识上的「好」。 对于确切的受体A与受体B，两者各自对于「好」的定义是不一致的。 平台需要能够为不同的需求方，尽可能的提供相匹配的内容，减少选择难度。 运营方视角 运营方首先要保障的是其平台运营的市场的公平性，消除由于平台自身能力不足导致不良用户破坏平台生态的行为。 供给方视角 供给方所关心的除了下游目标市场之外，还需要关注上游内容原料或者资源市场的动态，这也对平台运营方提出了需求——能否打通多个市场，为供给方提供一个多入单出，或者多入多出的市场风向标。 监管方视角 监管方更多的是从规范、法律层面，对其他三方的行为进行监管，在必要的情况下动用行政手段进行强制干预。","tags":"ideas","title":"平台运营的关键"},{"url":"/articles/devops-value-towards-enterprise-it","text":"DevOps 概念的发展历史 现在是2016年5月下旬， DevOps 作为一个IT圈的热词，几乎已经是无人不知，无人不晓。 如果你是一个有心人的话，可能会好奇DevOps这个概念到底是在什么情况下诞生的。 在 Wikipedia: Devops 的词条里，可以发现 DevOps 相关概念已经早在2008年就被提出了。 At the Agile 2008 conference, Andrew Clay Shafer and Patrick Debois discussed \"Agile Infrastructure\". The term \"DevOps\" was popularized through a series of devopsdays starting in 2009 in Belgium. Since then, there have been devopsdays conferences held in many countries worldwide. 即便是在2006年Amazon发布了ECS, 微软在2008年和2010年提出和发布了Azure， DevOps 的重要性似乎没那么强烈。 可是在8年前的那个时候，为什么 DevOps 没有迅速走红呢，第一个很重要的原因是因为那时候 云计算 （ Wikipeida: Cloud computing ） 还是小众产品，更多的与虚拟化相关。 第二个很重要的原因是 Docker 还没有横空出世，直到2013年7月。第三个很重要的原因是，Martin Fowler 在2014年3月提出了 Microservices 。 可以看出，当前 DevOps 概念的深入人心，离不开云计算、容器/Docker、微服务、敏捷等相关概念和实施的成熟发展。 企业IT对于企业的价值 谈到企业IT，就没有办法回避两种迥然不同的企业，一种是以传统制造业或者服务业为基础的，对生产资料进行加工的「传统企业」； 另一种是以「信息互联」为基础的，对「人与人关系、人与物关系、物与物关系」进行信息加工的「互联网企业」。 这两类，是两类极端的企业，一类企业的日常运行，可以没有信息系统；另一类企业，完全离不开信息系统。 一般的信息系统，对于企业的价值，主要有三类渐进过度的典型类型。 第一类，是将信息系统定位于「辅助和支撑」企业的产品制造以及企业运营部门，因为这类企业的生产资料系、生产力、生产关系，都以实体制造为主，不以信息加工和处理作为企业产品核心。 第二类，是将信息系统作为数据加工、传输作为主体，但业务模式来自于传统行业，信息系统主要完成已有业务规则的虚拟化，例如金融、电信行业。这类企业的信息或者数据，主要来自于业务受理，或者说数据的生产者和使用者是企业自身。 第三类，是将信息系统作为企业唯一生产工具，并将企业的客户（个人或企业）所自发贡献的信息、数据，作为生产资料，形成新兴的业务模式。这里企业的典型，就是互联网企业。 随着又一轮「数字化」的概念席卷全球，非互联网企业所面临的更多针对用户和客户的思考和探索，都需要有更快交付能力的信息系统进行支撑，这也是传统企业互联网化，打开企业边界围栏迈出的第一步。 DevOps 对于企业IT的价值 通过前文的分析，可以看到，企业IT对于三类不一样的企业价值体现各有不同。 对于互联网企业，信息系统是企业产品的命脉，企业对于软件的价值观以及投资组合，对于其他两类企业要高出很多。 DevOps 的核心价值，是能够帮助企业快速交付变更，以便于快速响应企业对于市场的变化、用户的需求。 代码 构建 测试 打包 发布 配置 监控 以上7个过程，是 DevOps 站在软件生命周期平台化运营的视角，为企业IT所建立的一个「IT for IT / IT4IT 」的业务平台。 如果说，软件开发、交付、运维是一个传统行业，那么 DevOps 就是映射了这个传统行业的一个软件平台。 通过 DevOps 可以助理企业软件交付的效率提升，帮助企业IT实现数字化运营。 可以用一句话定位以下三者在价值链上的关系 「信息」（数据） 「信息系统」（处理数据的工具） 「DevOps」（制造与维护处理数据的工具的工具） 在「信息」（数据）成为企业「生产资料」一部分的条件下，信息系统快速演进的业务驱动力、DevOps的价值，才能够清晰的得到体现。 企业IT系统的从「业务支撑型」走向「业务驱动型」的转折点，是由企业产品的最终用户，直接以低成本为企业提供生产资料——信息（数据）——并使之成为企业产品的一部分 。 如果信息是企业产品的全部，那么这种类型的企业就是第三类——互联网企业。 DevOps 在企业中的实践 和众多源于互联网的理念一样，在 DevOps 的概念被炒热之前，众多互联网公司其实已经实践了 DevOps 。 其中的原因也正是因为信息系统，是这些公司的生产工具，没有人比互联网公司的人更明白提高自身的办公效率，提高团队、企业的生产力，就是为提高企业产品的生产力进行有效的保障。 除了前文提的 DevOps 覆盖企业软件生命周期中的7个过程， DevOps 在企业落地过程中，传统企业或多或少都已经建设了一部分配套系统，尤其是AAAA与监控系统，其他的代码管理、持续集成工具也或多或少的有所积累。 DevOps 更多的是把IT服务产品化的平台，企业中的任何一个IT能力，都应当能够在 DevOps 中面向其用户提供自服务的的能力。 例如，系统的开发者，能够自主的在 DevOps 上联机分析生产环境的日志，而不必经过层层壁垒，一台台登录生产环境的主机，检索日志。 再例如，项目组的快速变更、员工的快速入、离职，都应当能够在 DevOps 中实现自动化的账号开通和注销。 需要注意的是，相比传统企业尤其是制造业的产品制造工艺和制造流程，软件产品的制造，IT服务的交付，更多的是交付一些无形的软件产品和知识工作。 正因为这些无形产品受制于不同的人认知所产生的多变，其管理复杂度远比制造业来的复杂，企业软件的设计、开发、发布、上线，缺乏标准化的管理过程。 对于如今的非互联网企业而言，能够快速见效的 DevOps 时间，应当从（环境）配置的管理，以及自动化部署。 在实施难度上，配置的管理要低于自动化部署。因为非互联网企业的技术路线由于供应商的竞争（甚至是恶意竞争），变得极其多样，架构离散化程度也很高。 对比互联网企业，（环境）配置管理和自动化部署，由于IT技术从硬件到虚拟化/容器的自主可控，企业整体技术架构的收敛性就比较理想。 当前 DevOps 对于企业架构支撑的不足 从 代码 到 监控 , 可以看出 DevOps 对于企业尚有以下不足（或者说 DevOps 本来就不考虑这些）: 缺少对企业IT战略规划、企业IT业务架构规划、企业IT系统架构设计、企业IT系统需求管理以及IT项目管理进行有效的平台化、数字化支撑。 缺少对企业IT部门、信息系统运营效能的系统性评估和优化模型 缺少对企业不同IT系统供应商的技术架构、IT产品的标准化、基线化管理。 缺少对企业数据类应用的支撑，更偏于交易型应用的交付。 对于第 1,2 两点 任何企业都有这方面的需求，但由于企业在投资组合上对这个领域投资较少，投资规模较大、实施难度较大，企业主更愿意进行面向企业产品「开源」投资。 对于第 3 点，几乎不会在秉承「自主建设」互联网公司存在，但在其他企业中也逐步会通过精益运营的方式进行落地实施。 参考资料 Wikipedia: Devops : https://en.wikipedia.org/wiki/DevOps Wikipeida: Cloud Computing : https://en.wikipedia.org/wiki/Cloud_computing Microservices : http://martinfowler.com/articles/microservices.html IT4IT : http://www.opengroup.org/IT4IT 修订历史 2016-06-01 09:51 补充价值链上的关系","tags":"ideas","title":"DevOps对于企业IT的价值"},{"url":"/articles/digitization-essence-and-foundation","text":"数字化的概念 「企业数字化」是目前媒体、市场上的热点关键词。 很多人都会困惑「数字化」、「信息化」、「自动化」、「标准化」这些概念的相互关系，好像时间又进行了一次轮回。 「数字化」给人直观的感受是与「智能设备」、「物联网」、「移动互联」、「云计算」、「大数据」等等等等，这些强IT概念联系紧密。 企业似乎只要把它们捏在一起，好像就实现了时髦的数字化转型，公司就可以和互联网、物联网联系在一起。 在这里，也许没有办法给出直接的「数字化定义」，个人对于数字化的观点，是把「数字化」理解成一种现象，一种市场语言。 数字化的本质 透过现实看本质，「数字化」战略的表象，其背后实质性的动作是「连接」。 连接产生交换 交换产生交易 交易产生市场 比较实体与虚拟连接 早在大秦帝国，秦始皇做的最了不起的事情是「书同文、车同轨、统一度量衡」。 这几件事情，是在整个国家之内统一了标准，降低了社会的沟通成本、协作成本，促进了社会的发展效率。 实体世界的连接 现实世界的实体连接，已经通过长时间的工业化得到了沉淀，比如把插头插到插座就可以使用电能。 工业标准定义了插头与插座的形状、交流电压的高低和频率。 即便是世界上没有完全统一，依然存在中国标准、美国标准、英国标准等等标准，市场上也提供了各种各样的转换适配器。 软件世界的连接 为了便于理解，对 交流电 这个概念进行展开。如果用 java 来描述一个 交流电 的最基本属性， 比如电的 伏特 ，以及 频率 ，那么两个不同的程序员，会产生两种不同的描述。 概念的代码实现 比如下面这两个代码对 交流电 实现： 我的实现 package wang.yanjiong.electronic ; import wang.yanjiong.electronic.Volt ; import wang.yanjiong.electronic.Frequency ; public interface AlternatingCurrent { Volt getVolt (); Frequency getFrequency () .... } 其他人的实现 package other.people.electronic ; public interface AC { int getVolt (); int getFrequency () .... } 可以看到两者都通过代码描述了 交流电 这个概念，但在IT这个虚拟世界内，是截然不同的两个概念代码实现。 在第一种 wang.yanjiong.electronic 这种实现方法，是对电压 ( Volt ) 和 电流 ( Frequency ) 进行了更为复杂的定义。 连接的代码实现 任何一个连接，都会有两方或者三方以上的出现。在两方的情况下，一般有： 提供方 使用方 在三方的情况下，一般有： 提供方 使用方 监管方 为例了便于表述，以两方为例： 提供方用 java 代码声明了一个接口 (API, Applicaion Programming Interface)， 便于使用方获得全世界的各种 交流电 信息： package wang.yanjiong.connect ; import wang.yanjiong.electronic.AlternatingCurrent ; public interface ProviderAPI { AlternatingCurrent [] getAlternatingCurrents (); .... } 使用方同样用 java 完成了使用代码的编写： package other.people.electronic ; public class ConsumerService { AC [] acs = ProviderAPI . getAlternatingCurrents (); .... } 很显然，使用方的代码，在编译的过程中就会出现错误，因为使用方没有 引用 提供方关于 ProviderAPI 的相关定义。 通过对这个例子的分析，提供方和使用方不在同一个虚拟世界里，两者无法进行「连接」。 进一步的，假设提供方与使用方分属于两个不同的企业，部署于两个完全物理隔离的机房，那这两者要进行一次有效的「连接」是完全不可能实现的。 数字化的基础 分领域统一标准 标准制定 通过上述两个例子的对比，在软件层面实现数字化，第一要务是实现统一「标准」。在前文的例子里，对于 电流 的描述，就应该首先被统一。 「标准」根据个人的实践和理解，包含两个要素： 概念 对于一个现象，给定一个便于理解的名称。 关系 不同概念之间的关联关系。 需要注意的是，概念来自于人的认知，而人的认知又受制于人的知识、人的经历。 标准的建立，应该是根据的目标适用领域以及对外影响范围进行。 领域划分 越是抽象的概念、越是抽象的标准，包容的万物越多，难度也越大。 某种意义下，领域的划分，也是因为一种抽象无法覆盖多个领域。现实的例子，就是社会的行业划分。 对于企业而言，标准的统一是一件相当困难的事，因为短期内效益没有体现，并且使用标准规范企业内部和外部的行为，需要有执行力的保障。 重要性评价 标准的重要性和影响面，可以通过对标准的引用次数来确定。这种模型类似于 Page Rank 。 标准的引用包含两个方面： 领域内部 领域外部 适应变化的机制 变化，来自于人的认知，来自于社会的进步，来自于科技进步对人类产生的影响，来自于对本质的深入理解，来自于方方面面。 企业信息系统，是一个高精度匹配的机器，任何一行关键代码的变更，都可能会导致整个系统无法正常工作。 一旦标准中的概念或者关系发生变化，需要有快速发现影响范围，并迅速制定有效的应对方案。 企业建立一套适应变化的机制，应当包含以下要素： 概念的文字性描述 概念的多语言代码的生成和快速引用 概念代码对应在不同视角、不同领域之间的转换和适配 变化的影响面分析 适应性变更的快速交付 MOF与MTL 概念模型 模型是表述一个领域内部概念之间关系的方法。 概念模型是在一个系统交付过程中，设计的核心之一。 根据 MOF (Meta-Object Facility) 的概念以及 ISO/IEC 19508:2014 的 Object Management Group Meta Object Facility (MOF) Core 国际标准，一个「概念」在信息系统落地的过程，可以包含层结构： 实例 -- 一个概念（在计算机系统中）的具体实例化对象 模型 -- 描述一个概念的结构的定义，类似于上文的 AlternatingCurrent 这个 Java class 元模型 -- 描述模型的模型，例如 UML 元元模型 -- 描述模型的模型的模型，例如 MOF 模型转换 正因为概念是标准的一部分、模型是描述概念的方法，所以模型的转换会同时发生在宏观和微观两个层面： 在宏观层面：当一个模型从一个领域走进另外一个领域 在微观层面：当一个模型从领域中的一个视角转换为另外一个视角 描述模型转换这件事，有专门的语言: MTL ( Model transformation language )。 ATLAS Transformation Language 是 MTL 的一个实现。 扩展阅读 Page Rank : https://en.wikipedia.org/wiki/PageRank MOF : https://en.wikipedia.org/wiki/Meta-Object_Facility MOF 2.5 : http://www.omg.org/spec/MOF/2.5/ ISO/IEC 19508:2014 : http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=61844 UML : https://en.wikipedia.org/wiki/Unified_Modeling_Language Model transformation language : https://en.wikipedia.org/wiki/Model_transformation_language ATLAS Transformation Language : https://en.wikipedia.org/wiki/ATLAS_Transformation_Language","tags":"ideas","title":"数字化的本质和基础"},{"url":"/articles/UniqueIDGenerateStrategy","text":"「主数据」类型的生成策略 主数据是一类和客观对象产生较为紧密映射关系的数据。例如:「客户」，「产品」等等。 这一类的数据会随着时间不但进行完善和修正，整体的数据生命周期较长。 使用ID来表述这一类数据的主要侧重点有: 隐私保护 - 权重5 整体可用容量 - 权重5 单位时间可用量 - 权重2 首次生成简便性 - 权重2 后期录入简便性 - 权重4 后期迁移简便性 - 权重4 人工阅读可预判性 - 权重5 分库分表可路由性 - 权重5 其中，人工阅读可预判性包含 包含分类特征 使用定长编码 例如, 身份证号「310109190001011235」,18个数字字母字符（18字节=144bit）, 最后一位为校验位 前6位为地域分类，7至14位为生日。 「交易数据」类型的生成策略 交易数据是一类和某个活动或者行为对象相关的数据。例如「订单」，「消息」。 这一类的数据会随着时间不但进行完善和修正，整体的数据生命周期较长。 使用ID来表述这一类数据的主要侧重点有: 隐私保护 - 权重4 整体可用容量 - 权重5 单位时间可用量 - 权重5 首次生成简便性 - 权重4 后期录入简便性 - 权重3 后期迁移简便性 - 权重2 人工阅读可预判性 - 权重2 分库分表可路由性 - 权重5 其中，人工阅读可预判性包含 包含时间特征 包含源与目标特征 例如, 淘宝订单号「1799508888858080」,16个数字（16字节=128bit）, 后四位数字为分库分表策略, 前12位与时间相关。","tags":"ideas","title":"唯一性标识的生成策略"},{"url":"/articles/HTTPSpecsOverview","text":"基于HTTP的RESTFul风格，是对HTTP协议的一次功能挖掘。 Infomation类 Infomation (include all kinds of information about the Internet including historical data, tutorials, etc. A standards group or individual outside the IESG produces these informational RFCs.) 一定程度上是一类「还债」类的 RFC RFC-1945 Hypertext Transfer Protocol—HTTP/1.0, May 1996 Obsoletes类 Obsoletes 是一类被新的 RFC 替换了的 RFC ， 被替换不代表已经根据这些 RFC 所实现的软件按照新的 RFC 都进行了更新升级。 RFC-2068 : Hypertext Transfer Protocol -- HTTP/1.1, January 1997 RFC-2616 : Hypertext Transfer Protocol -- HTTP/1.1, June 1999 Standards Track类 Standards Track (expected to become Internet standards ) 是一类被期待成为互联网标准的 RFC RFC-6265 HTTP State Management Mechanism, April 2011 RFC-6797 HTTP Strict Transport Security (HSTS), November 2012 RFC-7230 HTTP/1.1 : Message Syntax and Routing, June 2014 RFC-7231 HTTP/1.1 : Semantics and Content, June 2014 RFC-7232 HTTP/1.1 : Conditional Requests, June 2014 RFC-7233 HTTP/1.1 : Range Requests, June 2014 RFC-7234 HTTP/1.1 : Caching, June 2014 RFC-7235 HTTP/1.1 : Authentication, June 2014 RFC-7236 Initial HTTP Authentication Scheme Registrations, June 2014 RFC-7237 Initial HTTP Method Registrations, June 2014 RFC-7469 Public Key Pinning Extension for HTTP, April 2015 RFC-7540 Hypertext Transfer Protocol Version 2 (HTTP/2), May 2015 RFC-7541 HPACK: Header Compression for HTTP/2, May 2015 RFC-7725 An HTTP Status Code to Report Legal Obstacles, February 2016 参考 List of RFCs IPv6.com - The role of the Internet Engineering Task Force in IPv6 development.","tags":"ideas","title":"IETF HTTP 规范概览"},{"url":"/articles/TheConflictionOfID","text":"唯一性标识 (Identity) 的缩写有「ID/Id/id/I.D.」目的是在一定的范围内，标识一个对象的唯一性。 唯一性标识的生成方法众多，典型的有 算法生成类 数据库的自动生成，例如MySQL的Auto Increment自增特性 分布式的生成算法，例如Twitter的64bit自增 SnowFlake2010 128bit长的 UUID 基于具体场景，设计相关算法，在使用时自动生成 人工输入类 纯字母 字母数字组合 唯一性标识的生成结果有两种 可转换为全数字，例如SnowFlake 16进制字符，例如UUID 唯一性标识的可用性评价维度 隐私保护 整体可用容量 单位时间可用量 首次生成简便性 后期录入简便性 后期迁移简便性 人工阅读可预判性 分库分表可路由性 一些具体的潜在的易用性维度 最好能够反映一些和具体使用场景有关的信息，例如身份证的前14位。 尽可能的短 简便的键盘输入，比如纯数字或纯小写字母","tags":"ideas","title":"唯一性标识的矛盾"},{"url":"/articles/Changing","text":"系统的上线就意味着给业务带上了手铐。（已经忘了是从哪听来的这句话了） 变是永远不变的现实情况，因为变是源自于认知的升级。 变有哪几种类型呢？假设以纯人工方式进行一项业务： 个体变了（单个职责 [ 功能 ] 变了，不影响他人） 流程变了（分工界面 [ 接口 ] 变了，会影响他人） 流量变了（功能分工都没变，就是要多安排人手 [ 水平扩容 ] ） 一般来说，一个信息系统的交付，一定是以整体需求为基础，按照瀑布或敏捷方式进行交付的。 在这个交付过程中，工程师们在落地形态上，会把一些「功能」和「接口」在物理形态上进行集成。 这样高聚合的实现设计，一方面是由于过往硬件成本过高，另一方面也是由于担心跨进程所引起的不必要性能开销。 高聚合的设计，为将来系统进行业务进化，种下了许多「技术债务」的种子。 技术债务中的很大一部分，来自于后人对「业务逻辑」的不理解，没有文档，晦涩难懂的接口名称，一团乱麻的逻辑...... 在微服务落地的过程中，当系统落地方，接手一个完整的、冗长的业务需求说明，就意味着99%的场景下，微服务不太可能实现，因为很有可能看不见拆分的原则。 也许有一种视角，就是能够知道一个企业中的全部业务流程，并对业务流程进行优化和缩短，也许这种方式是业务和技术都愿意看到的情况。 一个微服务 ( Actor ) 应该是一个职能在虚拟世界中的投影，一组微服务构成的能力域 ( Domain ) 就应该是一个部门在虚拟世界中的投影。 一个职能对应于一个微服务 ( Actor ) ，是合理的。 微服务有多少种不同结构上的拓扑形态，应该是取决于自然社会的业务形态。","tags":"ideas","title":"变是永远不变的现实情况"},{"url":"/articles/ITTheMirrorOfParallelUniverses","text":"信息系统（软件和硬件）就是从自然世界向虚拟世界的映射。 每个企业，每个行业，都以唯心的方式（意识决定形态，用自己的意识决定自己虚拟世界的形态）向虚拟世界映射。 于是，这个自然世界形成了若干个、无数个虚拟世界，也就是自然世界的若干个平行宇宙。 每个IT系统的所有者，都在想尽办法，更快、更精准的去刻画自己的平行宇宙，并在自己的宇宙里，分析自然世界，并把结果反作用于自然世界。 任何一种依靠人类体力劳动和脑力劳动的方式，最终都会比不过以「智能信息系统」自己作为映射工具的方式。 也许，正在打开的是一扇门，通往平行宇宙的一扇门。","tags":"ideas","title":"信息系统和平行宇宙"},{"url":"/articles/ArchitectArchitecture","text":"架构，是解决问题的模式。 架构师，是这个模式的设计者。 问题的出现，是因为人的贪婪。 架构的出现，是因为人的偷懒。 机器的出现，是人不想劳动。 软件的出现，是人不想思考。 架构的多变，是因为万物多变。 架构的不变，是因为万物相通。 好的架构，以不变应万变。 好的架构，省时省力省心。 好的架构，折射人的贪婪。 好的架构师，挖空心思偷懒。","tags":"ideas","title":"好的架构师，挖空心思偷懒"},{"url":"/articles/TangYuanInsightArchitecture","text":"架构定义 所谓架构，就是解决「人所遇到的问题」(简称问题)的办法。 采用什么办法解决问题，和客观的条件有关，也和当事人有关。 因此，办法会有很多种，背后所体现的理念会有不同，折射出的是不同的价值观。 好架构的定义 「好」架构，应当是对架构使用人「简单」并且「通用性强」，可以解决「很多」人的类似问题。 「好」架构，应当因地制宜，不要求额外的增加使用人的负担（比如额外采购设备，学习新的知识），增加使用人的使用成本。 煮汤圆的传统架构 煮汤圆的传统架构就是老一辈交代的煮汤圆方法。 这里所描述的煮汤圆的方法，可能只是传统煮汤圆的方法之一，大致过程描述如下 取一锅干净的冷水 把冷水煮开 把适量的汤圆放入锅中 等水再次烧开 加入冷水，以保持汤圆不被煮破 重复第4/5步若干次 汤圆变熟，捞出享用 一定还有更多方法，因为煮汤圆的过程，和锅有关，和水有关，和火力有关，和被煮的汤圆数量和大小有关，不可避免的煮汤圆的人有关，等等等等。 煮汤圆的传统架构好不好 好。理由是： 对于汤圆怎么被熟的质变过程不需要了解（不需要了解物理原理） 可视化的温度，水煮沸了，就说明温度到达100摄氏度（一个标准的大气压条件下） 对于煮汤圆的设备不需要额外添置（常见的水、锅、煤气灶就可以） 整体过程容易理解，实际操作性强（烧开加水的重复过程，三岁小孩也许都会） 好吃有卖相是煮汤圆的目标 直接目标是煮熟（基本前提） 问题是，熟是一个定性非定量的修饰词。熟，需要能够被量化，量化之后才能被管理。 于是熟的量化标准之一常常会被提及：汤圆至少要浮于水面之上。 可问题又来了，浮在水面之上的汤圆不一定能保证在咬开之后，里面的馅料也是熟的。 于是前辈们，还会告诉我们，等待汤圆略微发胖，这是提高汤圆馅料变熟的有效量化标准之一。因为胖，是肉眼可见，是可被量化管理的对象。 间接目标是不煮破不煮糊（还得有卖相） 由于汤圆的外部材料主要是糯米，糯米遇到水之后，尤其是沸水，会发生结构分解（是不是分子，因为作者不是食品和高分子学专家，不能细讲，也不能乱讲），其最终结果就是煮糊了，也就是糯米和水完全融合了在一起，汤圆已经没有了型。 因为怕煮烂，所以老一辈会特别强调，加入反复加入冷水，让水保持在似开非开的状态。 这种方法，一方面是保持煮汤圆所需要的温度，一方面是降低沸水所造成的汤圆不必要的翻动，避免加速汤圆煮烂。 把煮熟汤圆「好吃」的关键要素（根据现象看本质） 热能 热能，是使汤圆从生到熟发生变化的核心、必要条件。没有变熟所需要的热能，并保持在合理的温度，汤圆静静的放在那里，永远不会变熟（但可能会变质）。 时间 时间，是控制汤圆发生质变的必要条件。时间需要和温度配合，才能达到让汤圆变熟的目的。 潜意识的基本假设 不管多少类型的汤圆，大小基本固定，一般条件下，手工汤圆的大小，要比速冻机械制作的汤圆大一圈。 被忽视的核心要素 汤圆在被煮前的基本物理条件，是直接从冷冻室内取出，还是常温。 需要注意的是，沸水和汤圆糯米外皮的物理接触，是热能的第一道传导方式。汤圆的糯米外皮和馅料，是第二道传导方式。 糯米外皮与馅料的热传导方式相比把水煮沸是缓慢的，换句话说，糯米皮和馅料，是热的不良导体，导热性能比水差。 同时，冰冻的馅料变熟所需要的热能要比常温馅料的多，但热传导的效率基本不变。 在冰冻的状态下进行直接加热，势必造成加热的时间变长，这样一来，汤圆的糯米更容易发生煮烂，如果还采用翻滚的沸水煮，很难避免汤圆煮烂、馅刚熟的情况发生。 所以，在煮汤圆之前，最好把冰冻的汤圆从冰箱取出，在室温下放置一段时间。 到底要如何煮汤圆 煮汤圆的基本概念 汤圆本身、一次煮汤圆的总体数量、锅的容量、热源功率、热源功率的可条件范围。 煮汤圆的领域分解 原材料供应商（汤圆） 煮汤圆平台-热能供应商（天然气灶、煤气灶、电磁炉、电陶炉、煤球炉、煤油炉、烧柴火的灶等等） 需要注意的是：这些热提供商的性能指标并不相同。比如，热功率（单位时间所提供的热能）提供热能可调节的范围。 作者直观感受是：现代化的天然气灶、煤气灶、电磁炉，热功率可调节范围要大于煤球炉和烧柴火的灶。 煮汤圆平台-恒温水容器供应商（水和锅） 高中物理，告诉我们，水的比热容是很高的。所谓比热容，说的通俗一点，就是温度升高一度，所需要的（热）能量。 所以，一个大锅里盛满的沸水，要比一个小锅盛满的沸水，所储藏的（热）能量多。 煮汤圆平台-熟汤圆交付集成商（煮汤圆的人） 煮汤圆的人，首先要评估要煮的汤圆有多少，热能的获得方式是什么、可调节性有多强，锅有多大、里面可以放多少水。 煮汤圆的基本流程 用锅把水烧开 下生汤圆，以最快的速度把水加热并接近沸点（接近水的沸点） 在一段时间，保持一定的水温（接近沸点，避免沸水翻滚以保持汤圆卖相），直至变熟（汤圆上浮和变胖） 又快又好把汤圆煮熟（最佳实践） 找尽可能大的锅 大锅，意味着可以放更多的水。在把一批汤圆放入到沸水中之后，由于汤圆和水会直接发生热交换，导致水温降低，水的温度直接从沸点下降。 举个极端的例子，在正在煮沸的一锅沸水中加入一滴常温的水，那么整个锅里的水，还将是煮沸的状态。原因是： 一滴常温水，变成沸水的所需要的热量，热能提供商（比如煤气灶）可以快速提供。 沸水的流动性，使得沸水和常温水的物理接触面增多，热交换速度变快。 这个极端的例子告诉我们，由于一滴水加热至沸点的能量，远小于蒸锅沸水的能量，所以蒸锅水在此过程中，水温基本不变。 回到煮汤圆的场景，大锅意味着加入常温的汤圆水温下降会变少。 持续的高水温，有利于提高热传导的进行（势能差越大，能量交换越快），有利于缩短煮熟汤圆的时间，保持汤圆的卖相。 把热源的功率发挥到最大 快速提供热能，使放入生冷汤圆的之后水温迅速提高，需要两方面的配合: 把热源开到最大（例如，把煤气灶开大火） 增加火和锅的接触面积（选择平底锅和煤气灶，并把锅底放在煤气灶的火焰温度最高的外焰位置） 保持准沸水的水温 保持略接近于沸水的水温，获得最高效率的热传递同时，避免水的翻动导致汤圆解体。 煮汤圆的锅，自身是具备一定散热功能的（在没有热源加热的情况下，水会停止沸腾和逐渐冷却至常温） 在热源最小输出热能的情况下，需要加入冷水，才能保持水温在沸点以下，避免不必要的水沸腾动能释放，引起汤圆破相。 非常规的花式煮汤圆秘籍（聪明人秀才艺） 在家煮汤圆不反复加水 前文所提到的，保持水温似开非开，是达成快速、不破相煮汤圆的必要条件。 在当煮汤圆的装备得到技术革新之后，我们可以做到把热源功率变小，平衡锅自身散热和热源供给的平衡。 同时，可以把锅容器，替换为玻璃材质，例如采用全玻璃锅，采用热功率无级可变的燃气和电气炉具。 这样整个煮汤圆过程全程关上盖子，水蒸气蒸发所带走的热能，也能看到水是否被煮开。 在实际操作过程中，只要保持水微微有些被煮沸，不对汤圆产生结构性破坏力。温度的用肉眼量化，结合控制火力大小的闭环控制。 这样做的好处是，增加了煮汤圆的机械化可能，减少了过程中，对于加水这一环节的依赖，减少了对水的需求，增加了能源利用率。 饭店煮汤圆「生熟混煮」 当然，控制水温的另外一个方法是，把加水，替换为加「生」汤圆。 这种方法，对于执行人的个人素质和能力要求更高，需要相当的实际操作经验。 其实，笔者相信，摄氏99度煮出来的汤圆，也是「熟」的。 智能煮汤圆产品设计（延伸阅读） 这里要表达的是，技术其实是可以给业务带来革新。 煮了一辈子汤圆的人（业务方），可能一辈子都不会提出「智能」煮汤圆的技术需求。 设计理念: 煮汤圆应该是不需要操心的，我只要「好吃」和「卖相好」的汤圆。 食客（吃汤圆的人）只要买来汤圆，把汤圆投进煮汤圆机里，在汤圆被煮好的情况下会自动提示食客来享用，甚至自动放到碗里。 突破技术限制 技术限制: 识别汤圆馅变熟 目前被传承的量化方法是「上浮」和「变胖」 目前需要最佳实践帮助和知道的是：上浮之后再煮多久 技术突破: 数字化汤圆馅变熟的技术指标 定位汤圆（因为水和汤圆的混合物，密度不一样） 判断汤圆馅料的温度（在前一步的基础上，采用热感应?超声波频谱?的方式(请原谅作者对于这一领域缺乏了解)） 恒温控制，保持水温接近于沸点但未到达沸点，避免由水的沸腾导致破相（笔者相信「99度」也能煮「熟」汤圆，当然这是在一个标准大气压的条件下） 降低数字化成本，以控制产品的整体成品，使其变为消费品而不是概念产品或者奢侈品。 口碑营销 消费者惊奇的发现，「智能煮汤圆机」其实还能煮馄饨、煮饺子...","tags":"ideas","title":"从元宵节煮汤圆看架构的识别与设计"},{"url":"/articles/PUMLMacOSXAtomEditor","text":"Atom的插件: plantuml-viewer 它支持 对 plantuml 文本直接进行进行预览，不需要依赖 plantuml.jar 支持另存为 svg , eps , png 基础环境 brew cask brew install caskroom/cask/brew-cask pandoc brew install graphviz 编写与预览 Atom brew cask install atom Atom 插件 plantuml-viewer language-plantuml 不推荐的Atom插件 plantuml-preview 理由: 还需要依赖 plantuml.jar , 它在这里 其他相关 Chome Extension: PlantUML Viewer ，它实际上使用的是 PlantUML Server 进行图片的实时生成 支持中文，但字体渲染不够好 首行必须是 @startuml ，否则无法阅览 Firefox Add-ons: 暂时未找到 基于IntelliJ IDEA的扩展: PlantUML integration Eclipse Plugin 效果","tags":"experiences","title":"用Atom在Mac OS X 下编辑PlantUML"},{"url":"/articles/AutoRepair4SEnterpriseSoftwareEvolution","text":"汽车已经成为中国大城市家庭出行主要方式之一，随之出现的大大小小事故，可能每位车主都会经历。 如果出现一次多方事故，责任方，交警，保险公司，一定会成为事故处理的必要成员，很多时候定损中心也是大概率出现的主角。 一站式修车（定损，维修，理赔），目前对于无责方而言，仍是困难重重。 差评级汽车4S店维修服务 这里，只聚焦维修过程，来看看「差评级汽车4S店维修服务」,背后折射出多少汽车服务行业管理水平与汽车服务企业软件的支撑力不足。 首先，来体验一下一次真实的「差评级」的维修服务，涉及的汽车品牌则是德国三大汽车制造商巨头之一： 车主在送车维修（维修部位为倒车雷达）过程中，在4S店的等待时间过长。 车主在根据维修服务合同，准备取车前，2次主动电话联系4S店以确认准确的提车时间，都无法直接联系到接待专员。 在上述每次沟通过程中，4S店接线员都需要询问车主姓名、被修车辆车牌号、联系电话以及接待的维修服务顾问姓名。 当车主提车之后，车主以绝对信任的心态直接把车开走（没有对维修部位做复查），但在上路之后，发现需要更换新的倒车雷达竟然没有安装。 车主返店再维修过程中，店方无人主动接待，依靠车主自己根据回忆服务专员脸部特征、体貌特征，人肉找到服务专员，进行投诉。 以上几点，处处都体现了企业的管理水平不到位，企业软件支撑不到位。 要强调的是，软件对于传统企业来说不是技术，而是帮助企业业务运营和流程管理的有力工具。对于汽车制造商、服务商而言，软件使用成本则占企业运营总成本的一小部分。 企业软件架构升级方向 对于各大品牌的汽车4S店来说，改进客户体验，保证乃至品牌形象，已经成为企业经营不可或缺的一环。从企业软件角度，至少可以有以下改进： 汽车品牌商，以公有云为基础，统一各个4S店的各个内部信息系统，例如电话语音、客户管理、维修管理等等。每个4S店都将成为公有云的租户。 打通内部信息系统，例如IVR(Interactive Voice Response, 互动式语音应答)系统、CRM(Customer Relationship Management, 客户关系管理系统)、车辆维修系统，实现对客户身份的即时识别。 增加手持移动设备（例如智能手机、平板电脑）的支撑（如喷漆钣金之类的维修项目）需要做到接待专员的（维修前before，维修后after）拍照存档，提高向客户交车前的质量保障水平。这也是移动化改变业务流程的典型场景。 打通内部系统与互联网公众账号运营，增加客户自服务能力。例如，客户不需要打电话查询维修车辆的维修进度、提车时间，减少客户与服务商的无效沟通成本。 汽车服务企业，可以通过与互联网社交平台的对接，实现修理过程透明化，每个关键环节都可以有数字照片直接通过社交平台推送给客户。 与互联网消费者服务评价平台对接，实现客户满意度向企业运营决策层的消息直达，减少满意度由第三方转述的信息丢失与走样。 可以看出，传统服务行业，在移动互联时代，传统服务性行业的企业软件已经滞后于社会信息化发展。 云计算与移动化，企业内部多系统实时数据互通，内部系统与互联网社交平台的集成，已经成为改善传统服务行业客户体验的必然之路。 传统企业的软件架构，背后折射的是企业整体的业务管理水平；企业业务的升级，需要背后企业软件架构的升级。","tags":"ideas","title":"从「差评级汽车4S店维修服务」看汽车服务行业的企业软件发展空间"},{"url":"/articles/TheOperationableEnterpriceITPlatform","text":"平台生产力 技术成本 学习成本 使用成本 维护成本 沟通成本 业务与技术团队沟通 技术团队内部沟通 业务价值 业务需求交付速度 业务创新力支撑 平台可运营评价维度 人员素质可发展 技术架构自主性 业务支撑连续性 上下游协作友好 管理制度平台化 平台产力提升途径 平台自动化程度 代码生成 文档生成 上下游协作流程 协作自助化程度 生产资料获得方式 社会化提问与答疑，质量与影响范围量化评估","tags":"ideas","title":"可运营的企业IT平台"},{"url":"/articles/RSTMacOSXAtomEditor","text":"基础环境 brew cask brew install caskroom/cask/brew-cask pandoc brew install pandoc 工具 Atom brew cask install atom Atom 插件 language-restructuredtext (预览首选) rst-preview-pandoc (预览备选) rst-preview 设置 rst-preview-pandoc 设置 pandoc path , 通过 brew install 的工具，一般都位于 /usr/local/bin 采用 rst-preview-pandoc 时，可以忽略 Bugfix 1 在设置 pandoc path 后，应当不会出现 Bugfix 2 Bugfix rst-preview Live preview not working Atom 1.0.11 ~/.atom/packages/rst-preview/lib/rst-preview.coffee # line 76-77 # grammars = atom.config.get('rst-preview.grammars') ? [] # return unless editor.getGrammar().scopeName in grammars Workaround on OSX for pandoc could not be spawned error ~/.atom/init.coffee process.env.PATH = [\"/usr/bin\", \"/usr/local/bin\", ].join(\":\") 效果","tags":"experiences","title":"用Atom在Mac OS X 下编辑reStructuredText"},{"url":"/articles/TraditionalVsInternetEnterpriseSoftwareValues","text":"从单个计算机到互联网 在中国大陆，计算机有一个更为形象的名字，电脑。从字面可以看出，它是一件帮助人类进行思考的机器。但决定计算机思考什么，如何进行思考的，就是程序。 把人类脑袋中的可重复的、机械性的脑力劳动，变为机器可重复执行的程序，这个过程就是软件过程。 在计算机诞生之初，它所要解决的问题是科学计算，也因此得名计算机。可以想象，一个计算机的计算能力是有限的，但有了计算机网络，使得成千上万，乃至上亿的计算机可以协同工作，并形成更大的计算能力，也就为解放人类机械性脑里劳动，带来了想象空间。计算机也从科学家手里，走进了如今的平常百姓家。 要让计算机为普通百姓服务，从衣食住行医多方面提高人们的生活质量，其先决条件是信息化。信息化，是将一件事情或者一个物品或者一个时间或者定量货币，以数字化的方式精确量化下来。随着计算机硬件的不断发展，整个社会的信息化成本逐步降低。从而，人与人的通信、交易过程方便的可以信息化，并在此基础之上形成如今的各种面相个人的互联网产品：例如，社交应用、电子商务、第三方支付、个人信贷平台。 ### 现今的互联网特征 现在的互联网公司是以轻资产行业——除了计算机及网络本身，不需要其他生产工具的行业——为切入点，以数字化逐步改变了人的沟通方式、人的消费方式，乃至生活方式。 如今互联网公司普遍具有以下三个特征： 面向个人消费者（B2C） 由于用户基数大，以计算机（含网络和存储）为生产工具的互联网公司，为单个用户服务的边际成本低，并且规模效应大。 轻资产距离实体经济较远 无论是蓬勃发展的社交应用（微信、微博），电子商务平台（淘宝、京东），还是个人金融（P2P金融），都远离消费品制造本身。即便是电商平台，与实体密切相关的是自身仓储信息化，物流环节则是和合作伙伴公司进行信息系统对接。电商平台，绕开了消费品诞生最为复杂的生产制造环节。 经营虚拟对象 无论是淘宝、或者大众点评，在显而易见的商业交易背后，有着对个人主观感受、人际关系这些虚拟概念的经营，并将其与商业过程进行良好无缝的融合，促进个人消费市场生态的良性发展。即便像是百度、谷歌这样的搜索行业寡头，也是以广告、产品推广作为盈利模式，根本上还是通过技术手段尽可能拉近买卖双方的距离。 所以，互联网公司的生产资料是一些看不见、摸不着的\"关系\"，这也导致了互联网所极力倡导的用户体验，快速交付。因为这些生产资料，任何一家公司都可以触手可及，唯有与众不同和贴心，方能获得用户的长期青睐。 传统行业的企业信息系统 在传统行业里，有三大社会基础设施类行业的系统建设规模较大，它们是金融、电信、能源行业，每个企业所拥有的应用系统数量是成百上千，单个企业所使用的计算机规模也在数万至百万，或者更多。 放眼传统金融行业，例如银行、证券、保险等细分行业，信息系统也是企业的核心生产工具。与第三方支付平台不同，商业银行有着社会基础设施的不可替代性，导致了其信息系统建设理念与互联网公司有着天壤之别，因为数据既是货币，所有交付行为都通过系统完成，所以其宗旨是在以账务为核心的会计准侧下，确保稳定、可靠零差错。 电信、能源，都是以国家级重资产投资为核心的基础行业，其业务模式较为稳定，行业竞争性弱，主要受国家政策影响大。这类行业的信息系统主要解决两个方面的问题，重资产（数亿计的电信设备、电力设备）的信息化管理维护，面向个人与企业的业务营销，账务核销。 为什么其他诸如工业制造行业的大公司（比如美国通用电气，德国西门子，德国大众汽车）信息系统并没有得到普通大众的关注呢？一个重要原因就是实体本身对一个行业业务模式变化的牵制作用。以汽车制造为例，其主营业务是设计和制造整车，信息系统的主要作用是一方面对物料、排产、供应链进行管理，另一方面对主营业务起支撑或者提高跨部门、供应商协作效率的作用。可以想象，并不会因为IT系统的一次变更上线，就直接诞生一个汽车的新产品，但很有可能是打通了来自于最终用户的个性化订单这个渠道。但在如今的互联网行业，一次IT系统变更上线，就可能具有行业的颠覆性。 面对实体经济，面对工业制造行业，信息系统并不能像互联网一样，具备核心生产工具的地位。工业4.0和物联网，所涉猎的信息系统变革，其效果是加快企业对市场、对最终用户使用效果的感知，加快企业内外部实体多维度状态的感知，提高企业内部和上下游厂商的协作效率，从而整体提高社会实体经济的生产效率。 ### 重视软件交付过程 通常一个具有人机交互功能（也就是带可视化操作界面）的企业信息系统，称之为应用系统。一个最简单的应用系统会包含前端可视化操作界面（Web）、后端业务逻辑（Service）、底层数据库（Database）以及存储（Storage）三个组成部分。将这样一个应用系统交付给企业内部的员工进行使用，以传统的软件工程方式进行建设，需要经过软件生命周期的六大阶段：需求分析、架构设计、编码实现、测试验证、上线运行、后期维护。 对于复杂的应用系统，架构会变得更加复杂。这两者之间的差异，有着类似单间平房与摩天大楼的区别。其建设方法，制造工艺，也有显著区别。 对于一个复杂应用系统，可能由不同的团队协作完成。这和建筑行业有负责基建、负责内部装修的不同工程承包商类似。每个工程分包团队只完成其专业领域的那部分，工程整体由总承包商进行统筹管理。 对于一个复杂应用系统，可能采用一些通用的技术组件。这和建筑行业有不同标号的水泥，螺纹钢筋、光圆钢筋等不同规格类似。物料供应商则根据国际国家标准进行批量标准生产。在IT行业，这种通用组件则被称为中间件或基础软件。它的通用性并没有国际国家的强制标准，一般都以某一产品领域寡头的实施标准作为参考依据。 而被非IT行业所广为熟知的程序员，则是编码实现这一环节的生力军，这一环节负责把业务需求变为代码，从而实现系统的业务功能。鲜为人知的架构师，则需要从业务需求、功能开发、测试验证、后期运维等多角度确定系统的基本框架，犹如确定一幢高楼大厦的主体结构。 可以发现，人是信息系统的制造者，不同资历的从业人员，所交付的信息系统质量会有所不同。这类似实木家具的手工制作过程，不同技艺的工人，所制作的家具精致程度不一。 虽然可以有方法论、软件工程学来指导和规范软件交付的过程，但软件最终是为一个企业或者组织提供相匹配服务，不同的行业特征、不同的信息技术发展时期、不同的组织结构、不同的系统建设方式，导致了世界上找不到两个一模一样的最终交付使用的信息系统，就好比世界上找不到两片一模一样的树叶。 软件价值观 互联网公司 互联网公司的系统作为生产工具，一般都由自己员工进行开发、测试、维护。对外采购行为大多集中于主机、网络、存储等硬件设备。对于系统建设的理念是自主可控，为的是拥有极佳的业务变更适应性。另外，从互联网公司的业务视角出发，其信息系统可以根据行业特征进行优化，一般不采购上文所提到的中间件或者基础软件，大多使用免费开源的软件框架。 传统行业 传统行业的信息系统，作为业务支撑平台，一般都以自有信息化部门牵头招标，以对外采购软件产品配合系统集成商服务，对中间件产品进行二次开发，从而实现业务功能的交付。企业主体通常不具备自开发能力，依赖于外部资源。从软件生命周期角度，开发、测试、运维三大团体也很有可能分属不同的集成商，甚至是外包人员。 投资构成比较 以同样的投资成本，互联网公司愿意使用零成本的开源中间件和100%的人力成本，进行系统建设。而传统企业，则会使用90%以上的投资进行对外产品和服务采购，余下的10%则作为甲方的信息化办公室团队人员成本。 即便是互联网公司所提出的去IOE（IBM, Oracle, EMC）口号向传统行业蔓延，但传统行业所需要的人才储备却远远跟不上转型需要。 信息技术的社会价值 互联网＋／ 工业4.0 对于传统行业，\"互联网＋\"或者\"工业4.0\"更多层面是引导以信息化优化生产过程，提高生产效率，不可能也不能照搬互联网以计算机系统作为生产工具的行业模式。 \"大众创业，万众创新\" 轻资产的互联网经济，已经被发展十余年拥有雄厚资金实力的互联网公司所操控。新想法，新创意可以被他们轻易复制和超越。 创业和创新的社会环境，面对普通大众，也许成功的只有彩票级的概率吧。 社会老龄化与延迟退休 中国社会老龄化已经是一个不争的事实，其导致的问题是社会青壮年所创造的社会财富无法供养不参与社会劳动的老年人。 直观的做法是以劳动人口数量直接来弥补社会劳动力的缺失，以创造足够的财富供养老人。 中国劳动人口基数庞大，如果信息化手段能够提高社会生产效率，也许能够降低延迟退休政策所引起的群体排斥心理。","tags":"ideas","title":"传统企业与互联网企业的软件价值观"},{"url":"/articles/MacOSXEnvironment","text":"Mail Mail.app Browser Chrome (Extensions) SwitchyOmega 1Password AdBlock Plus Evernote Chrome (App) Postman Gliffy ProcessOn Firefox (Adds-on) Firebug FoxyProxy Firegesture 1Password AdBlock Plus Evernote RSS Reeder 3 Editor & IDE Sublime Text Atom Mou / MacDown BBEditor IntelliJ IDEA PyCharm Version Control SourceTree Cornerstone DataBase Navicat Notebook Evernote Security 1password Efficiency Alfred Powerpack Spectacle iTerm2 zsh + oh-my-zsh Homebrew + homebrew cask RamDisk Automator Shell Socks5 socat / netcat Synchronize Dropbox Calendar LunarCal Fantastical Remote SecureCRT CoRD","tags":"experiences","title":"Mac OS X环境"},{"url":"/articles/pelican-toc-plugin","text":"插件准备 使用 extract_toc 执行 git clone https://github.com/getpelican/pelican-plugins.git 修改配置文件 文件： pelicanconf.py 指定插件目录 PLUGIN_PATHS = ['<your_path>/getpelican/pelican-plugins'] 启用插件 PLUGINS = ['extract_toc'] Markdown标记 插入 [TOC] 标签，例如： title: Pelican TOC Plugin date: 2015-10-16 modified: 2015-10-17 tags: pelican category: pelican [TOC] ### 插件准备","tags":"experiences","title":"Pelican TOC Plugin"},{"url":"/articles/TakeTimeAsAFriend","text":"李笑来：《把时间当做朋友》 能力： 我们要努力，我们要坚持，我们要学习，我们要有志向，即使不是那么远大 欲望：守住自己的心 幸福=能力-欲望 我要的幸福： 我曾经历了许许多多，现在，我似乎明白了什么是幸福，在乡下恬静的隐居，尽可能对人们做些简单而有用的善事，尽管那些人们并不习惯我为他们做了这些，做一份真正有用的工作，最后休息，享受大自然，读书，听音乐，爱周围的每一个人。这就是我对幸福的诠释。在这些之上，有你为伴，也许还有我们的孩子，一个男人还能再渴望些什么呢？ ——列夫 托尔斯泰《家庭幸福》 I have lived through much, and now I think I have found what is needed for happiness. A quiet secluded life in the country, with the possibility of being useful to people to whom it is easy to do good, and who are not accustomed to have it done to them. And work which one hopes may be of some use. Then rest, nature, books, music, love for one's neighbor. Such is my idea of happiness. And then, on top of all that, you for a mate, and children perhaps. What more can the heart of a man desire? — Leo Tolstoy 《Family Happiness》 \"要管理的不是时间，而是自己。人们生活在同一个世界，却又各自生活在自己的那个版本之中。改变自己，就意味着属于自己的那个版本的世界将随之而变，其中也包括时间的属性。开启自己的心智，让自己能够用最可能准确的方式思考、观察、记录、总结、分享和行动，那么自己的时间就会拥有不同的质量，进而整个生活都必然因此焕然一新。\" //#心声#，对自己不满首先要做的是改变自己。 苏格拉底揭示所谓的思考过程不过是\"提问和回答\"。 而千百年后培根说得更加全面：\"读书使人完整，讨论使人完备，写作使人完善\"。 //#心声#现在真正读书的人比例不高，进而真正\"讨论\"而不是\"争论\"的人更少，能总结写博客的少之又少。\"微时代\"是个机器浮躁的时代，没多少人能够沉下心做大事。 \"没时间了\"，其可怕程度几乎无异于死亡。死亡是所有人都要面临的终极困境——没有解决方案的困境。...... 死亡本身其实并不可怕，面临死亡的过程才真正可怕。如此，就很容易地体会那些\"既勤奋又懒惰\"的学生，面临的是怎样的悲惨境遇了。......但是生活中明显有另外一些人——尽管数量上并不占优——在用另外一种状态生活。他们从容，他们优雅，他们善于化解各种压力，安静地去做他们认为应该做的事情，并总能有所成就。他们甚至可以达到常人无法想象的境界——不以物喜，不以己悲。 总的来说，一方面是自己的欲望无限，一方面是要完成的事情太多，一方面是自我满意度的不断下降——这就是人们总是不由自主地期望速成的根源。出路肯定存在，但这出路只有一个起点——接受现实。告诉自己：我有不足，我需要时间，我没办法一蹴而就。 积累多的人之所以稳健，是因为对他来说，\"我要\"的欲望可以用\"我有\"的东西来满足。即便\"我有\"暂时不够，他也能借助已经拥有的足够努力和勤奋（抑或投机取巧的方法和经验），只需假以时日，定能如愿以偿。一旦得偿所愿，不仅\"我有\"的更多，\"我要\"的也更容易获得，如此形成良性循环。 //#心声#，其实抑或投机取巧的方法和经验，我并不赞同。 尽管天分确实很重要，但一个人的能力主要靠积累获得。从一个人开始从事一个职业的那一瞬间起，只要足够认真、努力，他的能力就会不停地积累。如果这个人实际上向往的是另一个职业，那么他的所谓\"梦想\"几乎必然是他在当前这份职业上心不在焉、无甚积累。其实，世界上80%以上的职业并不过分依赖天分，更可能甚至几乎只依赖积累。天长日久，这个人的当前的职业中将逐渐落后于那些认真做事的人。但此时他不会因为自己的落后而奋起直追，反过来，更可能的是把\"反正我的梦想不是这个\"当做借口。 //#坚持·勤奋·认真# 越是不满现状，摆脱现状的欲望就越强烈，而这种欲望会让一个人最终迷失方向，因为无论是谁，从本质上看都无法摆脱现状——每一时刻的现状都是过去某一或者某些时刻的结果，而每一时刻的现状都是未来或者某些时刻的原因。没有人能够逃脱现实的束缚。 从某种意义上理解，\"逆境造就成功\"、\"磨难令人成熟\"之类的话纯属胡说八道。显然，在顺境中更容易成功，而且很多磨难根本没有必要——这更可能是失败者对他们自己一生都未曾有机会体验的成功及成功者\"意淫\"式的猜想而已。失败者永远没有机会了解成功的真相，因为人最容易受自身经验的限制，而不曾有哪怕一点点成功经验的人更无从摆脱自身的局限。 //引申到我的个人观点：没有必要去刻意吃苦，但绝对有必要能吃得起苦。 几乎一切愚蠢的欣慰都来自否定现实、逃避现实，只有接受现实，才可能脚踏实地，避免心浮气躁、好高骛远。如果我们把成功朴素的定义为\"用正确的方法做正确的事情，并在最后期限之前漂亮地完成\"的话，那么，大多数所谓的\"时间管理技巧\"实际上发挥不了多大的作用，只不过是花拳绣腿。真正有用的往往是简单而又朴素的道理，例如\"现实只能接受\"。 怎样判断所做的事情是否正确？核心只有一个：看它是否现实。 很多人一生都不知道自己究竟有多么不现实。之前提到的\"勤奋又懒惰\"的人群，基本上都是把这些现实当做老生常谈的道理——视而不见、听而不闻、从不记录、从不反省，才常常作出荒唐的决定，最终堕落到那分田地。 //现实——脚踏实地，稳扎稳打，步步为营 两点之间的最短距离是恶性循环。——墨菲拓扑定律 //这句话，也许对我曾经对很多人举过的一个例子的反面高度抽象。 为了实现一个目标A，可以借助旁人的力量，直接获得A。也可以通过自己的实践获得A，同时在这过程中收获方法B，副产品结果C。 这是实现自我价值提升的良性循环。#技多不压身# 事实上，那些真正能够做对、做好的人，绝不会随意嘲弄、打击别人，因为他们是做对过、做好过的人，他们一路走过来，心里非常清楚做对、做好有多么不易，所以，他们会不吝一切机会去鼓励那些尝试做事情的人。这甚至可以当做一种测试方法：如果一个人经常嘲弄他人，那只能说明他自己不怎么样；否则，他会想那些极少数已经做对、做好的人一样，给予别人真诚的鼓励而非嘲弄。尽管那些能做对、做好的人又是也会给出负面评价，但这些评价通常是\"建设性的负面评价\"，并不是为了获得优越感而发出的嘲弄。 所以，我们没有必要在意来自他人的、非建设性的负面评价。没有谁从一开始就能做对、做好。所有做对、做好的人都是一路磕磕碰碰走过来的，这就是生活常态。而动辄给出非建设性负面评价的人，往往不是正经做事的人，他们和那些正经做事的人身处不一样的世界，这也是生活常态。 //只见贼吃肉，不见贼挨打的现象的是非常普遍的；那些尝试做事情的人，是孺子可教的人，他们在努力，需要被鼓励，需要被肯定。 更重要的是，人在小时候没什么事情可做，就愈发感觉时间过的慢；随着年龄的增加，要做的事情越来越多，当然就愈发觉得时间过得飞快，稍纵即逝。由此看来，小孩子的感觉自然是\"那时候天总是很蓝，日子总过的太慢\"，而\"人生犹如白驹过隙，瞬间而已\"大都是老年人的慨叹，也是他们的切身感受。 //时间有限，精力有限，我们不能什么都想要。幸福=能力-欲望。 所有真正做事的人都知道，任何任务的绝大部分都是枯燥而又无趣的，所谓有创意的部分，可能连1%都不到。对此，我有切实体会。 //就像爬山，枯燥而无趣地拾阶而上，为的只是站在最高点欣赏一览众山小的壮丽美景。 但不是每个人都有毅力坚持到最后，也不是每个人都有能力坚持到最后。毅力需要培养，能力需要积累。 而培养和积累的过程会很漫长，会很艰苦，会感觉到累，这就对了，说明在向上走。 //往上走，即便是一小步，也有新高度。 //我也会向众人提起，\"我喜欢做有创意的事情\"，但，我会为了这1%去做99%的枯燥的事情。 实现目标之后，再设定下一个1%。这样，人生就丰富了，并且不是简单的丰富了。 做任何事情，学会思考方式最为重要。要学着像一个项目管理者那样思考——他们更多关注\"方法\"，他们会花费比别人多（多出许多倍）的事件去落实每一个步骤。 在做任何事情之前，通过关注\"方法\"去反复拆分任务，最终确认每个子任务都是可完成的，这是一个人不可或缺的功课。 这样的习惯，会使得一个人变得现实、踏实。 这既是一种习惯，也是一种后天习得的技能。这种技能无比重要，却常常被忽视，业务掌握这种技能的人总是默默地应用它，而忽视这种技能的人从未看到过它的具体实施过程和巨大好处。 //#授人以鱼不如授人以渔#，珍惜每一次被授人以渔的机会，好的方法是节省时间的方法。书是前人对思考的系统总结和归纳，书传授的是方法。从小我们就被熏陶\"书是人类进步的阶梯\"，但不一定真真理解。（这里的书不是指小说，虽然它有时候也具备一定这样的功能，但需要自己具备归纳总结的能力） 与所有人一样，从小自命不凡的我当然也给自己贴过各种各样的标签。我崇尚公正，向往自由，渴望平等，憧憬希望。在相当长的一段时间里，我感受到的是禁锢，体会到的是差距，意识到的是失望。我现在猜想，或许所有人都必然要经历这样一个阶段，不过只有少数人能够度过这一阶段。 直接来自感官的认识很容易与他人分享，而思想上的体验却往往难以用语言表达。 //#心声#，何况我语文又那么差。 在与计划相关的格言中，我最喜欢的是：\"我们不是计划着去失败，而是失败地计划\"。 所有真正执行到底的计划，都是因为其目标现实可行。 有人说\"计划总是没有变化快\"。这句话听上去挺现实，缺没说到点子上。计划总是被变化打乱的深层次的原因在于：计划过于长远。事实上，无论变化多快，计划总是要有的，只是在制定计划的时候，应该考虑到变化，应该以自身的情况分析自家究竟适合制定多久的计划。 做长期计划显然是正确必需的，但是，并非每个人都有制定长期计划的的能力。这种能力可跻身最重要的能力之位，拥有它需要挣扎、需要努力、需要从一点一滴做起。 不要上来就制定过长的计划。 哪怕制定一个星期的计划，都不是很容易的事情——实际做一下就知道了。 //当每本书看到接近于一半位置的时候，是最惬意的。因为可以把书妥妥的平放，不用手压，全神贯注地与作者交流。翻书的声音很悦耳。 计划固然重要，行动更为重要。 如果想做事，当然要行动。行动是改变自己的众多方法中最有效、最直接的方法。很多时候，只要开始行动，哪怕实现并无计划，往往也会有收获。但是反过来，缺乏行动的计划肯定没有任何意义。 如果想要改变自己，或者对自己目前的处境不满意，那就一切从简——找一个你觉得应该会带来改变的任务，然后去做就是了。不要怕碰壁，不要怕失败，那是必须经历的过程。失败并不可怕，因为人总是要失败许多次才会得到结果，况且全天下又不是只有你会失败，怕什么？达成目标的关键在于每次受到挫折之后能否汲取教训。只要能汲取教训，然后自我调整，那就是进步。我们一生所做的事，大都是在试错，对于人生，没有人能像解释数学或物理学那样给出普适的公式。 永远记住，马上行动是最重要的——尽管这句话已经被无数人所过无数次。 //有多少人，其实是被自己拖死的。如果没有勇气去接受失败，那么也没有机会去获得成功。曾几何时，有人对我的评价是执行力强，雷厉风行。 很多人常常拒绝学习，他们拒绝学习的理由和那些痴迷学习的人一样——不知道它有什么用。 如果说，车是人类腿脚的延伸——使人们走得更远，望远镜是人类眼睛的延伸——使人们看得更清楚，计算机是人类大脑的延伸——使人们算的更快......那么，学习就是人类所有能力的延伸——使人们拥有更多的能力，并且往往主要取决于你花费的时间与精力。 事实上，学习是投资回报率最高的行为。 //确实如此，每当觉得无所事事的时候，看看大家的文章，或者动动手写写与工作无关的程序，吸收营养，不管是经济、历史、传记、管理、经营还是其他等等。——我的理由是：不知道它现在有什么用，但一定会有发挥作用的时候。有很多例子在自己身上不断应验。 \"拒绝学习\"的例子。我曾多次劝我的一个朋友花20分钟学习一下命令行下的批处理方法，未果。他拒绝的理由是：\"现在谁还用命令行啊？早就是可视化操作系统的时代了！\" 我曾经多次劝我的另一个朋友花10分钟学习一下Google通配符的使用，未果。她说\"不用那东西也一样能找到自己想要的啊！\" 我曾替他们着急，可是后来却发现这是个\"死结\"。为什么呢？第一，拒绝学习就不可能有机会知道学习之后的收获；第二，由于不知道学习之后的收获是什么，也就不可能知道那收获有多好、多大；第三，既然对学习的好处无从了解，自然就没有学习的动力...... //这是一个恶性循环。未果，说明，人和人的沟通，有时候真的没有用。子非鱼安知鱼之乐。大家的知识背景不同，所能看到的视野不同，所得出的结论不同，总之，价值观不同。 \"学习\"的重要起点是：起码学会一种技能。无论这中技能多简单、多普遍，学会之后总是可以让学习者了解\"习得\"带来的大不同。一旦拥有了一个起点，学习的欲望就会像发芽的种子，无论多大的石头都压不住——它会越来越茁壮，越来越坚强。 其实，那些拒绝学习或者一不小心受了影响而把\"学习\"两个字妖魔化了的人真的非常可怜，他们每天都在挣扎着想要\"管理时间\"、\"珍惜生命\"、\"提高效率\"，却不知道他们因为当初不肯花十几分钟学习而导致其后少做了很多事情、错过了很多机会，并且连只有一次的人生都没有过好。 千万不要拒绝学习。 //不学习是多么的可悲！ 观察一下就会发现，日常生活中主要的\"沟通障碍\"本质上几乎都是由于沟通双方无法让对方理解与他们的经验相悖的知识或信息造成的。 不夸张的讲，目前几乎所有关于沟通技巧的书中提供的解决方案都没有真正说到点子上。 这种知识和信息传递中的问题，不是仅仅通过\"站在对方的立场上考虑问题\"就可以轻松、彻底地解决的。 尽管\"站在对方的立场上考虑问题\"确实是很有用也很难掌握的技巧，可当我们面对（或者说\"背对\"可能更准确一些）\"站在双方立场都无法考虑到的问题\"时呢？ 尽管这时我们甚至可能不知道问题究竟是什么，但有一点是确定无疑的——这种问题不仅确实存在，而且往往至关重要。 在我看来，所有教育失败的症结也在于此。在人们探索未知、寻求真理的时候，困难大都来自如何正确地理解\"与现有经验相悖的知识\" //如何正确理解\"与现有经验相悖的知识\"对我来说是个难题，对于我来说，现有经验=对，与现有经验相悖=错，除非能证明这个相悖的知识确实是对的，我才能接受。可是，在我不轻易放弃现有经验的情况下，怎么证明？（但不要忘了我是讲道理的） 自学能力的打造就是从我们认真对待它开始的。它就像恋人一样，你对它好，它才对你好。完全靠自己学一样东西吧——管它是什么，并且一定要学好，学到比相当数量的人都好。如果真的做到这个地步，那你就不仅是一个完整的人了，还是一个相当优秀的人。这时，你完全可以对自己说：\"你太有才了！\" 我个人的建议是去自学一门计算机程序语言，因为计算机程序语言的相关资源在互联网上分布广泛、极易获得，而且优秀的资源使用的语言往往是英语，这又顺带练习了英文阅读理解能力——想想吧，肯定不仅是一举两得。 //借用某人的一句话，程序员的语言只有英语，不服来辩。同时，作为一个可以改变生活，梦想改变世界的程序员，对这职业感到深深自豪。 很多人就是这样，坚持拒绝思考，然后用天下最累的生活方式而不自知。大哲学家罗素曾观察到这个现象，他为之奇怪并慨叹，\"很多人宁愿死也不愿思考\"，然后戏谑道，\"实际上，他们确实死得很快。\" //脑子不用跟没脑子有什么区别 一个人的强与弱，实际上相当于他的勇气减去他的恐惧之后的分值——如果是正数，那么他是强的；如果是负数，那么他是弱的。所有人的起点都是负数。但凡是人，都要经过很多的挣扎才能使这个算式的结果变成正数。并且无论是谁、无论这个人有多强，都不可能完全消除恐惧。勇气可能等于零，恐惧却永远大于零。 //人贵自知，勇气需要积累。 之所以在遇到尴尬时会冒出这样的念头（后悔），是因为太多人早就朴素地明白一个简单的道理：我们所面临的今天很大程度上取决于我们的过去。 //哈佛校训：你所浪费的今天，是昨天死去的人奢望的明天；你所厌恶的现在，是未来的你回不去的曾经。 //你珍惜今天了吗？ 读书，其实不见得一定要有目的，随意翻同样有益——有用的知识经常是偶然获得的。时间久了，我们就会发现，读书偶得的知识不仅多，而且非常重要，只不过因为很多人因为片面而又肤浅地理解\"人生应该有目标\"而失去了这些机会。 //观察，阅读，思考，总结，是提升自我的\"捷径\"。知识是眼界之基石。 方法固然重要，但是比起\"用过\"来说，方法几乎可以忽略不计。 //\"用功\"是一种坚持，一种质朴的力量，它可以使人抛开一切杂念，享受心灵的宁静。 所有学习上的成功，都只依靠两件事——策略和坚持，而坚持本身就是最重要的策略。 坚持，其实就是重复；而重复，说到底就是时间的投入，准确的说，是大量的投入。 //策略中还包含一项重要的内容：专注。三天打鱼两天晒网是万万不行的。而重复，也不是指简单的机械性重复，而是经过归纳总结的螺旋式上升。如果在一次又一次地重复的过程中，没有缩短时间，那么就是在浪费时间；而缩短时间的过程，就是找到方法，并不断优化。 其实，比成功更重要的是成长。如果\"成功\"是与他人比较的话，那么\"成长\"则是与自己比较——今天的我和昨天的我、明天的我和今天的我之间的比较。后一种比较显然比前一种对个体来说意义更大，也能够带来更加踏实的幸福感。 //每天成长一点点，时间会给出答案。不信？回头看看。 浪费时间、虚度年华的人，有一个共同的特征——拼命想控制自己完全不能控制的事物，却在自己真正能掌控的地方彻底失控。 相信运气其实是缺乏自制力的表现。 //我越来越相信，所谓的\"运气好\"，本质上是自身能力以及对周围控制力的综合作用的结果。使自己避免处于不确定因素中，以至于失去控制，听天由命，这本身就是获得\"好运气\"的必要条件。 \"相信我，所谓的人脉就算重要，也根本没他们说的那么重要。\" 这些公认为优秀的人，往往并不\"低调\"，也不\"平易近人\"。他们不是故意这样做的。他们无意去惹恼那些在他们看来\"平庸\"的人，只不过他们无形中有这样的体会：与这些人交流，沟通成本太高。这些人当中不多见的那些心态平和者，一般都是经历了波折，才终于意识到自己应该保护自己。他们发现，有些误会根本没机会解释。于是，他们开始\"谦虚\"，他们学会\"低调\"，他们显得\"平易近人\"。 //懒得解释 承认自己能力有限，是保持心理健康的前提。 \"量力而行\"是如此高难度的行为模式： 第一，承认自己能力有限； 第二，不怕在别人面前露怯； 第三，敢于不去证明自己是\"好人\" 从这个层面上讲，的确往往只有优秀的人，才会拥有有效的人脉。 而且，正因为这些人随时随地都可能要回避\"不公平交换\"的企图，他们会更加注重自身的质量，知道\"不给他人制造麻烦\"、\"独善其身\"是美德，这也体现了常言说的\"事多故人离\"。 //还记得那个公式吗？幸福=能力-欲望。独立，是立身之本。#不求人格自高# 有些资源很难靠白手起家获得，例如金钱、地位、名誉。然而，有些资源缺可以轻易从零开始积累，例如一个人的才华与学识。才华与学识，是一定可以通过努力获得的。一个人的心智能力一旦开启，只要正常地努力，并且有耐心和时间做朋友，很容易就能成为至少一个领域的专家。 努力并不像传说中的那么辛苦，说出来只不过是——每天至少专心学习、工作6小时。可是努力需要的耐心，却远比多数人想象中来得巨大，\"要与时间相伴短则5年，长则20年\"。 //在这个浮躁的年代，什么都急于求成，能坚持5年，10年，20年，潜心、专注、努力，凤毛麟角。而在此过程中所得到的感悟，并不是周围人能够理解的。#人需要信仰# 专心打造自己，让自己成为一个优秀的人、一个有用的人、一个独立的人，比什么都重要。打造自己，就等于打造自己的人脉——如果人脉真像传说中那么重要的话。 其实，我总觉得关于人脉导致成功的传说虚无缥缈，不过是些不明真相的人的臆造出的幻想罢了。 //每天晚上8点至10点——每天的黄金时间，在这个时间做的事情，决定了你的一生。 想做到\"不以物喜，不以己悲\"的健康状态，要迈出的第一步就是——停止嘲弄他人。嘲弄者必被嘲弄——这件事就是一个恶毒的魔咒。另一个比较\"技术\"一点的手段就是\"忘记自己的有点\"。很多时候，所谓\"谦虚\"和\"低调\"其实是一种自我保护的优化策略。 //要经常对自己说，别把自己太当回事，其实你什么都不是。 如果一个人把大部分的时间花在工作和学习上，那么他是以工作成就为导向的人；如果一个人把大部分的时间花在享受欢乐上，那么他是以生活满足为导向的人。每个人都不相同，有些人可以在工作和学习上获得更多的乐趣，有些人则会在生活琐事中获得更多的幸福。 所以，你需要确定自己是一个什么样的人。很多时候，鱼和熊掌缺失不可兼得——你必须选择。这也会使你非常清楚一个简单的事实：选择意味着放弃。选择做某件事情，可能就不能去做另外一件事情——哪怕你觉得可以一起做两件事情，实际上你已经不可能同时做第三件事情了。 这时候，黄金分割率可以作为一件趁手的工具。如果一天你可以规划的时间有10小时，并且你确定自己是以工作成就为导向的人，那就这也规划吧：用大约6.18小时去工作和学习，而用剩下的大约3.82小时去享受欢乐——毕竟你是一个正常人。反过来如果你确定自己是以满足生活为向导的人，那就这样规划吧：用6.18小时去享受欢乐，而用剩下的大约3.82小时去工作和学习——你毕竟还要想办法养活自己。 每个人专注的重点是不一样的。少数情况下，一个人可以专注到无以复加的地步——看看那些几天几夜打麻将的人，那些每天除了吸毒什么都不做的人，那些长时间坐在计算机前玩游戏的人就知道了。不过这些都是负面的例子。 某种意义上，我们不得不说，这也的人心智发育不是很健全，因为他们太容易满足并且仅仅满足于简单的感官刺激，而很少甚至无法感知那种需要通过复杂的劳动才可以获得的心灵上的愉悦。 //两种不同的生活导向，并不是一成不变的。两者存在相互转换，目的是使漫长的人生处于良性循环通道中。另外，可以注意到的是，不管是那种导向，都需要去学习，尤其是在当下，逆水行舟不进则退的时代。 很有可能，我们不知不觉就被这个社会抛弃了。我也十分赞同不能同时做很多事情的观点，即使可以并行做很多事情，那也是短暂的，毕竟能力有限、精力有限。 很多人半途而废，往往是因为把目标设定得太高，同时又对达成那么高的目标要付出的代价缺乏清楚的认识。这足以体现\"自知之明\"的重要性。我常常觉得，很多快乐是建立在\"自知之明\"上的。我知道自己的优点是什么，同时也知道自己的缺点是什么，所以，通常情况下，我不大可能做白日梦。 //我至今依然以为我是一个有自知之明的人，所以在做一个重大的决定前，我会花一定的时间去考察目标的高度，评估自身的能力，以及对周围的影响，从而找到一个平衡点。即便在外人看来，这个目标不是最高的，但也许是最合理的。 我们应该把自己的生活节奏调整的慢一点。 在一个所有人都匆匆忙忙的世界里，想放慢节奏实在是一件非常难的事情。但是我们应该记住的是：凡是值得做的事情，都值得慢慢去做，做很久很久。 //慢是一种奢侈，快是一种浮躁。不要想法太多却不切实际了，我们不能什么都想要。人生需要规划，人无远虑必有近忧。 真正的成功者，在关注\"开源\"的时候，会不吝惜金钱合理地\"节流\"；在关注\"开源\"的时候，也不会忘记\"开源\"的重要性。道理很简单：任何事情都可能\"物极必反\"。 //还记得正弦曲线sin(x)吗？大部分的事情都会有周期，我们也不可能一直得意向上，总会有失意的那一天。我们要做的只是储备能力，前进，向前，期待下一个顶点。不慌，不忙，笃悠悠，按照节奏来。 相信积累的力量，本质上就是相信复利的力量。 常言道\"习惯决定命运\"，说的就是这个道理。有些好习惯，养成得越早，一生的收益就越大。同理，坏习惯也是收复利的\"高利贷\"。 举一个很重要的例子：\"怕麻烦\"就是一种害死人的坏习惯。学习效果差，就是因为\"怕麻烦\"而造成了疏漏；工作成绩差，也不过是因为\"怕麻烦\"而偷懒所导致的。 甚至，可以说，只要仔细观察一下，我们就会得出这样的结论：很多人生活不幸，其实只不过是在作关键决策时因为\"怕麻烦\"而产生了失误...... 养成不怕麻烦的性格，才可能拥有耐心。耐心则是在任何工作、学习上获得成功的前提。 //事实上，性格决定命运。坏习惯就像慢性病一样，暂时看起来没什么事，等到并发症来的时候，无药可救。 //当然，很多人不怕死，因为他们无所谓，也不存在对未知的恐惧，觉得得过且过已经不错了。那这日子过的跟动物有啥区别呢？ 表情和神态是一个人内心的折射，几十年积累足以是一个人的内心变得\"不俗\"，于是，表情跟着\"从容\"、神态跟着\"睿智\"。 //所以，与新人接触，第一要看面相。#面相很重要#","tags":"ideas","title":"把时间当做朋友"}]}
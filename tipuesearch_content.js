var tipuesearch = {"pages":[{"title":"关于","text":"列夫·托尔斯泰《家庭幸福》 我曾经历了许许多多，现在，我似乎明白了什么是幸福，在乡下恬静的隐居，尽可能对人们做些简单而有用的善事，尽管那些人们并不习惯我为他们做了这些，做一份真正有用的工作，最后休息，享受大自然，读书，听音乐，爱周围的每一个人。 对于软件以及IT行业的理解 重脑力劳动，仅仅完成翻译业务规则的程序员必将消失 软件架构的多样性，源于顶层标准的无法统一，也源于底层硬件设施的持续发展。 当前，软件的集成过于僵化，交付的系统，就犹如为多变的世界加上了一副手铐。 顶层的标准难以统一，是因为不同的人对世界的认知是截然不同的。 无法以标准的形式去统一每个人的知识背景、思考的过程、以及积累的知识。 底层的硬件，由于技术的进步，时刻发生着变化，影响着软件的物理集成形态、整体的复杂程度以及软件行业的分工协作。 每个单独的软件、单独的硬件，都应该成为一个原子的神经元，通过灵活的集成方式，发挥出应有的价值。 这个集成的方式，不一定是人，也可以是内置算法的机器。","tags":"pages","url":"/about","loc":"/about"},{"title":"版权","text":"Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License 您可以自由地 分享 — 在任何媒介以任何形式复制、发行本作品 只要你遵守许可协议条款，许可人就无法收回你的这些权利。 唯须遵守下列条件 署名 — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. 非商业性使用 — 您不得将本作品用于商业目的。 禁止演绎 — If you remix, transform, or build upon the material, you may not distribute the modified material. 没有附加限制 — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits. 声明 You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation. No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material.","tags":"pages","url":"/copyright","loc":"/copyright"},{"title":"活好","text":"如果你的人生只有一件事，会是什么？ 答案是：活好！ 判断一个人活得好不好的标准很简单，就看别人想不想和你在一起，希不希望成为你的样子。 我们见过很多功成名就的人活得并不好，他们的员工和孩子都不想和他们在一起，更不希望成为他们的样子。 如果你的小孩想要成为你的样子，那还需要使劲教吗？如果你的小孩不想成为你的样子，你再怎么努力教他，有用吗？ ——台湾《商业周刊》创始人 金惟纯 觉知弱点——贪、怕、懒、怨 把懒和贪放在一起，有一个概念，叫投资回报。 把懒和怨放在一起，有一个概念，叫无能为力。 把懒和怕放在一起，有一个概念，叫回避矛盾。 活好，就是不陷入「既期待高回报，又无能为力、选择逃避」的不作为模式，也就是要首先积极地对自己负责。 爱因斯坦说（ 也有说不是 ）：\"Insanity: doing the same thing over and over again and expecting different results.\" 刻意练习——不贪、不怕、不懒、不怨 不贪——知足，面对利益 不怕——勇敢，面对风险 不懒——勤劳，面对付出 不怨——担当，面对责任 边界与安全感 一个人的边界是「感觉」：舒适的时候都是在圈内（安全），逆境的时候都是在圈外（风险）。 圈内和圈外有很多名字： 影响圈 | 关注圈 Performance Zone | Learning Zone M.Scott Peck《少有人走的路1》 —— 心智成熟的旅程 我感到害怕。就在沮丧的时刻，仿佛神谕一般，我听到一种声音，一种来自潜意识深处的声音：\"人生唯一的安全感，来自充分体验人生的不安全感。\" 能力与成长 人的能力，就是解决问题的能力。能力的强弱，是通过要问题的复杂程度来衡量的，实际上世界上并没有两个一模一样的问题。 所谓成长，就是不断增强能力，扩大影响圈，解决更多的更难的问题（不仅仅是自己的，更也是社会的）。一个人的能力是有限的，影响圈也是有限的，当要解决更大的问题的时候，一定会和社会、和其他人发生联系。而想要获得和维护良好的人际关系，核心的本质是平等、尊重、不评判。 文化 Richard Dawkins《自私的基因》 总而言之，我们人类的独特之处可以归结为一个词——文化。我是作为一个科学工作者使用这个字眼的，它并不带有通常的那种势利的含义。文化的传播有一点和遗传相类似，即它能导致某种形式的净化，尽管从根本上来说，这种传播是有节制的。 利他行为背后的目标函数是：最大化个体基因在种群基因库中的占比。 吸血蝙蝠可以讲述一个新的神秘故事，一个关于共享、互助、合作的故事。它们昭示这样一个善良的思想：即使我们都由自私的基因掌舵，好人终有好报。 手中的权力，不是用来制定僵硬的规则，或者来满足自己的圈内需求，而更多的应该是创造一种让所有参与者共同成长的良性文化，克服贪怕懒怨，并用权力隔离威胁到这种文化传播的异类。 也要意识到，文化也是有局限性的，没有一种文化可以包容万物，一定程度上文化和格局等同，要像生物态一样，不断迭代和发展——以促进最大范围内的协同发展、共同成长为目标、激发他人的善意，解决别人实际存在的问题。","tags":"ideas","url":"/articles/how-many-heartcounts-do-i-have","loc":"/articles/how-many-heartcounts-do-i-have"},{"title":"尊重，就是不要用自己的标准要求别人","text":"人和人都是不同的，视角、想法、诉求都不一样。 每个人都在做自己认为「对」的事情。 如果用「非黑即白」的二元逻辑去看别人的想法。 只要和自己不一样， 那么别人都是「不对」的。 因为不一样，所以有矛盾和冲突。 表达清楚自己的诉求和方法。 理解清楚别人的诉求和方法。 和而不同 — 从不同中找相同，形成共识，建立信任。 不要用自己的标准要求别人。 共识越多，拉近距离。 共识越少，保持距离。 志同道合，或者，道不同不相为谋。 「为你好」是一种自私的绑架 「好」只是自己认为的「好」，还是别人的 「真正诉求」？ 澄清自己认为好的标准，不要让别人欠下无法承受的人情债。 从别人真正的诉求角度，力所能及地去帮助别人才是真的好。","tags":"ideas","url":"/articles/respect-dont-apply-your-standard-to-the-others","loc":"/articles/respect-dont-apply-your-standard-to-the-others"},{"title":"如果，把一个人看成一个HTTP Server","text":"HTTP状态码和视角 在 RFC2616 - HTTP/1.1: Status Code Definitions 标准里，最常用的HTTP 状态码一共有3类 Successful - 2xx Bad Request - 4xx Server Error - 5xx 所有来自于外界的 request 和 反馈的response 就是和外界的连（guan）接（xi） 2xx 是正常 4xx 和 5xx 是异常。异常在英文里叫exception ，也就是例外 也就是说，这个\"人\"经常会说 2xx - 好的，我可以 --> 结果，大家皆大欢喜 4xx - 这不是我的问题，怪别人 —> 结果，让别人修bug，也得等别人修bug 5xx - 是我错了，怪自己 —> 结果，老老实实修自己的bug去 一般人，对于强（wan）大（neng）的系统的预期： 大部分时候都在「理所当然」回应2xx 很少回应4xx 主动修复5xx 一切总有例外 什么叫承受委屈？ 把别人的4xx，当做自己的5xx，默默修成2xx了 什么叫甩锅？ （本来就是三个和尚） 把自己的5xx，说成别人的4xx，不是我的责任。 什么叫很难理解 对request和response的定义，涉及到的概念解释不同 每个人背后切分4xx和5xx的理念和逻辑不一样 探寻root cause的动机不同 「始于君子，终于小人」 什么叫事前逞强？ 盲目乐观 在对后市一无所知的时候，无畏答应了一堆2xx 在对后市一无所知的时候，无知假设了一堆2xx 什么叫事后扯皮？ 甲：为什么定义成我的5xx，不是你的4xx? 乙：为什么定义成我的4xx，不是你的5xx？ 丙：（边吃瓜，边浇油） 什么叫「你应该」？ 因为不是说好的 2xx吗 因为别人家的HTTP Server都返回2xx 怎么办？\"重构（知识结构）\" 底线 - 丑话说前面，自己的代码记得写上 try - catch - finally 兜底 接纳 - 把处理异常（例外）的逻辑方法，从 catch - finally ，改写成到处理已知的逻辑 switch (case), default 放下成见 - 去接纳一些世界上更多不能用简单逻辑解释的事情，比如中医，比如一些神经网络。 这个过程叫——学习做最好的自己。","tags":"ideas","url":"/articles/if-consider-a-person-as-a-http-server","loc":"/articles/if-consider-a-person-as-a-http-server"},{"title":"正弦 (1)","text":"完美的本质是一切符合预期，万事如意。 这需要很强的控制力。不仅对自己，也对周围环境。 这很难，因为一切都在变。 环境在变，与之相匹配的自适应性能力也要变。 我们总以为知道自己知道了一些\"真相\"，\"看清了\"一些本质，并且可以用逻辑去证明。 可这永远是源于我们自己的视角， 看到的不等于真相，理解的不等于本意。 我们终究还是生活在一个无知的世界里，看不清，也没有能力理解绝对全部。 沟壑永远存在。 因为弱小，我们需要安全感，以保证我们看不见的部分不会对自己造成伤害。 因为弱小，我们需要信任感，这并不源于ta自以为能做什么，而是ta过去做了什么。 我们用逻辑和推理去建立自己的安全感，以消除对未知的恐惧。 快乐是一种痛苦，就像没有苦并不知道什么是甜。 愤怒是一种弱小，因为不仅驾驭不了周围环境，而且也驾驭不了面对失望的情绪。","tags":"ideas","url":"/articles/sine-1","loc":"/articles/sine-1"},{"title":"使用Nexus3进行Snapshot和Release管理","text":"Nexus3中的关键角色与用户 Snapshot库的Deploy角色 nx-repository-view-maven2-maven-snapshots-edit 在Nexus库中创建拥有以上角色的用户，例如 developer 。 这个角色，必须要包含 nx-anonymous 这个「匿名角色」，否则会被以 ReasonPhrase:Forbidden. 理由拒绝。 Release库的Deploy角色 nx-repository-view-maven2-maven-releases-edit 在Nexus库中创建拥有以上角色的用户，例如 publisher 。 这个角色，必须要包含 nx-anonymous 这个「匿名角色」，否则会被以 ReasonPhrase:Forbidden. 理由拒绝。 .m2/settings.xml中servers的设置 <settings> <servers> <server> <id> snapshot </id> <username> developer </username> <password> password-of-developer-in-nexus </password> </server> <server> <id> release </id> <username> publisher </username> <password> password-of-publisher-in-nexus </password> </server> </servers> ... </settings> maven project super-parent maven project 对于每个组织或者企业，使用一个顶级的、唯一的parent project是十分有必要的，这可以统一各级子工程的发布管理配置。 <scm> <url> http://your.domain/and-path </url> <connection> scm:git:ssh://git@your.vcs.domain/your-path </connection> </scm> <distributionManagement> <snapshotRepository> <id> snapshot </id> <url> http://your.nexus/repository/maven-snapshots </url> </snapshotRepository> <repository> <id> release </id> <url> http://your.nexus/repository/maven-releases </url> </repository> </distributionManagement> <build> <pluginManagement> <plugins> <plugin> <artifactId> maven-release-plugin </artifactId> <version> 2.5.3 </version> </plugin> </plugins> </pluginManagement> </build> 其中， snapshotRepository 中的 id 与 .m2/settings.xml 中的 server/id 需要保持一致。 在例子中，两处都都同时使用了 snapshot` 以及 ``release 。 snapshot deploy snapshot deploy 是每个developer日常进行snapshot library发布的正常行为。 在每个developer的本地，都可以针对一个 maven project 执行： mvn deploy 操作，将任意的 Version 以 -SNAPSHOT 结尾的 artifact 部署至 snapshot 库中。 release publish maven-release-plugin 是用作正式发布使用的maven插件。 其中有两个关键的mvn 指令， mvn release:prepare 以及 mvn release:perform mvn release:prepare 这个指令主要的操作目标是VCS (例如GitLab) ，它的执行条件有： 本地的所有代码已经提交，对于git而言，本地的所有代码，都已经经过 git push ，也就是说stage区不存在修改过的文件。 mave坐标中的Version，必须以 -SNAPSHOT 结尾，否则该指令会罢工。这个指令的执行过程，是交互式的，它会询问三项内容： 指定要发布的Version值，一般来说，它会自动提示不包含 -SNAPSHOT 部分的版本号 VCS的tag名称。例如，git分支上的tag。 下一个开发版，含的 -SNAPSHOT 版本号，一般来说，它会自动将最后一位数字版本号自动增加1。 这个动作执行之后，会生成两个主要的文件： 原来pom.xml的备份文件 release.properties，即本次release的相关信息。 同时，这个指令还会对修改后的release版本进行 mvn release:perform 这个指令主要的操作目标是仓库 (Repository，例如 Nexus)。 它的主要目的，是把本地已经生成好的 release library 部署至仓库。并不会对 VCS 进行任何写操作。","tags":"experiences","url":"/articles/nexus3-maven-snapshot-and-release","loc":"/articles/nexus3-maven-snapshot-and-release"},{"title":"图片的管理与运营","text":"没错，这又是一个还没实现的理想，缺的是时间资源。 （工程设计）图的窘境 脑图、UML图、PPT中的图形，是经常用到的集中画图的方式。这些方式都会造成图片的绘制限制，或者使用限制。 使用A工具绘制而成的图片，非常容易的在 B/C/D... 等工具和场景中被「引用」。 上下文无感知 一个图片不能在多个场合进行引用，主要体现在无法根据上下文条件进行自适应的调整，例如 矢量缩放 配色主题的更换 格式的自动转换 重构、抽取与局部引用 内容价值弱反馈，变更无感知 目前大部分的绘图工具的设计，都缺乏对「协作」的支持。 也就是说，他们都假设了，「产物的作者 就是 使用者」。 简而言之，就是用同一个工具进行编辑、修改和演示。 从协作的角度来说，「产物的作者 不是 使用者」 简而言之，就是进行编辑、修改的工具，和进行演示的工具不是同一个，是相互松耦合的。 即便是实现了松耦合的工具设计，目前也缺乏 「使用者」 对于上游 「作者」 进行内容更新的通知与提醒。 这些因素，导致了内容的分享变得困难，对内容的价值评价变得无法进行。 二进制图片的内容管理 二进制图片，是没有办法采用面向文本的 diff 工具，对的内容进行精准比较的。 图的重度依赖者，又非常希望能够看到两张图片在内容上的细节差异，不想在一张图片的若干版本中，重复的进行着「找不同」的游戏。 这也是二进制图片，表达「图意」的难点。在数据处理领域，称之为「无结构的数据」。 这种称呼，其实是站在图片的使用者角度，无法用计算机直接理解图片的「图意」。 目前的人工智能或者说是机器学习，对于图片的识别已经有了长足的进步，能够识别「日常」的一些「简单图片」。 不过，对于「工程制图」的结构识别、模型还原的应用，还不多见。 图的制作 商业或者封闭的绘制工具 一般，商业的绘制工具，对图的物理格式，都采用特有的方式进行编码，即便是基于 XML 方式进行解析，大多数情况下，只能靠人猜测其含义。 同时，商业工具，还会持有一些「布局算法」，并可能以专利的形式进行保护。 这样，对于非官方的「图片浏览器」而言，则会产生布局效果差强人意的结果。 很明显的例子是，对于 Office 系列文件的图形化渲染， 用A工具绘制的图片，在B工具内打开，可能就会发生剧烈的变形。 也就是说，这些封闭的绘图工具，在产品设计的时候，有一个基本的假设，那么就是图片的绘制，与图片的浏览，都在本工具之内进行。 这可能是增加产品「用户粘性」的一个手段？ 基于文本生成的例子 以git为代表的管理工具，是对文本文件，进行版本管理的最佳选择。 SVG 等等以 XML 为核心的文本格式矢量图，或者是以 PlantUML 为代表的，有自己特有语法的描述语言，可以进行多种输出图片格式的图形转换。 在软件领域， PlantUML ，是在设计阶段，最为「淳朴」的UML绘制工具，也就是说，整体布局由 PlantUML 自行通过算法完成，用户很多时候能够采取一些「小技巧」来实现布局上的「更高要求」。 可以说， PlantUML 是可以解决一些小规模程序的设计图的绘制问题。 同时还能够以文本的形式，对内容进行版本管理。 使用标记语言聚合内容 标记语言，是基于文本的，它很大程度上解决了内容与格式的紧耦合模式。 这种方式，相比传统的 Office套件（无论那个厂商），放弃了一些「所见即所得」的撰写体验（其实也有热心群众提供非官方插件支持），但释放了内容的「复用、分享」能力。 把修饰文字的「元信息」，通过简单的特殊符号，附加在特定的文字周围。 比较简单的和典型的有（按学习难度排序） Markdown reStructuredText AsciiDoc 这些标记语言，都是基于文本的，并且天然的支持以「URL」的方式对图片进行引用。 例如，本文，就是用 reStructuredText 编写的，引用图片时候，只需要写成： .. image :: /images/2017/01-13/the-way-of-pubsub-diagram-4.png :height: 400px :width: 450px :align: center 就能够完成对一个图片的引用，当然，还可以是外链的URL。 图的引用 对，我没写错，是「引用」，不是「应用」。 也就是说，图的「作者」不是「引用者」，这种情况，在知识互连、知识共享、知识集成的时代，非常常见。 图的引用场景是广泛的，常见的有： 嵌入Office文件，例如Presentation PDF或者HTML格式的宣传册、白皮书、说明书 网站、博客、微博 微信公众号，还可能是多个 可内置渠道信息、支持条件跳转与有效期的动态二维码 老态龙钟的 Microsoft Office 其实，Apple家的Keynote也类似。只是Microsoft Office市场占有率更高一些。 Microsoft Word Version 15.30 (170107) 不支持用URL引用一个「外部远程」图片。 Microsoft Powerpoint Version 15.30 (170107) 不支持用URL引用一个「外部远程」Slide，图片也类似。 与时俱进的 Google Docs 在探查之前，就一定猜到，Google一定是支持引用「外部URL」的。 例如，可以在Google Docs中，插入一个URL形式的图片。 令人失望的 Office 365 可以看到，企业文化、产品理念的差异，很容易体现在「功能细节」上，用户的内心自然而然会有公道的评价。 意料之外的 PlantUML 可以说， PlantUML 是工具解耦上做的最充分的一个工具了（虽然任然有缺陷，例如对于中文的处理） PlantUML 生成图片，可以基于「Web Service」进行。 PlantUML 官方提供了一个演示的例子： http://www.plantuml.com/plantuml/proxy?src=<your_puml_url> http://www.plantuml.com/plantuml/proxy?src=https://raw.github.com/plantuml/plantuml-server/master/src/main/webapp/resource/test2diagrams.txt 有潜力的开源项目 Presentation领域的 SlideHub 虽然 SlideHub 不是直接对图片进行的分享，但是它基本上已经是除了 SlideShare 之外，自行搭建演示文稿分享的不二选择了。 SlideShare 和 开源的 SlideHub 都实现了对 Office Open XML 的解析，以及对于Slide的切片。 在 SlideShare 上，每个用户都可以收藏自己重点关注的 Slide ，而不用收藏 Presentation 的全文。 实际上， Office Open XML 是一个开放的 Office 文件标准。 Presentation的物理结构是基本上是这样的（用Zip解压工具，解压之后就能够看到，如果你不想看枯燥的标准的话）： 几个关键的目录： _rels : 组织整个Presentation的结构，完成内容的编排。 diagrams : 是以 XML 为物理结构的矢量图。 media : 外部的二进制图片，或者视频。 slideLayout : slide的基本布局模板。 slideMaster : slide母版的基本布局模板。 theme : 基本的矢量图配色方案。 如果，一系列的 Presentation 作者，是同一个人或者组织，那么这些 Presentation 的风格、主题应当较为类似。并且能够有很多的 diagrams 能够复用。 再进一步地，应当能够基于已有的 Presentation 进行快速的内容编排，形成一份新的 Presentation 。 另一方面，如果一些 Slide 发生了版本变更，那么那些引用这些发生变更的 Slide 的 Presentation的作者，也应当能够收到「变更提醒」，进一步的有帮助他们完成内容的自动更新。 也许这是 SlideShare 企业版所拥有的能力。（ SlideShare 有企业版吗？） 不过，Google Slides 已经支持了 Import , 它缺的一个社区，缺一个对 diagram 这些素材的管理: Document领域的 Mkdocs 企业，对于 Document 的需求是频繁的，例如：合同、使用说明书、设计说明书，或者出版物，都需要有「内容」与「排版」分离的素材管理模型。 MkDocs 是众多的「静态网站生成器」（SSG）中的一个 ( StaticGen 对他们有个简要的介绍 ) 。 另外，最著名的应当还要属于 gitbook ，但是它并不支持在企业中进行 on-premise 部署，只支持以 SaaS 的云模式提供服务。 它们好还是不好，这是个主观的判断，「合适」自身的特点，才是真的好。 新媒体渠道 新媒体渠道，可能会包括企业「自运营」的网站，以及由第三方托管的「内容平台」，例如，微信公众平台。 对于企业「自运营」的网站，可以使用一部分的 SSG 能力，实现对内容的版本化更新。 对于类似于「微信公众平台」，则可以使用 OpenAPI 进行素材的自动化管理。 这类非官方的素材非常多，可以去 GitHub 上进行搜索。 最后，还需要一个内容运营平台 这个内容管理平台应当具备几个要素 面向个体的素材管理 基本形式与转换 版本 原作者 演绎者 发布与引用更新通知 面向平台的运营生态 基于最小粒度的评价体系 基于原作者的反馈评价 为知识付费","tags":"ideas","url":"/articles/the-way-of-pubsub-diagram","loc":"/articles/the-way-of-pubsub-diagram"},{"title":"EnhancedREST 1.0.0 规范","text":"阅读知识背景要求 熟悉HTTP/1.1协议以及MIME-types 熟悉RESTful 熟悉分布式事务处理模型 了解OAuth2协议 了解Kerberos (V5) 协议 了解Hash单向函数 修订历史 1.0.0 首次发布 背景与目标 编写背景 RESTful 是一个将HTTP传输协议以及JSON报文体相结合的RPC通信风格，但目前并不存在一个得到普遍认可和约束的工业技术规范。 由于RESTful风格形式简洁，工具链丰富，收到广大开发者的喜爱。同时也由于其落地实现的随意性，导致各大企业都有不同的落地实现方法，形成了不同形态的「方言」。无形之中增加了软件互联的成本，造成了有限的研发资源浪费。 编写目标 「书同文车同轨」，规范不同系统之间的技术标准，降低产品间的集成成本，提高研发效率，促进各产品规范、有序发展。 基本约定 本规范中涉及大量对HTTP/1.1 协议的标准引用，对于HTTP Header中各项规范定义，本规范以 \"X-RL-\" 作为前缀进行扩展，未扩展的遵循RFC所定义的含义。 限制条件 本规范主要的使用范围，主要位于后端服务之间的RPC通信。 对于每个Client/Server具有唯一性标识生成能力的要求。 修订计划 补充TCC模式技术规范 在对本规范进行实现之后，进行部分的内容修订 参考标准 直接参考标准 RFC2616 Hypertext Transfer Protocol -- HTTP/1.1 RFC7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content RFC2119 Key words for use in RFCs to Indicate Requirement Levels RFC2045 Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies 间接参考标准 RFC4120 The Kerberos Network Authentication Service (V5) RFC6749 The OAuth 2.0 Authorization Framework 分布式事务的RPC模式简介 Commit-Compensation (CC) 「提交-补偿」模式：要求提供方提供对原请求的补偿（也称作撤销，反向）操作能力。 双方可依照5个操作进行RPC通信： * Commit 提交 * Compensation 补偿 * Status 状态 * Fetch 获取 * Trace 跟踪 Try-Confirm/Cancel (TCC) 「尝试-确认/取消」模式：要求提供方提供资源预留、资源确认消费，资源预留取消的操作能力；要求提供方具备进行尝试操作后，自动针对「未确认操作」进行自动「取消」的能力。 双方可依照6个操作进行RPC通信： * Try 尝试 * Confirm 确认 * Cancel 取消 * Status 状态 * Fetch 获取 * Trace 跟踪 Event Sourcing (ES) 「事件溯源」模式：要求事件产生方（事件源）对消息根据时间排序；要求事件消费方根据事件发生顺序有序处理；要求在事件消费方（也就是DDD模型中的聚合根）对来自多个事件源的事件进行处理时，具备复杂事件处理（CEP）的能力。 由于事件产生方与事件消费方采用异步消息模式进行通信，因此本规范暂时不对ES模式进行技术规范的约束。 EnhancedREST-CC模式 Client Side 技术标准 Client Side 请求结构 Consumer-Agent Client Group (MUST) Client Name (MUST) Client Version (SHOULD) Cluster Group (MUST) Cluster Name (MUST) InstanceId (MUST) Request-Metadata Consumer Consumer Group (MUST) Consumer Name (MUST) Consumer Version (MUST) MessageId (MUST) RequestId (MUST) TransactionId (SHOULD) Content-Type (SHOULD) Serialization Method (MUST) Data Structure Version (SHOULD) InstanceId (SHOULD) Accept (COULD) Access Token (Security Considerations) Client Access Token Consumer Access Token Request HMAC (Security Considerations) Timeout (COULD) Consumer-Request 5 Types Commit Compensation Status Fetch Trace Request-Body Client Side 概念定义 Consumer Consumer 是指请求的实际产生者，不包括自然人。 Consumer Group Consumer Group 是Consumer所属分组的唯一标识，一般为系统所属域。 Consumer Name Consumer Name 是Consumer的名称，在Consumer Group内具备唯一性，一般为系统名。 Consumer Version Consumer Version 指Consumer的所包含功能的具体介质发布版本，一般的Release版本在物理介质上必须保证唯一性。（发布版本、介质、介质SHA1/MD5/SHA256，需要保持一致，有条件的还需要进行代码签名） Consumer-Agent Consumer-Agent 是指用户行为的代理执行者。 Client 物理概念 Client 是Consumer-Agent的物理实现，一般为承载请求的运行时容器。 Client Group Client Group 是Client所属分组的标识，一般为容器提供者的唯一标识。 Client Name Client Name 是Client的名称，在Client Group 内具备唯一性。 Client Version Client Version 指Client的具体发布版本，一般的Release版本在物理介质上必须保证唯一性。（发布版本、介质、介质SHA1/MD5/SHA256，需要保持一致，有条件的还需要进行代码签名） Cluster Group Cluster Group 是指Client 和Consumer的可部署介质，在目标运行环境中所属分类，一般对应到域。 Cluster Name Cluster Name 是指Client 和Consumer的可部署介质，在目标运行环境中的具体集群名称，一般对应到一组相同功能实例，即集群。 InstanceId InstanceId是指Client 和Consumer的可部署介质，在目标运行环境中的具体集群中，被分配的唯一序列号。其唯一性的范围，至少在集群内部，也可以是全局。 Request-Metadata 逻辑概念Request-Metadata 是请求中元信息的总称。 MessageId MessageId 是每个消息(报文)的唯一标识，由Client运行期即时生成。对于Client或Consumer发起的重试行为，需要提供不同的MessageId。 RequestId RequestId 是每个请求的唯一标识，由Consumer运行期即时生成。 TransactionId TransactionId 是每个请求的全链路标识，用于关联最源端开始的完整调用过程。 Content-Type 逻辑概念Content-Type 是用于说明客户端请求的报文体序列化方法的总称。 Serialization Method Serialization Method 是指请求报文的序列化方法。一般使用 MIME-types ( RFC2045 ) Data Structure Version Data Structure Version 是请求报文内数据结构的版本。 InstanceId InstanceId 是指Client在物理部署后，进程在集群内的唯一标识。 Access Token 逻辑概念Access Token是访问令牌的总称。 Client Access Token Client Access Token是表明客户端合法身份的标识，一般通过安全算法生成，并具备时效性。 Consumer Access Token可以与 Kerberos 协议相结合。 Consumer Access Token Consumer Access Token是表明消费合法身份的标识，一般通过安全算法生成，并具备时效性。 Consumer Access Token可以与 OAuth2 协议相结合。 Request HMAC Request HMAC是通过Hash函数、Consumer持有的私有秘钥、请求报文内容的摘要、盐，所生成的安全校验码，具备放篡改能力。 Timeout Timeout 是指Consumer所限定的超时时间。 HTTP/1.1 协议映射 HTTP Method 概念映射 Commit —> HTTP PUT Compensation —> HTTP PATCH Status —> HTTP HEAD Fetch —> HTTP GET Trace —> HTTP TRACE HTTP Header 概念映射 User-Agent <Consumer Group>-<Consumer Name> / <Consumer Version> (<Server Group>-<Server Name>/<Server Version>) From <MessageId>@<InstanceId>.<Cluster Name>.<Cluster Group> Content-Type <Serialization Method> Referer Upstream <RequestId & RequestURL> X-RL-CC-C-TID <TransactionId> X-RL-C-DSV <Data Structure Version> X-RL-C-INST <InstanceId> X-RL-C-CLAT <Client Access Token> X-RL-C-COAT <Consumer Access Token> X-RL-C-HMAC Request HMAC X-RL-C-TIMEOUT <Timeout> URL 概念映射 RequestId & RequestURL http(s)://<domain>/<path>/<RequestId> Server Side 技术标准 Server Side 响应结构 Provider-Agent Server Group (MUST) Server Name (MUST) Server Version (SHOULD) Response-Metadata Status Code (MUST) MessageId (MUST) ResponseId (MUST) RequestId (MUST) Content-Type (SHOULD) Serialization Method (MUST) Data Version (SHOULD) InstanceId (SHOULD) Response HMAC (Security Considerations) Message Date Response Date Retry-After Expires Provider-Response 5 Types Commit: Commit Result Commit: Compensation Result Status: Request Current Status only Fetch: Final Result Trace: Commit, Compensation & Sub RPC call Trace Response-Body Server Side 概念定义 Provider Provider 是指响应的实际产生者，不包括自然人。 Server 物理概念 Server 是Provider-Agent的物理实现，一般为处理请求、作出应答的运行时容器。 Server Group Server Group 是Server所属分组的标识，一般为容器提供者的唯一标识。 Server Name Server Name 是Server的名称，在Server Group 内具备唯一性。 Server Version Server Version 指Server的具体发布版本，一般的Release版本在物理介质上必须保证唯一性。（发布版本、介质、介质SHA1/MD5/SHA256，需要保持一致，有条件的还需要进行代码签名） Cluster Group Cluster Group 是指Server 和Provider的可部署介质，在目标运行环境中所属分类，一般对应到域。 Cluster Name Cluster Name 是指Server和Provider的可部署介质，在目标运行环境中的具体集群名称，一般对应到一组相同功能实例，即集群。 InstanceId InstanceId 是指Server 和Provider的可部署介质，在目标运行环境中的具体集群中，被分配的唯一序列号。其唯一性的范围，至少在集群内部，也可以是全局。 Response-Metadata 逻辑概念Response-Metadata 是响应中元信息的总称。 Status Code Status Code 是每个响应的状态编码，一般情况下遵循HTTP/1.1协议的标准。 MessageId MessageId 是每个消息(报文)的唯一标识，由Server运行期即时生成。 ResponseId RequestId 是每个响应的唯一标识，由Provider运行期即时生成。 Content-Type 逻辑概念Content-Type是用于说明客户端请求的报文体序列化方法的总称。 Serialization Method Serialization Method 是指响应报文的序列化方法。一般使用 MIME-types ( RFC2045 ) Data Structure Version Data Structure Version 是响应报文内数据结构的版本。 InstanceId InstanceId 是指Server在物理部署后，进程在集群内的唯一标识。 Response HMAC Response HMAC是通过Hash函数、Consumer持有的私有秘钥、请求报文内容的摘要、盐，所生成的安全校验码，具备放篡改能力。参见RFC对ETag的定义。 Message Date Message Date是响应消息的生成时间，由Server给定。参见RFC对Date的定义。 Response Date Response Date是响应内容的生成时间，由Server给定。参见RFC对Last-Modified的定义。 Expire Date Expire Date是Commit操作结果的过期时间，由Provider给定。当Consumer在Expire Date时间之后提交Compensation操作，有可能得到的是Compensation操作失败的结果。其他内容，参见RFC对Expires的定义。 Retry-After Expire Date是响应内容的过期时间，由Server给定。参见RFC对Retry-After的定义。 HTTP/1.1 Header 概念映射 Status Code 参见上一节「HTTP Status Code 映射」 Server <Server Group>-<Server Name>/<Server Version> <Provider Group>-<Provider Name> / <Provider Version> <Cluster Group>-<Cluster Name>/<InstanceId> X-RL-CC-S-MID <MessageId> X-RL-S-RESID <ResponseId> X-RL-S-REQID <RequestId> Content-Type <Serialization Method> X-RL-S-DSV <Data Structure Version> ETag <Response HMAC> Date <Message Date> Last-Modified <Response Date> Retry-After HTTP-date / delay-seconds 响应 Commit 操作 针对Commit操作，允许返回以下响应码 201 Created 正常处理，并成功。 400 Bad Request 指Consumer提供的请求不符合约定的规格。 401 Unauthorized 指Consumer未提供可供Provider进行合法性验证的身份信息。 402 Payment Required 指Consumer所执行的请求，超过约定的流量限额。 403 Forbidden 指Consumer没有权限执行这项操作。 408 Request Timeout 指Consumer没有在Provider能够接受的请求报文接收时长内接收到完整报文。 409 Conflict 指Server所接受到的报文存在冲突。即相同的RequestId，所对应的Request HMAC不一致。 413 Payload Too Large 指Client对Consumer所提供的报文，在进行序列化之后的长度，超过Server能够接受的最大长度。 414 URI Too Long 指Client所提供的URI，超过Server能够接受的最大长度。 500 Internal Server Error 指Server在处理过程中，发生了未知错误。 503 Service Unavailable 指Provider在处理过程中，发生了未知错误。 响应 Compensation 操作 针对Compensation操作，允许返回以下响应码 400 Bad Request 指Consumer提供的请求不符合约定的规格。 401 Unauthorized 指Consumer未提供可供Provider进行合法性验证的身份信息。 402 Payment Required 指Consumer所执行的请求，超过约定的流量限额。 403 Forbidden 指Consumer没有权限执行这项操作。 404 Not Found 指Provider根据Consumer指定的RequestId没有找到相关的Commit请求。 408 Request Timeout 指Consumer没有在Provider能够接受的请求报文接收时长内接收到完整报文。 409 Conflict 指Server所接受到的报文存在冲突。即相同的RequestId，所对应的Request HMAC不一致。 410 Gone 处理补偿操作，并成功。 413 Payload Too Large 指Client对Consumer所提供的报文，在进行序列化之后的长度，超过Server能够接受的最大长度。 414 URI Too Long 指Client所提供的URI，超过Server能够接受的最大长度。 500 Internal Server Error 指Server在处理过程中，发生了未知错误。 503 Service Unavailable 指Provider在处理过程中，发生了未知错误。 响应 Status 操作 HTTP/1.1 不对HTTP Status Method提供请求体以及响应体的支撑。 201 Created 处理提交操作，并成功。仅在Commit操作正常完整之后返回。 410 Gone 处理补偿操作，并成功。仅在Compensation操作正常完整之后返回。 响应 Fetch 操作 对于一个正常请求，以及后续可能出现的补偿请求，在Provider可能会产生多个响应结果，Fetch操作只会产生最后的操作结果。当Provider没有补偿操作进行时，返回的是Commit操作的结果；当Provider执行成功执行过Compensation操作时，返回的是Compensation操作结果。 200 OK 返回Provider处理结果的内容。 400 Bad Request 指Consumer提供的请求不符合约定的规格。 401 Unauthorized 指Consumer未提供可供Provider进行合法性验证的身份信息。 402 Payment Required 指Consumer所执行的请求，超过约定的流量限额。 403 Forbidden 指Consumer没有权限执行这项操作。 404 Not Found 指Provider根据Consumer指定的RequestId没有找到相关的Commit请求。 408 Request Timeout 指Consumer没有在Provider能够接受的请求报文接收时长内接收到完整报文。 414 URI Too Long 指Client所提供的URI，超过Server能够接受的最大长度。 500 Internal Server Error 指Server在处理过程中，发生了未知错误。 503 Service Unavailable 指Provider在处理过程中，发生了未知错误。 响应 Trace 操作 对于一个Provider，在处理 Commit操作的过程中，一方面可能依赖下游的其他Provider；另一方面后续可能还会出现 Compensation操作。因此，对于一次请求，处理的结果会产生一系列的处理轨迹。 Trace操作，需要使用HTTP/1.1 Multipart响应机制对结果进行返回。 Content-Type <Serialization Method> (Multipart Content-Type) 200 OK 返回Consumer处理结果的内容。 400 Bad Request 指Consumer提供的请求不符合约定的规格。 401 Unauthorized 指Consumer未提供可供Provider进行合法性验证的身份信息。 402 Payment Required 指Consumer所执行的请求，超过约定的流量限额。 403 Forbidden 指Consumer没有权限执行这项操作。 404 Not Found 指Provider根据Consumer指定的RequestId没有找到相关的Commit请求。 408 Request Timeout 指Consumer没有在Provider能够接受的请求报文接收时长内接收到完整报文。 414 URI Too Long 指Client所提供的URI，超过Server能够接受的最大长度。 500 Internal Server Error 指Server在处理过程中，发生了未知错误。 503 Service Unavailable 指Provider在处理过程中，发生了未知错误。","tags":"ideas","url":"/articles/enhanced-rest-1-0-0-specs","loc":"/articles/enhanced-rest-1-0-0-specs"},{"title":"企业软件是怎样炼成的 ，做软件的为什么总加班？","text":"企业软件产品的制造与消费 用生产关系来分析企业软件的制造过程，是非常合适的，但很少见。 软件的原材料是一些片面的知识，软件是对一些片面知识集成之后的固化产物。 软件的版本更新，既源于对新知识的集成，也源于对旧知识的淘汰。 源代码、机器码，是知识在计算机层面的两个形态。 程序员编写源代码、编译器将源代码转换机器码，是对「知识」这个生产资料进行加工的「工艺」。 知识的直接价值，可以通过「软件产品的交易」的方式得到体现——被最终直接用户购买和使用。 知识的间接价值，可以通过「软件被软件集成」的方式得到体现——作为中间产品被最终用户间接够买和使用。 解决普通实际问题的软件，即应用软件，需要根据不同的应用场景和软件的最终运行环境，对不同来源的代码进行集成，这就需要「集成方案」。 「集成方案」也称为「解决方案」，它和具体应用场景和软件运行环境紧密相关，灵活性与复杂程度较高，但通用性不强。 「集成方案」是一类专业知识，同样可以被加工为「集成代码」，其结果是固化了被集成知识的范围以及使用方法，也就是固化了知识作为生产工具、形成生产力的过程。 「集成」决定了以软件作为生产工具，形成生产力的生产关系——如何加工数据，并形成「数字产品」。 一个应用软件（系统）的整体，是集成多个复杂知识领域的结果。 设计复杂系统的模块化划分原则，依据的是不同领域的知识点。 在设计过程中，声明对其他模块代码的引用和依赖，即表达了对其他知识的潜在使用需求，产生了知识消费的意向。 对软件产品进行公开发布，是对知识的产品化发布，一方面将自有知识转化为拥有自主知识产权的知识产品，另一方面也确定了对被集成知识产品的订购关系。 完成一次软件产品的交易，等同于完成一次对知识商品的交易。 做软件的，为什么总加班？ 软件部门的工作内容 在软件部门，按工作内容定义的职位已经非常繁多，架构师、程序员、开发者、码农，这些概念既有能力上的交集，也有经验上的差异。 职位的划分方式，在不同IT规模的企业是不同的，有意思的是，这会呈现出千变万化组织结构——直接反应了企业内、来自人力资源的生产力。 （我想，这也是不少IT行业的研究图书，例如吴军博士的《浪潮之巅》，对企业组织结构进行研究的原因。） 单看企业软件制造过程的两个工作内容，还是比较简单的。 架构设计——制定集成方案 这是最为「烧脑」的「重脑力劳动」，要求从业者对「以知识作为资源进行开发」具备三个基本素质（生产力）：「系统性理解、场景化抽象、灵活集成」。 被加工的「知识原材料」可以分为四类：「多视角的应用场景」、「可被集成的软件」、「运行的目标硬件环境」和「定制软件的实现工艺」，最终形成的设计产物，就是前文所提到的「集成方案」。 对这四类「知识原材料」的深入、系统性的理解，掌握每个部分的机理，是形成一个合理、优秀「集成方案」的先决条件。 这里的优秀，指的一个通过「集成方案」固化下来的复杂系统（包含软硬件），既能解决目前应用场景实际问题，同时能够保持长远发展所带来变更的「灵活适应性能力」。 「集成代码」是「集成方案」的软件形态，需要通过「编码」进行实现。 实现工艺——实现集成方案 编写源代码，是实现过程的首要环节，主要以敲击键盘、点击鼠标，并用眼睛观察计算机在显示器上给出的反馈，验证编码正确性构成。 编码既是体力活，也是个手艺活，它能够直接决定软件作为未来生产工具的生产力——性能，也就是看在相同条件下，能不能最大地发挥出计算机的通用计算力。 当然，人们已经深刻的认识到，人作为直接生产力，难以保证生产质量的稳定性，所以源代代码生成器（模板引擎，生成源代码的软件机器）也越来越多的涌现。 到底为什么老加班？难以说清的工作环境 这里所说的工作环境，不是指有没有免费、美味工作餐，提不提供下午茶，配不配备高效的办公用户——个人PC。 当然了，这些都能够提高员工的工作效率，降低企业隐形成本。（干活不开心，哪有生产力） 从前面描述的工作内容中可以明显的感觉到，「知识原材料的不确定性」是难以定量描述工作环境的根本原因。 也就是说，「知识原材料」没有像实体经济、制造业的那样工业标准。很少见到一个软件产品会标注着「执行标准」。 「多视角的应用场景」 大多数来自于应用场景各个参与方，以文字陈述性质的「功能需求说明书」，经过无数人的转手，原始意图已经被转义为「不知所云」。 「可被集成的软件」 软件被集成的条件是能够开放互联，提供代码级的集成能力。 对于已有软件集成者，一方面，阅读文档是最为直接了解原作者设计思路和意图的方法，另一方面，阅读源代码的边界判断条件，是精确掌握已有软件功能特点的必要手段。 现实中的普遍现象是，普遍存在说明文档的过期或者缺失，这导致已有软件的集成者只能够阅读源代码对知识结构进行还原。 这对于一个需要集成复杂的、规模庞大、超过个人或者团队认知能力、学习能力的软件而言，无疑是一个盲人摸象的行为。 更不幸的是，当面对一些庞大、功能不稳定，只提供机器码，不提供源代码，说明手册描述不准确的软件，集成者看到的将是——末日。 「运行的目标硬件环境」 众所周知，软件是要运行在硬件之上，才能把硬件的「通用无目标计算力」转换为「特殊专项生产力」。 硬件的可靠性是基础，它的不稳定性可能来自于网络、来自于存储、来自于芯片，也可能来自于人为事故和自然灾害。 硬件的不稳定性，一样需要通过软件进行解决。 这些看不见摸不着的能力，不容易被应用层面的普通人理解，更难以体现价值，也只有发生系统故障、信息泄露、密码被盗才会被注意到。 「定制软件的实现工艺」 应用系统软件之中，一定会包含根据应用场景的「定制部分」。 定制部分的软件交付能力，现阶段不可能由一个人独立完成，也就是需要一个团队合作才能完成。 有合作，就会有分工，有分工就会有上游和下游环节。 从软件的设计、实现、交付、到维护，每个环节都是上一个环节的下游。 复杂的依赖关系，交付过程导致质量问题难以被追溯。生产事故的出现，下游为上游背黑锅，在IT运营能力落后的企业里，是一个普遍现象。 解决上述种种问题的手段，就是——加班。 提高软件行业生产力的方向 制定企业IT运营能力基线 每个企业都会遇到IT系统的建设与持续更新问题。软件应用场景的变更是频繁的，计算机硬件设施的更替是缓慢的。 对于企业IT而言，首先要深入理解应用系统是「蛋糕式」集成的的产物，每一层对下层的集成，都应该按照不同的速度进行持续的「新陈代谢」。 每一层对上一层的支撑，应当形成企业内部的「可操作标准」，包括可靠性指标、集成模式、准确的文档说明，明确的责任关系，以及利益分配关系，有条件的还应当与财务报表相结合。 每一层对上一层的支撑，还应当形成「按需自助的发布订阅」机制，对于陈旧的知识所对应的过期软件，应当提供下架、下线的能力。 改变以编码作为唯一集成方法的集成模式 固化的集成模式——根据已有经验，人工设计和组合已有软件——是企业IT系统为企业商业模式所带上的一副手铐。 应当把每个知识点——也是软件功能点——作为一个神经元，通过机器学习的算法讲企业生产力自适应的集成在一起。 软件自主研发与商业采购并行 以交付产品为商业模式的企业，其核心竞争力是「应需而变」的柔性生产力。 交付「数字产品」企业，其生产力则直接依赖于企业IT生产系统，这一部分的软件产品，应当以自主研发为主，目的是保障商业模式所需要的专业知识与IT能力的高度一致。 与企业主要产品所需要的核心生产力不相关的软件，采购成熟商业产品（主要评估维护成本）。从0到1的学习知识，掌握知识的成本远比直接购买知识的成本高。","tags":"ideas","url":"/articles/how-to-build-enterprise-software","loc":"/articles/how-to-build-enterprise-software"},{"title":"基于 HTTP/1.1 协议, 设计一个REST-like的RPC协议（下）","text":"HTTP/1.1 协议的潜力 RFC对于HTTP/1.1的规范，主要以 RFC2616 为基础，在 RFC7231 , RFC5789 进行了补充说明。 HTTP/1.1 协议，主要有9大方法，其中主要考察的有： POST 写操作 PUT 写操作 PATCH 写操作 DELETE 写操作 HEAD 读操作 GET 读操作 TRACE 读操作（但可能会产生副作用） 另外的 CONNECT 方法主要处理与 HTTP Proxy 相关的事务 , OPTIONS 方法用于对协议内容的协商。 在2014年，RFC通过 RFC7230-7236 对RFC2616进了「Replace」。 不过RFC2616应用实在是过于广泛，即便是被宣布「Dead」，运行在全世界各地的协议实现，仍然是主流。 幂等性考量 幂等的概念是，对于相同的请求，被处理任意次，对数据的操作结果，等同于处理一次。 满足幂等性要求的Method，一般都是对于数据操作安全的。对于读操作，显然是满足幂等性要求的。 PUT DELETE HEAD GET 上述四个方法，HTTP/1.1 要求协以幂等的方式进行实现。其中 HEAD 以及是 GET 是明显的读操作，而 PUT 和 DELETE 是写操作。 在实现层面，对于幂等性的实现，都要求由请求方提供唯一性标识，也经常称之为「流水号」。它的生成方法，可以参见之前写的这篇文章： 标识与唯一标识概览 。 当然，标识也可以通过请求方提供的多个唯一性要素，类似以「联合主键」的方式，在服务端进行计算和判定一致性。 承载性考量 HTTP Header 一般来说，Header部分的数据，都用来传输元数据。Header部分的数据结构，都以 Key-Value 的形式出现。 对于复杂的Value，也就是Value中再嵌套数据结构，可以采用「;」对齐进一步 Key-Value 化。 常见的 Request Header有： User-Agent : Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36 Refer : https://www.google.com/ User-Agent : 用于申明客户端的身份，其本意是用于声明「用户操作行为的代理者」。 Refer : 用于申明引用的地址，也就是本次请求源于上一次请求的地址。在分布式架构下，这个字段本质上是可以很好地用于声明一个请求链路的「上一跳地址」。 常见的 Response Header有： Status Code ： 200 Server ： SimpleHTTP/0.6 Python/2.7.10 Date : Mon, 19 Dec 2016 14:16:20 GMT ETag : W/\"5715dcfb-47e8\" Expires : W/\"5715dcfb-47e8\" Content-Type : application/json; charset=UTF-8 Status Code ：是最为熟悉的响应头了。诸如 401 , 403 , 404 , 500 , 503 等等响应码，RFC都对其进行了「业务化的定义」。 Server : 默认都是以应用服务器的提供者和版本作为响应值。很多人都会把 Server 的概念等同于 Machine ，这是不正确的。 Date ：指的是这一响应结果，在``Server``的响应时间， Client 可以对这些数据进行加以利用。 ETag ：则是对响应体进行的摘要Hash计算，设计的初衷是为了让 Client 降低比较多个响应结果的差异，提高性能。 Expires ：同样是提醒客户端，这一响应结果的有效期是多少，客户端可以自己根据过期时间，对所辖的缓存进行处理，或者出发其他时间。 Content-Type : 方便 Client 对响应体进行反序列化的解析操作。 HTTP Body HTTP Body 并不是想象中的那样，只有 GET 方法不能够支持请求体的传输。 7个方法的 Request Body 支持情况如下： POST 支持 PUT 支持 PATCH 支持 DELETE 不支持 HEAD 不支持 GET 不支持 TRACE 不支持 需要注意的是， DELETE 方法并不支持请求体的传输。 再看一下7个方法对于 Response Body 的支持情况： POST 支持 PUT 支持 PATCH 支持 DELETE 支持 HEAD 不支持 GET 支持 TRACE 支持 相比之下，Response Body的支持情况，只有 HEAD 方法不支持了。 整体而言，对于用户贡献内容的行为（User Generate Content），HTTP/1.1 协议明显有着不平等的倾向性。 也就是说，只有 POST , PUT , PATCH 三个方法支持用户侧「提供内容」。 现如今，任何的一个互联网平台，都以 UGC 为核心，以用户提供的 内容 作为企业产品的生产资料，HTTP/1.1是不是有些落后了呢？ 另外，作为程序员，不了解 PUT 以及 PATCH 这两个幂等Method的正确方法，并且在前端生成「唯一性标识」，没有成熟框架的条件下，选择大面积使用 POST 方法，似乎也得到了一个看似合理的解释。 提交-补偿模式的处理分布式事务的协调方案 对于分布式事务，一共有三种典型的协调方案，分别是： 提交 (Commit) - 补偿 (Compensation), C-C模式 尝试 (Try) - 确认(Confirm) / 取消（Cancel）, T-C/C模式 事件溯源 (Event Sourcing), ES模式 此处，对 C-C 进行一个极为简单的概述。 C-C 模式，也就是对数据进行正向操作的「反操作」，是在同步业务场景下，最简单的模式。 分布式事务的参与者的模型，是 1:n , 也就是分属于不同服务的 1 个消费者( Client )与 n 个提供者( Server )， 共同完成一次协调过程。 在消费者内部，需要内置一个「协调器」。 每次协调过程，则对于一个「协调处理单」的实体概念。 消费者，每次在进行「协调请求」前，除了需要准备好请求内容之外，还要准备好生成一个「协调处理单」的唯一性标识，记为 RequestId 。 消费者如果作为调用链中的一个中间环节，那么还需要附加携带 TransactionId 作为全局流水号，为一次完整的全链路跟踪提供线索。 提供者，每次在处理请求时，需要记录上游提供的 RequestId ，同时还需要对响应结果，生成一个 ResponseId ，并携带 RequestId 作为关联标识。 提交-补偿模式的REST-like实现示例 消费方请求示例 C-C Commit Request cURL Syntax curl -X PUT -H \"Content-Type: application/json\" -H \"User-Agent: <ConsumerId>\" \\\\ -H \"Referer: <TransactionId>\" -d <RequestBody> \"https://<domain>/<path>/<RequestId>[?v=<Version>]\" C-C Commit Request cURL Example curl -X PUT -H \"Content-Type: application/json\" -H \"User-Agent: REST-like-Consumer\" \\\\ -H \"Referer: 0987654\" -d '{ \"title\":\"This is an request example.\" }' \"https://api.yanjiong.wang/article/new/67890\" C-C Commit Request HTTP/1.1 Example PUT /article/new/67890 HTTP/1.1 Host: yanjiong.wang Content-Type: application/json User-Agent: REST-like-Consumer Referer: 0987654 { \"title\" : \"This is an request example.\" } 提供方请求示例 C-C Commit Response HTTP/1.1 Syntax HTTP/1.1 <Status Code> Server: <Provider>/<Version> Content-type: application/json [ Date: <Date> ] [ Last-Modified: <Date> ] [ ETag: <Content Hash> ] [ X-CC-RequestId: <RequestId> ] C-C Commit Response HTTP/1.1 Example HTTP/1.1 200 OK Server: REST-like-Provider/2.1 Date: Wed, 21 Dec 2016 15 :03:33 GMT Last-Modified: Tue, 20 Dec 2016 08 :37:25 GMT ETag: W/ \"ebf-1591b60c988\" X-CC-RequestId: 67890 { \"title\" : \"This is an response example.\" }","tags":"ideas","url":"/articles/design-an-rest-like-rpc-over-http11-part-2","loc":"/articles/design-an-rest-like-rpc-over-http11-part-2"},{"title":"基于 HTTP/1.1 协议, 设计一个REST-like的RPC协议（上）","text":"REST本身是风格，不是规范 对于 REST 本身，以及它的四级的 Uniform interface 的介绍，遍地开花，本文不作冗余的介绍。 较为权威，但不一定公正的描述，可以通过前面的链接直达 Wikipedia。 REST只是一种实现风格，不是一个强制规范，更连连RFC规范都算不上。 （ RFC7231 作为参考文献，提到了一下 ） 由此，REST的历史可以追述到2000年，也就是那篇很多人听过，但可能很多人没读过的 博士论文 ，它来自Roy Thomas Fielding。 2000年，离现在也有段时日了，如今REST怎么就突然走红了呢？几个正常人都能够想到的因素是：它借助了日益「完善的HTTP协议」、丰富的工具链，网络的日益发达。 对于HTTP协议，最权威的描述，莫过于RFC对其制定的规范了，有兴趣的可以去这里看下我对它的 简要概览 。 可以说，REST对于HTTP协议的理解是比一般人要深入的，也使得URL的设计产生了「设计感」。 REST的优势 丰富的工具与运行时环境 例如， cURL (最好的「全能」URL处理命令行工具) , POSTMAN （最好的GUI调试HTTP工具) , NGINX (最有希望成为市场第一的HTTP Server) , Apache HTTP Server (稳居HTTP Server排名第一的常青树) 由于HTTP协议，还能够非常好的通过部署SSL证书，实现HTTPS协议，REST的安全性也能够得到一定的提升，比如不安全链路下的内容防篡改。 无状态 这看上去是REST的一个优势，但使用REST的大多数服务，都是有状态的。无状态的设计，则是把对状态管理的责任，甩给了第三方平台。 也就是说，无状态，更多的是对RPC通信协议的「无状态化设计」。 服务对于无状态化的处理，大致有三种方式： 状态信息通过请求，也就是入参传递 状态信息通过外置的数据源存储，可能是缓存，也可能是数据库 托管给运行时环境的容器，例如J2EE应用服务器集群 Uniform interface 这一点，是REST最只管，最富设计感的特性，它可以使得一个URL表达一个客观对象，使得URL富有现实含义。 并且能够借助于，HTTP 协议的4个基本Method对这个对象的状态进行维护。 最常见、入门级的例子，是对于 Order , 或是 Book ，再或是 Article 这样的实体进行维护，比如以下四个HTTP Method： POST : https://yanjing.wang/articles/ GET : https://yanjing.wang/articles/design-an-rest-like-rpc-over-http11 DELETE : https://yanjing.wang/article/design-an-rest-like-rpc-over-http11 PUT : https://yanjing.wang/article/design-an-rest-like-rpc-over-http11 URL一致性，使得这些URL看上去「几乎完美」，它及表达了目标对象的所述域，也表达了分类，还为目标对象分配了唯一性的标识。 REST的不足 不支持分布式事务 关于REST的绝大多数文章里，都没有设计「分布式事务」，这个复杂、难解的问题。 对于「分布式事务」，我的一个观点是——这是个伪命题。分布式事务并不存在，只存在本地事务。 在分布式环境下，保障多个点数据一致的算法，有Paxos以及Raft。 而要保障多个对一个事件所进行的操作都是「一致的」，则需要协调器的参与。 这里的「一致的」，所指的并不一定是保证两个被操作数据的一致性，而是「同目标」。 例如，对一篇 Article 进行 POST 动作时，常见的，还会更新这篇 Article 所标注的 Tags 和 Category 索引。 更新 Tags 与 Category 则是同目标，不同结果的两个子操作。 在复杂场景下，对 Article , Tags , Category 的维护，可能分属于三个独立的系统。 这需要有一个协调器进行分布式协调，才能保障一篇新的 Article 被正确发布，保障文章与两个索引的一致性。 使用场景的自述型 HTTP协议是被广泛使用的，它经常出现在普通人的视野中，普通人可能不了解HTTP所代表的全称，但在记忆网址，也就是域名的时候，不会忘记HTTP这个「符号」。 那么，一个HTTP地址，所代表的，是一个可被浏览器访问，并能够通过浏览器渲染出一个Web页面的地址，还是一个仅仅传输JSON格式报文的API地址呢？ 很显然，类似 https://yanjing.wang/articles/design-an-rest-like-rpc-over-http11 这样的地址，难以被分辨。 一般都需要通过浏览器进行尝试，或者通过阅读配套的文档才能够了解其使用场景。 在传统的软件工程项目中，在一个域名下的Application，经常会既提供用于浏览器访问的Page URL，也提供用于浏览器请求后端数据的API URL，这使得URL的设计更为复杂。 另外常见的做法，是为Page以及数据提供不同的访问域名，例如用域名 https://api.yanjiong.wang/v1 专门提供API服务，用域名 https://yanjong.wang 专门提供Page服务。 这些应用实践方法，都会为软件工程带来更多的复杂性，更高的集成难度。 报文的承载能力 需要注意的是，一些HTTP方法，是不支持 Request Body 进行数据传输的。 虽然，作为客户端，可以在准备报文时，准备好 Request Body 进行发送，但RFC规范，则对这种情况作出规定——服务端可以忽略这些不应该出现的 Request Body 。 为人熟知的HTTP Method，就是 GET , 它并不支持客户端发送 Request Body , 而仅仅能够从 Request URL 中传输请求数据。 不太为人熟知的 DELETE 也与 GET 类似，不支持 Request Body 。 复杂场景下的RPC协议与报文的要求 URL要求 需要能够秉承 REST 风格的优势，也就是 Uniform interface 能够直观的区分两次不同的请求， 既能够表达对客观单个实体的操作，也能够表达对于一组实体的「事务性操作」 报文要求 以JSON为基础，在报文体较大时，不解析报文体保障性能。 能够提供相关扩展机制，对参数进行非JSON的序列化 能够快速的进行「回滚」，也就是撤销动作 追踪要求 能够在分布式条件下，对请求的调用链路进行跨系统无缝跟踪 能够区分首次与重试不同的请求 便于日志记录，还原故障现场的上下文环境 版本要求 能够区分不同的版本便于路由 能够由客户端指定兼容版本区间 查询要求 提供处理过程中的状态查询能力 提供处理结果的查询能力 能够实时展示调用进度 安全要求 提供报文传输安全性保护能力 提供双向身份认证能力 流量控制 应急隔离","tags":"ideas","url":"/articles/design-an-rest-like-rpc-over-http11-part-1","loc":"/articles/design-an-rest-like-rpc-over-http11-part-1"},{"title":"PaaS 为什么至今没有成功的商业案例","text":"海洋球是五颜六色，给儿童玩的一种游乐设施。海洋球的多变性，给孩子们带来了无穷的乐趣。当要用脚踩在上面的时候，海洋球都会由于受到外力，发生位移。对未来的无法预知，增加了这样一个简单娱乐项目的乐趣。 IaaS, PaaS, SaaS 在 Windows 桌面时代就早已存在 任何一个写云计算历史的，都会写到，云计算分为IaaS, PaaS, SaaS 三个层面。表面上，这是软件运行发生了革命性的变化，从集中式的硬件环境走向虚拟化的运行环境，并逐层提供向上支撑：IaaS提供虚拟化的硬件，PaaS提供分布式的中间件，SaaS则交付最终的应用，非常完美。 在这里，需要着重关注一下PaaS。在云计算出现之前，PaaS的身影在哪里？其实，它不在服务器端，而是在最终用户的PC端，也就是以Microsoft Windows为代表的操作系统。 没错，Windows 是上一个时代的PaaS。它定义了，上层应用程序的规范，定义了应用程序的标准格式PE，也提供了统一的软件开发工具Visual Studio。 在互联网时代还没有到来的时候，软件的复制成本是高昂的，需要通过线传统渠道对软件进行销售。通过限制软件的使用许可——License，可以稳定的获得软件的销售收入。 在那个时代，有Intel 这个IaaS厂商的大力支持，外加上实体的工业标准支持，给了Windows一个较为稳定的**基础基线**。在弱的工业标准，都要比离开硬件的软件文档标准强。（可以发现，吴军以及诸多老外，都喜欢称之为Wintel体系。） 同时，在Windows这个唯一的PaaS之上，提供个各个硬件厂商的扩展空间，驱动程序机制。也是如今SPI (Service Provider Interface)的另一种实现原理。各大硬件厂商所开发的驱动，可以认为是Windows平台上的底层生态，UGC（User Generate Content）的方式之一；另一层面的UGC，则是使用 Visual Studio 开发的桌面应用程序（当然，还有Delphi 这个IDE）。 微软唯一没有做的，是对第三方程序，尤其是桌面应用程序的知识产权保护。各种破解，软件加壳，反跟踪，都是那个时代流行的知识产权保护的「黑科技」。 苹果、iOS和应用商店的启示 相比之下，苹果AppStore的成功，离不开iOS的安全性设计。iOS提供的是一个面向软件开发商有利的安全的运行环境。（现如今，越狱使用iOS系统的人，越来越少了。）这种机制，既保障了软件开发者的知识产权，也保障了软件最终用户的隐私安全——再非用户授权的条件下，第三方应用程序不得访问用户的隐私数据。例如：相册、联系人、相机、位置信息。 苹果没有开放硬件的设计，不走Android基于通用硬件架构的软件形态。很多人都会归结为这是乔帮主的固执、以及对极致的追求。我倒是认为，这是软件需要一个明确硬件运行环境定义，才能够发挥出最大效能，实现最极致体验的必要条件。 现如今，最大的PaaS，应当是苹果的iOS系统。当每个移动App去适配多款不同分辨率，不同屏幕尺寸，不同操作系统的Android系统的时候，受苦受累的，都是一线程序员。 兼容的价值——只有苦劳，没用功劳 如果说，云计算所定义的PaaS是承上启下的一层，那么这一层既要肩肩负对硬件的兼容，又要肩负对上层应用的兼容。 这看上去是中流砥柱。但目前，确只是空中楼阁。 对于PaaS来说，IaaS是海洋球。 对于提供虚拟化硬件环境的IaaS多方，距离应用层的SaaS太过于遥远，可以把责任推卸给PaaS。 对于SaaS来说，PaaS是海洋球。 对于在应用层体现IT整体价值的SaaS多方，则需要随着实际场景提出各种苛刻需求。 多方对多方，这就是像三明治一样夹在中间PaaS。 兼容性带来复杂，并且是「级数级的」也就是接入方的根据排列组合，产生若干总组合方式。 还记得高中的那个对于组合的定义吗？ 从 n 个不同元素中取出 m(m≤n) 个元素的所有组合的个数，叫做从 n 个不同元素中取出 m 个元素的组合数。用符号 C(n,m) 表示。 这就是PaaS所要面临的兼容性复杂度上限。 于是乎，PaaS总是找不到硬气的存在理由。对于任意的直接用户而言，为其兼容它用不着的某个技术，价值无法得到认可。 PaaS的复杂性，没有显而易见的价值。 确保PaaS可持续发展的四个正确姿势 从逻辑上，PaaS确实应该存在的。这直接关乎到软件的开发成本。 众所周知，从事软件工作的优质一线编码工程，从事设计与框架落地的架构师，目前都被优厚的待遇，光明的职业发展空间所吸引，大多就职于世界上或者国内一流的互联网公司。 这些优秀的工程师与架构师，就像航空公司的飞行员。需要大量时间的磨练，才能成长。任何的成长，都需要时间——这个无条件的要素。 反观程序员的日常工作之一——编码，其中又饱含了大量重复的劳动。例如，如何解决分布式事务问题，如何保障高可用的稳定性，如何把业务逻辑实现。系统中的知识是通过零碎的代码集成在一起的，知识不仅在要在企业中复用，更需要在社会中发挥价值，这种价值的发挥，不应当以员工的跨企业流动为转移。 PaaS要想要得到健康的发展，以下四个方面是重中之重的必要条件： 运行在可控的虚拟硬件环境下 此处的可控，不代表自主建设，也可以选择一到两个差异性不大的公有云IaaS为基础。有条件的可以自行建设IaaS。 目的只有一个，降低底层兼容性的成本。 另外，从降低整个社会成本的角度出发，采用公有云的商业模式，也是最低的。 提供安全的数据处理环境 软件运行时数据所有权，是最终用户的。运行环境有义务和责任，保障数据的安全保存、安全传输、安全处理。其中前两者，目前的技术较为成熟，但安全管理，尤其是对秘钥以及证书的安全管理，使得安全的加密算法形同虚设。这也是软件研发、运营过程中的短板。 安全处理技术，是目前大数据安全、合法的最大屏障。也就是说，当数据的第一创造者，将数据交给第三方进行计算的时候，第三方不能够获得数据的真实含义——在密码学上的算法称为「同态加密」——还相当不成熟。 提供软件运行的精确能效计量 软件，本质上是若干知识沉淀为代码（用代码解决人的问题、用代码解决计算机的问题），而软件价值的体现方式，是被使用。任何软件代码中，都包含了若干知识工作者的成果。 每一次的代码集成、每一次的函数调用，都是一次「知识互联」的过程。其中包含了对业务知识的使用，对计算机知识的使用。在不能够区分每个知识能效的条件下，价值的最终体现，就像「大锅饭」一样。在发生故障的时候，一定会发生相互推诿；在优秀评比的时候，一定会发生不公正的事件。 架构中唯一职责的设计，需要与自然人形成映射，不管是从客观知识点，还是从代码实现上。 软件的智能集成 软件的每个小模块，就犹如若干个神经元。在目前的大多数情况下，都通过静态的编译脚本，把他们编译称为部署介质，或是部署包或是镜像。在软件的运行期，它们又通过程序设计好的规则，进行相互访问，以实现人定义好的处理规则。 软件的模块足够多，组合的方式也无法枚举。 未来，应当采用面向结果集的交互方式，与最终用户进行人机交互。 就犹如导航，设置好目的地，设置好必经的路径，剩下的，交给机器学习做自动集成和优化吧。 海洋球，应当是软件在应用层给人以随需而变的体验。 软件，应当代表最先进的生产力。","tags":"ideas","url":"/articles/colorful-ball-the-paas-foundation","loc":"/articles/colorful-ball-the-paas-foundation"},{"title":"专业知识型产品的开发与价值体现","text":"专业知识的形态 专业知识的形态包括： 软件源代码 学术性论文 发明专利 软件源代码的特殊性是程序员进行编写（这需要专业知识），它的是使用方式是由计算机对其进行执行，自然人使用软件的过程是驱动软件的运行状态发生一系列的改变。 学术性论文或者发明专利（这也需要专业知识），都是以文章的形式编写，需要通过自然人对其进行直接使用——阅读与理解。 学术论文价值表现是对其进行引用，发明专利的价值是其融入到具体的商业产品之中，而代码的价值直接表现是被运行时依赖。它们都是知识工作的产品。 在形成有价值的知识成果之前，都需要经历入门训练的过程，对于普通人来说，需要18个月以上的初步学习与实践。 专业知识型产品的开发 专业知识型产品，包含了三个方面： 对先前知识的理解，成为了可利用的已有知识资源（旧知识）。 对未知的探索形成的知识型总结，成为了新的知识资源。知和识的过程，是一种对信息的非线性加工工艺，而这种工艺，应该叫智慧。 知识型产品中，一定包含了对新旧知识的集成方案，而方案本身，也是一种新的知识。 其中，对于未知的定义，是相对于知识型产品制造者而言的，也就是相对来说是一个唯心主义的定义。也就是我不知道，等于不存在。 「重新发明轮子」的现象，是一个中性的现象。重新发明轮子的过程，是对旧知识的理解的过程，也是开发「新知识」的过程。 时间和智慧，是知识型产品的最原始和最必要的生产资料。 获得时间的方法，可以通过购买其他自然人的工作时间，也可以把没有创造性的脑力劳动交给计算机。 而获得智慧的方法是？ 专业知识工作的价值体现 自然人个体或团体，是知识的原始获得者。这些个体，一般服务于四类组织：高校与科研机构、企业研究院、软件公司，以及独立个人或团体。 来自高校与科研院所的学术论文 获得研究基金自助，是其主要变现方法。 来自企业研究院的发明专利 发明专利，作为企业的无形资产，也作为企业产品的无形原材料，融入到企业产品中，经过市场销售进行变现。 专利发明人，企业通过薪金对他的知识型劳动成果进行购买。 商业产品源代码 作为商业产品的一部分，这类产品不一定是软件产品，也很有可能是一个虚拟平台的一部分，例如互联网平台。 源代码的编写者，同样的，企业通过薪金对他的知识型劳动成果进行购买。 独立个人与团体开源源代码 源代码的作者，可能会获得某些开源软件基金会的部分资助，也可能自行设立收费渠道获得「善意的捐助」，再或者增强了在行业届的影响力，间接地获得经济利益。 而开源基金会的支撑着，往往来自商业公司。 专业知识产权的商业保护 学术论文 学术论文，有着严格的体制对齐进行原创性保护，例如学位评定、职位评定，这些都将直接影响到知识原始获得者的经济利益。 学术论文的引用，是公开且唯一的，有公开的独立机构确认引用的有效性。同时，每一次的引用，都增加了知识的价值。 软件源代码 软件源代码的依赖使用，是非公开的，这是源代码的运行时环境所客观决定的。 对于计算机的知识产权保护的措施，仍然是计算机程序，在原作者对最终运行环境不可控的条件下，对计算机程序进行逆向工程获得源代码，是知识产权受到侵犯的常见方式。 计算机软件的物理规模，取决于其架构的形态，典型的Client/Server架构，是普遍的形态。 在Client端，成功的商业化知识产权保护形态是苹果iOS系统，完善的保护了每个App的源代码知识产权（归软件的开发商）与软件运行过程中产生数据（所有权归软件的最终用户）的安全性。 在Server端，有条件成为公开的独立机构，能够对其运行期使用进行有效保护的模式是公有云。公有云保障知识产权的公信力，是在公有云上建立商业生态的必要条件之一。同时，公有云还需要做到对代码的使用计量和计费，对数据进行隐私保护。 然而，具备这些特性的公有云，似乎还没有出现。 需要注意的是，Browser/Server的架构下的Browser侧的知识产权较难以保护，也许各大浏览器厂商正在努力，我却不知道。 从知识价值放大器到知识开发器 机器学习的价值，是将计算机的价值定位，从知识价值的放大器转变为了开发器。 计算机，作为知识价值放大器 代码的优势，是能够通过计算机，迅速放大其价值。 相比之下，学术论文的价值，放大的方法受制于行业体制，较为缓慢。 计算机，作为原始知识开发器 在机器学习大规模到来的时代里，机器学习的结果——对于特定应用场景的模型参数，是除了自然人之外获得知识的新方式。 通过机器学习所获得的模型，是一种如何集成现有「神经元」，广义上是任何资源进行使用的集成知识。 有意思的是，当计算机成为知识生成器之后，也需要通过「训练集数据」，进行入门的学习和实践，才能产生实际价值。","tags":"ideas","url":"/articles/the-development-of-professional-knowledge-products-and-value-representation","loc":"/articles/the-development-of-professional-knowledge-products-and-value-representation"},{"title":"理解软件","text":"软件的出现，是为了解决计算机本身硬件无法快速适配实际应用场景所提供的扩展能力。（虽然有FPGA，可以对硬件进行重复性的烧录定制） 软件本质上是复杂的。 但，软件表象上「应该」是简单的。 软件是工具 工具的出现，是为了解决某个特殊问题，并且高效 软件 = 代码 + 数据 软件是处理数据的工具 数据需要通过代码表达 处理方法也需要通过代码表达 代码 代码，很多时候都是指源代码。也就是用某一种计算机语言，通过程序员手工编写的方式，阐述由计算机执行的指令的逻辑。 在一个混合的场景下，一段代码可能解决了多个方面的问题： 现实中的实际问题 计算机运行时的问题 记录了整个处理过程 额外提供了事中、事后的监控审计能力 在这种场景下，编码对于程序员而言，是一个跨领域知识集成的过程。这些知识都通过代码的方式，被集成在一个个源代码文件里。程序员需要深入理解这些来自不同层面的知识，平衡相互之间的冲突，才能得到一个较为合适的程序。 这是一个制造虚拟世界的过程，由于制造水平和认知的限制，很容易造出一面面现实世界的哈哈镜。 数据 很多时候，人们对于一个概念性名词的理解是不同的，也就是说，对于同一个概念，不同的人有各自不同的理解。概念是通过总结、抽象而得到的，反过来，理解概念的过程，是一个主体在其实际环境进行解释的过程。 实际上，人还热衷于给一些概念起新的别名，或者用简写的符号，方便自己的理解，或者体现一些与众不同的理念。这些行为，不但增加了其他人理解这些符号的难度，增加了产生误解的可能。 这一切，最终都会在数据上体现出来。 数据是结构化的信息。 环境 软件，没有任何保存价值，只有使用价值。 软件需要运行环境才能发挥其使用价值，这从根本上还需要硬件设备以及电力。 操作系统，完成了软件运行环境差异化的第一层屏蔽与封装。 现如今，实际的应用软件，都需要需要依赖操作系统与其他第三方软件才能够工作。 「缺陷」与「版本」 软件是知识的沉淀，是把已知的知识翻译为计算机语言的成果。 知识是一定是有局限性的，受制于人所在的环境、视野以及认知的方法，甚至还有文化和政治的因素。 知识的集成，有若干种选择，自然也受到价值观的影响。 因此，软件存在缺陷也是必然的。 软件，永远都不会到达一个没有缺陷的状态。未知相对应已知，太过于浩瀚。为此，为了使得现有的知识得以被使用，为软件标记一个「相对成熟」的稳定状态，人们采用了「版本」这个概念。","tags":"ideas","url":"/articles/understanding-software","loc":"/articles/understanding-software"},{"title":"Happy Hacking Keyboard Professional 2 Type-S","text":"键帽 空格键的键帽，最好拆卸来之后反装，否则容易伤到大拇指 光标移动组合键 其实下面这些快捷键，都是macOS自带的快捷键 上一行 CTRL + p 下一行 CTRL + n 行首 CTRL + a 行末 CTRL + e 删除后一个字符 CTRL + d 删除前一个字符 CTRL + h 删除光标之后的所有内容 CTRL + k 交换光标左右两个字符 CTRL + t 移到下一个字符 CTRL + f 移到下一个字符 CTRL + b 括号匹配 CTRL + m 参考资料 http://kaochenlong.com/2013/06/29/about-hhkb-pro2/ https://support.apple.com/en-us/HT201236","tags":"experiences","url":"/articles/hhkb-pro2-type_s-cheat-sheet","loc":"/articles/hhkb-pro2-type_s-cheat-sheet"},{"title":"软件结构的十个基本概念","text":"概念的意义 概念的初衷，是为了沟通，为了加速理解。 如今的这个社会，概念的定义，一部分变成了「市场宣传」的「洗脑行为」。 比如，各大汽车厂商，都会定期面向市场发布「概念车」，向广大的消费者宣传品牌理念，技术趋势，营造诸如「高科技」、「人性化」、「环保节能」的品牌形象。 人的差异，是源于天生对于概念的不同认识、理解，这和其经历过的环境，接受的教育，传承的文化息息相关。不同文化和理念，会对相同概念产生不同的诠释，并体现在对相关事物进行选择的各个方面。 概念的定义 一个好的概念，一定是面向目标受众，指代清晰，便于理解的。 非普适的、专业领域的概念，有另外的称呼——术语。 越抽象的概念，其内涵越小，外延越大，也就是可以解释的范围越大，可以根据实际情况解释出不同的内涵。 越具象的概念，其内涵越大，外延越小，也就是没有太多解释的必要，有特指的效果。 聚合概念 一般的概念定义，是基于一些已经存在、被广泛接受的概念，进行缩略和重组，赋予新的内含，这种类型概念在理解时，一般可以通过「望文生义」的想象，由受众自行解释内涵。 以「手机」这个概念，举个例子。 手机 —— 可以拿在手里的电话机（当然，手机在别处也成为「行动电话」） = 手持 + 电话机 = 手持 + （用电 +可以通话 + 机器） 可是，「无绳电话」又是另外一个截然不同的解释了。概念的诞生，有时会带着时代的烙印。 借用概念 当事物的内涵发生质变的清下，外形不变，人们就又会对概念进行升级。有时，会借用一些概念，以示区分。 以「功能手机」和「智能手机」这两个概念，再举个例子。 功能手机 —— 拥有不同外壳，但仅仅可以拨打电话，发送短信的手机 智能手机 —— 可以连接数据网络，自行安装App应用，满足每个人个性化需求的手机 「智能手机」其实是借用了「智能」这个概念，其实远远没有达到「智能」，任何手机目前都没有「先于人类思考、归纳、演绎」的能力，事实上是由无数的程序员，通过代码，以软件的形式，把预设好的场景、规则植入了硬件之上，使之产生了「智能」的假象。 人们同样喜欢在从其他完全不相关的行业、生活场景中，借用概念。 同样的，在英文中，人们习惯于对词根进行重组，将单词进行拼接。 所以，借用概念，有时也是偷换概念。 创造概念 创造一个全新的概念，是需要大量的文字、图片、语音、视屏，多维度进行阐释。更多的情况下，全新的概念，太过于抽象，而被定义成了品牌。 全新的概念，其实没有那么容易被创造。 概念的根源，是宗教和信仰，是看上去不证自明的公理。（科学,也是一种宗教） 概念的演变 大部分的概念，是通过组合或者借用的方式形成的。 当这些被重组的概念的内涵，作为顶层概念的根基，随着社会发展产生变化的时候，会逐渐与定义时偏差的解释，这导致了顶层的概念同样需要进行重新的定义和解释。 十个基本概念 软件只有被运行，才能产生使用价值。它始于硬件，终于用户交互，是具备「层叠集成」特性的产物。 代码 代码，可以用来表示与计算机无关的实体、关系、逻辑，也可以用来协调和控制计算机的运行时逻辑。 代码，简单而言，至少应该被分为源代码和机器码。 源代码和机器码，是代码的两种形态，前者用于和人的交互，后者用于和机器的交互。两者的相互转换的方法，是编译和反编译，当然这两个过程会产生失真，反编译比较严重。 版本 代码是对客体，用特定的计算机语言进行的「结构化描述」，也是阶段性认知的产物。 版本，则是对代码进行了「不可变的固化」，形成一个暂时地「附属代号」。 版本的意义在于，容易让受众理解，一个新的版本是进行了部分优化、正向修正的结果，但代码主体没有发生太大的变化。 数据 数据，是特定的计算机处理逻辑能够处理的「结构化信息」。它可以存在于内存或者处理器中，也可以存在于存储介质上，还可以存在于网络中。 数据，是代码的血液，使运行中的代码产生实际价值。 资源 资源，是个广义的、相对的概念。 正因为软件在运行时，是具备层叠集成的特性，所以不管采用哪种分层方法，都能为某一层的软件，找到它的运行时依赖——资源。 资源，既包括用代码描述的可被处理的数据，也包括通过代码定义的逻辑处理能力。 环境 环境，也是一个广义的、相对的概念。 软件需要被运行，环境是软件的物理运行时基础。不同层面的软件，具有不同的运行环境。 例如，操作系统的运行环境则是硬件，而浏览器中的脚本代码，运行时环境则是脚本解释器。 容器 容器，同样是个广义的、相对的概念。 容器，是对运行时环境的进一步虚拟划分的结果。 隔离受控是容器的特性 ，两个不同容器中的代码，其对资源的操作是严格受到容器控制的。 提供组件（即容器中的内容）的运行环境。 一种容器，面向不同内容，是同质的。 容器保证运行期不同内容的隔离。 不同层面的软件，可以有不同的实现。例如，在操作系统层面的虚拟化（Docker）、服务与应用层面的运行时环境（OSGi Bundle）等等。 组件 组件，是一组能够独立部署于容器内，提供有效功能的代码，是模块的物理集合。组件在设计时，可以申明运行时的资源依赖，并由容器在运行时为期加载所申明的资源。 一个容器内可以有 m 个组件，且 m ≥ 1 。当 m > 1 时，实现了组件化。 组件化，是软件设计中常用的设计方法。 模块 模块，是一些独立具备有效功能的代码，但模块不能在运行时环境中独立运行。一个组件在设计期申明的运行期资源依赖，可以被多个模块所共享。 一个组件可以有 n 个模块，且 n ≥ 1 。当 n > 1 时，实现了模块化。 模块化，也是软件设计中常用的设计方法。 插件 插件，一般不具备独立的功能，直接依赖于运行环境所提供的资源，不能在设计期向运行环境声明外部的依赖资源。插件中包含的逻辑功能，更多的是以「插入」的方式，嵌入到预先设定的逻辑中，以此适应和增强不同的应用场景。 Filter Chain 是一种典型的插件化设计模式。 插件化，同样是软件设计中常用的设计方法。 配置 配置，同样不具备独立的功能，更多的使用场景，是由用户在使用过程中，自行设定的逻辑或者参数值。配置一般不需要编译。","tags":"ideas","url":"/articles/10-basic-concepts-of-software-structure","loc":"/articles/10-basic-concepts-of-software-structure"},{"title":"软件，不简单","text":"软件的鸿沟 并不是每个人，都可以制造一个软件，它可能是一个简单的应用，目的是让计算机为我所用。 人们在生活中，所使用的自然语言中的很多 普适 的「形容词」，一般都在人与人的沟通中，由客体根据自身特点和实际场景进行 解释 。 例如，「好看」，每个人的解释都不一样。 计算机也有语言和各种方言，人们习惯性的称之为「代码」，并一般用「代码」来指代「源代码」。计算机语言，是「程序员」发起的与计算机沟通的「单向语言」（计算机和「程序员」沟通并不这样「说话」）。而在计算机的代码中，从来没有出现过「好看」，这样的形容词。 代码，代码，到底用码代表了什么？ 与硬件交互的代码，更多的是指挥硬件，如何进行逻辑运算、管理内存、读写硬盘——毫无面向普通人的「应用价值」。 与生活应用相关的代码，更多的解决人们的实际问题——社交、购物、出行等等等等。 软件和普通人，存在着巨大的鸿沟。 一般人无法理解，在软件领域里：架构，是骨架；场景，是肌肉；数据，是血液；界面，是皮肤；体验，是外衣。 这一切，都需要代码表达。 跨越鸿沟的程序员 黑客也是创造者，与画家、建筑师、作家一样。—— Paul Graham: Hackers and Painters: Big Ideas from the Computer Age 优秀的程序员，既是自然语言的翻译师，又是复杂软件系统的建筑师，还得是懂得体验的交互设计师。 拥有系统性认知的能力 「盲人摸象」的故事，是说在缺乏整体的「系统性大局观」的条件下，每个人都用自己的手，去感受大象的外形。 现如今，面对更为复杂的世界，每个人获取信息的带宽，却是有限的。有限的时间和精力，不可能认知无限的未知。碎片化与社交化所形成的认知方式，使得每个个体，更难以形成系统化的知识脉络。 系统性认知，是从已知中找到一个全面且条理性强的普适规律——知识，并能够用规律，有效地推理未知。系统性，是全面性和条理性的综合体现。 对特定场景的系统性认知，是软件在此类场景下产生应用价值的前提。其中，包含两个要素：抽象和建模。 抽象——提炼概念 场景的参与者是多视角的，通过简单的几个现象或者场景，就能够迅速捕获、提炼出关键概念，这是一项典型的「认知技能」。为一个正确的概念取名，是沟通的前提——名不正则言不顺。对于新生事物，新概念的出现，需要大量的传播成本，才能使得每个受众——人，产生 与期望相符 的「正确理解」。 建模——理清关系 通过场景之间、参与者之间的关联分析，能够找出多个视角各自的关注点，是建模的基础。缺乏实际经验，缺乏站在人性角度的思考，是难以建立一个让多方认可的模型。 深刻理解软件的局限性 在克服了硬件的局限性之后，还需要通过三类最基本的数据处理方式，建造出五花八门的应用软件。 条处理 典型以表单交互为源，逐级驱动 异步调用为主，异步中断比较困难 容易产生分布式事务 处理时长为秒级以内 流处理 典型以多维、高维事件为源，内存计算为主 单点故障较容易产生，多实例并行计算一致性较难保证 计算前，采用数据字典进行压缩编码，有利于提高降低内存开销 处理时长为毫秒级或者更短 批处理 典型以数据库或文件中的批量数据为源，以并行计算任务为主 一般由集中的调度器，进行任务的调度 处理时长为秒级以上，分钟级较为常见 软件为什么变复杂 提高单个硬件的稳定性 大部分的硬件的「工况」都是不可靠的，导致软件也缺乏了必要的「工作环境」： 断电会无法工作 过热会自燃烧毁 遇水会短路烧毁 摔打会自燃解体 光纤被铲车挖断 电线被老鼠咬断 … 因此，世上也没有谁，能够保证硬件至软件的100%可靠，不同的可靠性，所带来的成本开销，肯能是指数级增长的。 硬件的品类与品质越多，其稳定性提升的「高可用软件方案」也越多、越复杂。 ——软件变复杂了。 为应用场景提供更多的基础能力 人类社会的发展，是通过知识的积累和传承。而认知这个「实验过程」，永远不会停下脚步。为了让硬件产生「应用价值」，软件则需要在不断克服「硬件稳定性不足」的条件下，虚拟化出「人、财、物、事」的社会镜像，以满足各种各样的「成熟的旧规则」和「不成熟的新想法」。 人类有记忆，所以寄希望于用硬件存储，来模拟一个「永不遗忘」的虚拟记忆。 人类有沟通，所以寄希望于用通信网络，来模拟一个「万物相连」的虚拟沟通。 人类有逻辑，所以寄希望于用逻辑规则，来模拟一个「适时而变」的虚拟规则。 ——软件变复杂了。 要满足定性和定量的双重要求 软件的底层——硬件——是机械性的，不管归结于基因或是传承，各个层面的软件，都体现着这样的「非黑即白的逻辑性」。也就是说，「天生丽质」的软件，自然而然的具备了定量条件下逻辑计算的能力。 没有任何一门软件语言，具备原生的「定性关键词」。相比于「好与坏」，软件其实只懂得「合适」。也就是说，给定一个标准，软件可以告诉你，给定的对象与标准之间的差距有多少，并根据这个差距，再通过一个给定的公式，得出是否合适的结论。 社会中的沟通，很多场景下都是基于不太确定的概念以及定性的形容词，人们需要解释，或者自行解释。比如， XXXX 的解释权，归YYY所有；请 拉好 扶手。 ——软件变复杂了。 要满足人的无限的心理预期 人性的弱点之一，在于「外貌协会」。 响应，布局，配色，文案，手势，一切都要符合用户的心理预期。 无需解释的表达，才能不需要说明书。 人们还希望计算机理所应当的具备： 永不丢失的记忆 呼之即来的速度 因需即变的更新 ——软件变复杂了。 无数个我们 我们在虚拟的世界里，制造了无数个我们的影子。 我们希望在虚拟的世界里，我们的记忆永远不会被忘记。 我们希望在虚拟的世界里，实现我们的奇思妙想。 我们还不希望其他人通过这些影子，拼凑出现实世界中的自己。 我们还希望计算机帮助我们加速认知...","tags":"ideas","url":"/articles/software-is-not-simple","loc":"/articles/software-is-not-simple"},{"title":"标识与唯一标识概览","text":"无处不在的标识 名称是一种相对唯一的标识 在世界里，「相对的唯一标识」是普遍存在，例如： 每个人出生的时候，就获得了一个「相对的唯一标识」——姓名。 城市的道路，都基本上采用了唯一的命名（当然这也需要一个 过程 ）。 显然，对于每个标识，都需要有一个命名空间（namespace），来保证其相对唯一性。 可以说，在人的意识里，对于的实体的描述是基于名字进行的，人们并不希望同名的出现太多，这会在沟通过程中的产生理解困难。 实体在不同命名空间的标识 对于人来说，在家庭里会有小名，在社会中会有正式名字，在社交过程中还会产生绰号。 在中国，对于企业来说，除了企业有名称之外，还有组织机构代码证、有税务登记证、有工商营业执照，并分别对应三个编号。（当然，目前三证合一也在进行中）。 回到计算机领域，围绕主机在网络上的地址，在不同的命名空间中，都会存在一个「相对的唯一标识」用来描述一个实体 每个以太网网卡，都有一个48-bit 的MAC地址 每个MAC地址，可能有一个或者多个IP地址 每个网卡，都可能有一个或者多个IP地址 每个IP地址，都可能有多个域名 当然，每个主机，都会有一个主机名 接续上面的例子，事实上，MAC地址是由 IEEE Standards Association Registration Authority 完成地址段的分配。 对于目前的 1530 个顶级根域（gTLD），以及 IPv4 / IPv6 地址，都由IANA对其进行管理。 小结 标识是从一个典型的场景，对客观事物进行统一编码的过程。 采用 半集中与半自主相结合 的方法，是一种实现「分而治之」十分普遍和有效的设计模式。 标识的唯一性是根据命名空间紧密相关的。 标识的使用 在不同命名空间中实现标识的转换 在中国，对于人名，通常是由公安局出入境管理局完成中文至英文的翻译，同时，他们会把翻译结果写到数据库中，印到护照上。 这中间的翻译规则，通常是根据中文与汉语拼音、汉语拼音与英文字母的两次转换关系完成的。 对于计算机网络，则会有 NAT完成IP地址间的转换，RAP/RARP完成IP地址与MAC地址的双向转换，DNS完成域名至IP地址的转换。 可是，为什么需要那么多不同命名空间的标识标识一个实体？可能最直观的回答通常是这样： 域名为了方便人的记忆与使用 IP地址是为了更广范围的计算机互联 MAC则是为了在物理上保证唯一 OSI开放系统互联7层模型决定的 人们会在不同的领域（也是命名空间）中定义自己的命名规范，这可以认为是领域主权的体现，同时伴生的会是一套与相关领域标识的转换协议。 结构化与别名效应 结构化是把数据的元信息以位置的方式固化是数据中。也就是说，代表某个意义的信息，一定会出现在一个约定好的位置上。 由于标识是被人经常使用的，那么在使用过程中会对大脑形成一定的训练。 人在看到了010-XXXXXXXX，021-XXXXXXXX号码之后，自然而言会产生条件反射，认为两者分别代表了北京和上海；同样的人在看到了139和186之后，分别产生了中国移动以及中国联通的运营商联想。 对于使用者，这种场景，数字类似是一个名称别名。对于程序员，这十分接近「数据字典」的设计模式。 标识转换过程的两面性 别名和正名，同样是来自于两个不同命名空间的标识，之间自然而然的会进行转换。 当然，人们也不会忘记去Hack这些转换协议的设计。 一些是有益的，是实现了更为便利的应用场景。例如：将不同的域名指向相同的IP地址（使用A或者CNAME记录），并结合相关软硬件实现「虚拟主机」，达到资源复用的目的。 一些却是有害的，例如，诈骗电话也经常采用改号的方法，让接听者误以为那是来自某个官方的外呼电话。 同样的，在计算机领域，一样有DNS劫持、DNS污染。 有矛就有盾，进行安全性扩展的 DNSSEC 就是为了对DNS结果，验证不存在性和校验数据完整性验证，不过依然没有实现全面部署。 小结 不同命名空间的标识，在互通时需要进行转换 转换的过程，可能是一个简单的规则，也可能是一个独立第三方服务 标识需要有数据标准的规范指导，以及辅助的易用性工具支撑 标识的生成 标识的生成方法有很多，有集中式的，分布式的；有后端的，前端的，当然还有人工的。 并没有一种通用的生成方法来适应各种应用场景。 人工生成 人工生成的确是一种方式，比如电子邮箱，微信ID，各种论坛的账号。 在人想出标识的那一刻，是无法判断是否是唯一的，对这种生成方式的结果，显然在录入时都需要进行唯一性校验。 所以，下面描述的几种生成方式，是在生成的那一刻就在一个命名空间内唯一，而不再需要进行唯一性校验。 基于数据库生成 MySQL(5.6) AUTO_INCREMENT 特性 Postgres(REL 9.6 Stable) SEQUENCE 特性 Oracle 数据库的 SEQUENCE 特性，有知道这一特性如何实现的，可以在 知乎 做一下解答。 Flickr Ticket Servers ，同时支持Sharding (文章发表于2010年2月8日，算法上线于2006年1月13日)。 一般地，这种类型的生成方案，都可以设置其实初始值，以及增量步长。 基于协调器生成 在不使用数据库的情况下，通过一个后台服务对外提供高可用的、固定步长标识生成，则需要分布式的集群协调器进行。 一般的，主流协调器有两类： 以Paxos为代表的：ZooKeeper 以Raft为代表的：Consul / Etcd ZooKeeper的强一致性，是由Paxos协议保证的；Consul的一致性，官方用subtle(微妙的)来形容。它既采用了Gossip管理集群Membership，也采用了Raft管理Service Catalog。Consul的写一致性通过Raft保证，但Consul的读一致性有三种模式，default / consistent / stale， 其中consistent是强一致的。 在步长累计型生成算法中，最核心的就是保持一个累计值在整个集群中的「强一致性」。同时，这也会为唯一性标识的生成带来新的形成瓶颈。 基于服务内置生成 似乎对于分布式的ID生成，以Twitter Snowflake为代表的， Flake 系列算法，经常可以被搜索引擎找到，但似乎MongoDB的ObjectId算法，更早地采用了这种思路。MongoDB 1.0 是在2009年8月27日 发布 的，并且0.9.10(2009年8月24日发布)和1.0两个版本没有差异。 在StackOverflow上， 最早的一个关于ObjectId的问题 ，时间是2010年1月27日。不知道Twitter的同学，是不是受此启发呢？ MongoDB ObjectId 12-byte MongoDB ObjectId 的结构是： a 4-byte value representing the seconds since the Unix epoch, a 3-byte machine identifier, a 2-byte process id, and a 3-byte counter, starting with a random value. 可以看出，这个方案所支持的最小划分粒度是「秒 * 进程实例」，单进程实例的每秒容量是 3-byte (24-bit)，也就是接近16777216个ID。 有兴趣的，还可以进一步 看代码（MonogoDB 3.3.x Java Driver） 研究：Timestamp, Machine Identifier、Process Identifier、计数器的初始值分别是如何获得的: Timestamp private static int dateToTimestampSeconds(final Date time) { return (int) (time.getTime() / 1000); } Machine Identifier StringBuilder sb = new StringBuilder(); Enumeration<NetworkInterface> e = NetworkInterface.getNetworkInterfaces(); while (e.hasMoreElements()) { NetworkInterface ni = e.nextElement(); sb.append(ni.toString()); byte[] mac = ni.getHardwareAddress(); if (mac != null) { ByteBuffer bb = ByteBuffer.wrap(mac); try { sb.append(bb.getChar()); sb.append(bb.getChar()); sb.append(bb.getChar()); } catch (BufferUnderflowException shortHardwareAddressException) { //NOPMD // mac with less than 6 bytes. continue } } } machinePiece = sb.toString().hashCode(); Process ID try { String processName = java.lang.management.ManagementFactory.getRuntimeMXBean().getName(); if (processName.contains(\"@\")) { processId = (short) Integer.parseInt(processName.substring(0, processName.indexOf('@'))); } else { processId = (short) java.lang.management.ManagementFactory.getRuntimeMXBean().getName().hashCode(); } } catch (Throwable t) { processId = (short) new SecureRandom().nextInt(); LOGGER.log(Level.WARNING, \"Failed to get process identifier from JMX, using random number instead\", t); } COUNTER private static final AtomicInteger NEXT_COUNTER = new AtomicInteger(new SecureRandom().nextInt()); 此处需要注意的是MongoDB的 NEXT_COUNTER 其初始值是一个随机数，这是有利于分库分表的。因为在小并发的条件下，非随机数的初始值，容易产生 偏库偏表 ， 不均匀的现象。 Twitter Snowflake Twitter在2010年6月1日（在Flickr那篇文章发布不到4个月之后），Ryan King 在Twitter的Blog 撰文 写道： Ticket Servers方案缺乏顺序的保证 考虑过采用UUID，不过128-bit太长了 也考虑过采用ZooKeeper的 Seq 所提供的 *Unique Naming* uence Nodes 所提供的 Unique Naming 特性，但是性能不能满足。(个人认为，Sequence Nodes的设计目标是解决分布式锁的问题，但不解决性能要求极高的ID生成问题，直接应用是一种Hack行为) 在这种情况下，Twitter给出了 64-bit 长的 Snowflake ，它的结构是： 1-bit reserved 41-bit timestamp 10-bit machine id 12-bit sequence 在过了不到4年，2014年的5月31日，Twitter 更新了 Snowflake 的 README，其中陈述了两个容易被忽视的事实: \"We have retired the initial release of Snowflake ...\" \"... heavily relies on existing infrastructure at Twitter to run. \" 可以看出，这个方案所支持的最小划分粒度是「毫秒 * 线程」，单线程（Snowflake 里对应的概念是 Worker）的每秒容量是12-bit，也就是接近4096。 翻一下Snowflake的 归档代码 (Scala) ，可以看到： 关于初始化Sequence的处理 if (lastTimestamp == timestamp) { sequence = (sequence + 1) & sequenceMask if (sequence == 0) { timestamp = tilNextMillis(lastTimestamp) } } else { sequence = 0 } 可以看到此处Snowflake对于 sequence``的赋值为 ``0 。 关于每秒超过4096个ID生成请求的处理 protected def tilNextMillis(lastTimestamp: Long): Long = { var timestamp = timeGen() while (timestamp <= lastTimestamp) { timestamp = timeGen() } timestamp } protected def timeGen(): Long = System.currentTimeMillis() noeqd 2011年11月23日，用Go语言实现的，基于Snowflake的 neoqd 出现了。 它的特点是，除了使用Go语言进行了实现，更是把ID生成做成了一个网络服务。支持客户端向ID生成服务申请ID。它还支持： 简单预共享Token的客户端身份证认证（只是加强了那么一点点的安全性，可以忽略） 支持批量获取ID，最多256个（因为使用一个byte表示申请个数） 同时，作者还建议使用 Doozerd 一个用Go语言写的 -- a highly-available, completely consistent store for small amounts of extremely important data. 进行Machine ID的分配。 (关于 ZooKeeper / Etcd / Consul / Doozerd 的比较，也是可以期待下) Boundary Flake 2012年1月， Boundary Flake 同样的，用Erlang语言把Snowflake，变成了一个网络服务，提供128-bit长的ID生成服务。 不过，根据其RoadMap的描述，这个项目并没100%完成。例如，批量的ID生成，HTTP 接口，客户端Library都列在里面待实现。 CruftFlake 2012年7月， CruftFlake 更显然的，是想以一个PHP变种身份出现。 它在结构上与Snowflake基本一致，存在两个区别： 在timestamp上的取值略有区别 可以自行决定是否采用ZooKeeper作为协调器 LableOrg/java-uniqueid 2014年7月18日，LableOrg 写了一个通过ZooKeeper进行协调的，128-bit长的算法 java-uniqueid 。其 结构组成 依然十分相似： Timestamp Sequence counter Generator IDs Cluster IDs 前台浏览器生成 这里的前台，主要是指以「浏览器」为代表的客户端。 2015年2月16日， Sudhanshu Yadav (看面相像印度人)，用Javascript写了Flake的又一个变种实现 FlakeId 。其核心代码是： if (this.lastTime == time) { this.seq++; if (this.seq > 4095) { this.seq = 0; //make system wait till time is been shifted by one milisecond while (Date.now() <= time) {}; } } else { this.seq = 0; } 它的Machine Identifier则是作为构造函数的选项参数 options.mid 传入。 function FlakeId(options) { options = options || {}; this.seq = 0; this.mid = (options.mid || 1) % 1023; this.timeOffset = options.timeOffset || 0; this.lastTime = 0; } 全自主随机生成 可以说，成熟的、全自主生成方案，可能只有 128-bit UUID 一种，具体的说，是UUID Version 4。另外，微软对它实现，称之为 GUID 。 一般的，使用的最多的是UUID Version 4，很大程度上是因为其依赖的其他服务最少。 这里，通过python (2.5+) 对UUID的实现，体验一下UUID的生成效果： $ python Python 2.7.12 (default, Jun 29 2016, 14:05:02) [GCC 4.2.1 Compatible Apple LLVM 7.3.0 (clang-703.0.31)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import uuid >>> uuid.uuid1() UUID('d17c4397-830d-11e6-b62d-985aeb899615') >>> uuid.uuid3(uuid.NAMESPACE_DNS, 'yanjiong.wang') UUID('363053e8-e02d-3b9d-b18b-83da99d5a684') >>> uuid.uuid4() UUID('59cfe861-a6b1-45ff-9522-2e780adf491a') >>> uuid.uuid5(uuid.NAMESPACE_DNS, 'yanjiong.wang') UUID('25d4e194-0404-5c64-8695-c547f98ccde1') 另外，我们看一下网卡的MAC地址 $ ifconfig lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> mtu 16384 options=1203<RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP> inet 127.0.0.1 netmask 0xff000000 inet6 ::1 prefixlen 128 inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1 nd6 options=201<PERFORMNUD,DAD> gif0: flags=8010<POINTOPOINT,MULTICAST> mtu 1280 stf0: flags=0<> mtu 1280 en1: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500 ether 98:5a:eb:89:96:15 inet6 fe80::8d7:fea6:2ec2:ea55%en1 prefixlen 64 secured scopeid 0x4 inet 10.0.3.22 netmask 0xffffff00 broadcast 10.0.3.255 nd6 options=201<PERFORMNUD,DAD> media: autoselect status: active (因为UUID Version 1会泄露网卡的MAC地址，所以我对MAC地址做了下小手术) 可以看到UUID Version 1 最后一组数值 985aeb899615 与网卡的 MAC地址是一样一样的 98:5a:eb:89:96:15 。 个人一直认为，采用UUID Version 4是一种偷懒的，缺乏必要设计的做法。 一方面，它是依据概率确保无碰撞的，计算的过程与概率上的「生日问题」是一样的，不再展开。 另一方面，从使用的角度，UUID还有以下缺点： 太长，即便是转换成36个字符，不利于输入 过于随机，没有规律，在开发调试、线上故障定位，都容易看花眼。 如果作为数据库主键，对索引不利。 小结 人工生成的标识，在相同的命名空间里，需要后续唯一性验证才能保证唯一 由计算机生成，在低并发的场景下，适合通过一个服务集中生成，并保障此服务的高可用性 由计算机生成，在高并发的场景下，适合通过一个保障命名空间独立的命名规范下，由多个服务并行生成。 采用步长和增长相结合的生成算法，本质上都是对某个状态进行累积的结果。 对于取模进行分库分表的场景，初始化值随机有利于均匀分布。 （MongoDB 的 ObjectId 更是Flake系列算法的鼻祖，并在初始值上进行了随机化处理） 设计一个「合适」的标识 区分实体和关系 实体是点，而关系是线。 一般而言，面向实体的标识生成速度，要小于面向关系的生成速度。 具体的例子，以电商为例：买家、卖家、商品这些实体的录入速度，要远比订单生成小的多。也因此，主数据要比交易数据稳定的多。 并且，关系还可能包含层次关系，进而体现为一个依赖树。 面向实体的标识 面向实体的标识，更多的与概念相关（名称）、与形态相关（型号），有很多的人为因素参与，随机因素有限，命名的主体也来自于人。 对于实体制造，为任意一个产品进行标识，大致会分为六个方面：品牌、品类、品名，型号、批号、产品序列号。 对于前四者，更多的是人为的进行命名。 例如，给定中文，找到对应英文，再进行缩写。 对于批号，则会增加一些时间因素，以关联到产品的生产时间。 例如，采用20160925表示具体某一天，或者采用201640表示具体某一周。（一般来说，同一个批号的产品，所使用的原材料是也是同一批。） 对于产品序列号，最简单的是采用自然数法进行编号。 这一类的标识，在分布式系统下，在系统并发量小，集群规模小的情况下，可以采用基于数据库或者协调器的生成方案。 面向关系的标识 自然的，关系源于两个或两个以上的实体之间所进行的某一个活动，并且具有一定的时效性。 常见的关系的表现形式有：交易流水号，会话标识等等。 这一类的标识，在分布式系统下，在系统并发量大，应当采用基于服务的内置生成方案。唯一依赖的是在实例部署时、启动前，为期分配唯一的Machine Identifier。这个Machine Identifier可以交由以强一致性保证的协调器完成。 当然，在系统并发量小的情况下，任然可以采用基于数据库的生成方案，因为没有协调器集群的参与，系统整体的复杂度更低，更利于维护。 标识的容量 任何采用文字所表达的标识，最终在计算机里，都会根据一定的格式，被转换为字节byte进行处理，这个过程称之为「序列化」。 这种序列化方式，本质上是一种编码方式。 变长编码 一般来说，采用变长的编码方式，主要的目的是为了应对不可预期大小的信息量。 常见的有 TLV(Type-Length-Value) 方式。 Google的 Protocol Buffers 非常有意思地采用了 Base 128 Varints 的编码方式。 本质上，一个 URI 也是对一个标识，它可以标识一个功能，也可以标识一个虚拟实体。 RESTful是对此类命名方式的一种实践方式，也是对 URI和HTTP协议组合之后，「表征力」的一个深入挖掘。 定长编码 在回顾一下前文所提到的IPv4地址，它似乎、可能、或许会在2019年 完全枯竭 ， 因为它只有32-bit。相比之下，MAC地址有48-bit，IPv6有128-bit。即便是它们都没那么容易枯竭，但也不代表由于人为因素，导致无法有效使用。 再回想下，每个人的身份证、手机号码，都是采用定长的形式进行编码。 选择定长有利于预先分配计算机资源，不管是内存、文件系统，还是数据库。同时，对于人的心理来说，可预期性大大增强了。 标识的命名空间 命名空间有三个层面： 异构切分：对于不同的场景和视角，以树形进行层次划分。 同构切分：对于异构切分的结果，切分出不同的分片。 时间切分：对于同一个分片，在不同时间点上的状态。 一般地： 首先，采用并行无状态的生成算法，一般都采用时间作为首要的命名空间，并且此命名空间的实效性小于生成者的重启时间 其次，采用生成器实例自身的标识作为次要命名空间，以保证各个生成器的时间即便是不同步也不会产生重复标识 同时，需要注意的是，这可能导致唯一标识产生，大段跳跃，原因有： 单位时间的并发量远小于子命名空间的容量 生成器重启 标识的冗余 不管标识是在运行时的内存出现，还是记录到数据库中或者文件里，它都需要占用硬件资源。 还是拿身份证举例，一方面，一个18个字符长度的身份证，那么需要18个字节进行存储。18个字节意味着144-bit，比IPv6的128bit还长。 如果简单的标识全世界每个人，以目前全地球60亿人口的总量，那么33个bit就足够了。 采用这种冗余设计的原因，一方面是「半集中，半自主」和现实的行政、地域结构对齐，另一方面是实现关联信息的集成。 小结 标识编码后的长度，则决定了一个标识方案的整体容量。 在一个统一的命名空间内，有多个标识生成者并行生成时，需要划分独立的子命名空间，以保证生成的标识在整个命名空间内唯一。 单个命名空间的标识，承载的信息量有限，在标识的使用过程中，需要扩展与包含一些其他视角的信息以进行冗余。 标识的文本兼容 和人工取名字不一样，自动生成ID的主体，是计算机本身，但使用这个ID的主体，有两个：人和计算机。 对于计算机，最擅长处理的是结构化数组、条形码或者二维码；而对人，最擅长使用的是文本、图形或者视频。 一般而言，在大量的RESTful设计的应用，其URI中会包含大量的ID，用来标识用户、商品、订单等等，它们经常会出现在URI中。 以ASCII编码为基础的各种文本化编码算法，从Base16开始，正常的有Base32，Base64，Base58，Base85等等，不太正常的，在本文最后的扩展阅读里有列举。 其中，Base16是最为「字节友好」的，因为不需要进行任何Padding操作，就可以以把 4-bit/half-byte 转换为 [0-9a-f] 这十六个字符，因此Base16还有别名：Hex。另外对于键盘输入，这16个英文字母，又是相对纯数字之外，最方便的。 而Base32, Base64等等，都需要Padding。因为Base32是每 5-bit 进行分组编码，Base64则是 6-bit ，都无法直接对齐一个 byte(8-bit)。 另外，Base16还对 URI 友好，不需要进行任何的 URLEncode/Decode操作。 以64-bit长的ID为例，它既可以转化为 long ，也可以Base16成为16个字符的``HexString``，同时它大小写不敏感。 相比之下，如果采用Base64的文本化方案，其长度虽然少了5个字符，为11个，但其大小写敏感，不利于人机交互的输入，还会包含URI不友好，还会被转义为「 %3D 」的符号「 = 」。 一个精巧的标识文本化算法，并不应该简单的把一个二进制值转为HexString。在日志里，应该有相应的解码算法，解析出符合人类阅读的字符，比如：精确到秒、且带格式时间，生成改标识的主体，等等。 标识的安全性 标识的信息泄露 采用连续，或者固定步长的标识，容易从一个标识猜测其他标识的存在性。 常见的例子有： * 通过局域网扫描工具，扫描某个子网的活动的IP地址 * 通过端口扫描工具，扫描一个目标主机开放的端口，以初步确定主机操作系统类型 另外，在物联网领域，如果采用的EPC编码，那么很容易通过连续编码，估计某个产品的具体产量。 标识的自校验能力 还是使用身份证号这个例子，根据国家标准（GB11643-1999），身份证号的前17位为本体码，最后1位为校验码。也就是说，它是通过前17位进行数学公式计算之后获得，主要目的是用于检验录入过程是否产生差错。 这样设计的好处是，每当输入完18位身份证号后，可以直接判断一个身份证号，是否在逻辑上是「合规的」，对于系统而言不用查询数据库，可以减少IO操作。不过，这不代表这个身份证号是有效的，也有可能是一个无效，但符合校验规则的身份证号。 由于标识的长度有限，能够加入的冗余信息较少，一般的基于公钥密码体制的签名机制，都难以在一个短标识中嵌入。 扩展阅读 Distributed System Building Block: Flake Ids Roughly sorting: Sequential and parallel approach , 1989 Base1 HexagramEncode (六十四卦编码) BrailleEncode (盲文编码) 更新历史 2016-11-02 13:34, 更新基于协调器生成的内容","tags":"ideas","url":"/articles/id-and-unique-id-overview","loc":"/articles/id-and-unique-id-overview"},{"title":"架构是一种解决问题的能力","text":"计算机是个复杂的机器，相比普通的机器（比如小家电、汽车），它可以在使用过程中对其「工作行为」进行「再定义和场景适配」，以解决不同场景下的人的需求和问题，这种「定义的结果」，对于机器的最终用户来说，是「应用 / Application」。 对于非计算机相关的普通人而言，即便是有诸多对于职位头衔的描述：「程序员」、「软件工程师」、「架构师」、「首席技术官」，也离不开一个潜意识的印象：「做网站的」或者是「修电脑的」。 很多「架构师」，都是从「软件工程师」开始，不知不觉的变成了一个「架构师」。对于我个人而言，当我还是一个实习生，被「升」为一个部门架构师带领一些正式员工干活的时候，对「架构师」这个概念居然是一片空白，甚至于不知道这是个「好消息」，还是个「坏消息」，当然也不知道「架构师」是干嘛的。 所以，我一直以 最简单的方式 对架构进行定义：** 架构是一种用计算机解决问题的综合能力，与头衔无关** 架构源于对实践的总结 架构能力并不是与生俱来的，而是和具体经历强相关的，丰富的经验是形成架构能力的基础。 很多时候我们强调「系统性思考」对于架构设计的重要性，希望从方法论上能够对正在从事或者即将从事架构工作的程序员在专业能力上进行提升。教条式、填鸭式的培训，是教不出架构能力的。理论的价值是能够帮助应用理论的人少走一部分的弯路，但不能够解决眼前的现实问题。 在企业里，架构是一个实践结合非常紧密的领域，一切以解决实际问题为目标。由于问题是多种多样的，导致解决的方法也是多种多样的。踩过的雷，填过的坑，都需要进行总结和抽象，才能提升到架构层的高度，防止重蹈覆辙。 架构是一个建模的过程 对于一个复杂问题，通常会对复杂问题按照能力领域进行分解，其目的是能够找到与现有能力相匹配的映射。这个映射，就是解决方案。它，不开人的「知识型劳动」，主要分解为三个方面： 对于已知问题的抽象和建模 对于已知能力的抽象和建模 对于解决方案和工具的设计 其中前两个方面，都提到了「建模」。建模本身是对客观事物的一种抽象，客观事物越复杂，那建模的结果变成「盲人摸象」的概率就越高。 然而，「盲人摸象」在IT领域其实不能算是个「贬义词」，因为这个现象十分的常见。究其原因，解决实际问题信息系统，更多程度是面向于「典型」应用场景，而不是「任意」应用场景的。 场景即是对客观事物的认知视角，信息系统做不到、也不需要对一个完整的客观事物进行全面（360°无死角）建模。 举个具体的例子：对于人这个客观事物，银行系统里，可能会关心这个人财务指标，例如「收入」、「支出」和「存款余额」，但在医院的重症监护病房里，可能就会关心这个人的生命指标，例如「血压」、「心跳」。 从例子里可以看出，一个面向具体问题的场景化应用系统，都是对一个客体进行「片面的」场景化建模。 说到底，建模是一种抽象能力，具体的说，是人对客观事物认知结果的理性提炼和总结，不可否认感性的部分太难以刻画和描述。很符合「庄子·天道」中所述：「意之所随者，不可以言传也」。 如果要拿数学语言进行描述「建模的能力」，就是找到一组尽可能少的「特征向量」去表述这个空间，而找这组「特征向量」的能力，就是建模的能力。 架构工作的核心是设计 没有软件的计算机，是「无法使用」的，因为没有办法帮助我们解决任何问题。计算机原本很「生硬」，无法很「柔软」的去直接适配所需要解决的问题。 架构的核心工作是「设计」，设计计算机如何按照预期进行工作。 架构设计中，建模的结果，是模型，它有着结构化、棱角分明的特质，因为这是计算机进行计算的最高效的方式：严格的告诉我们——两个数是相等还是不相等，及其衍生。正由于严格匹配，所以在很长的一段时间里，解决方案的制定和后续系统的交付运行，都围绕着如何严格按照实际场景进行模拟和落地。 很少以「按概率成功」对系统的业务功能进行设计和实现，一切都必须「绝对正确」。因为绝大部分的计算机系统，无法理解自然语意。只能根据人为设计的结构化信息，「按部就班」地完成重复性劳动。 人工智能、机器学习，在解决自动化建模领域的成熟度还是远远达不到人的能力，如果达到了，那么软件就不需要人进行「架构设计」了。简单的从架构设计的结果（当然也是结构化的），生成代码，这方面目前的计算机还是有能力胜任的。 任何不符合实际场景的计算结果，用户都认为是「缺陷 」，而在系统中产生此类异常结果，往往需要「程序员」为此承担相应的责任。呐，回想一下，在没计算机的时代，反而往往都是店小二算错了帐自己赔，没有人会去责怪算盘。这是为什么，因为算盘足够简单，简单到不需要做任何的监控系统、不需要记录任何的日志，连「三下五除二」这样的操作规则，都已经被社会化学习消除了使用成本。最终，一切出错的原因只有一个：用键盘的人。 是的，计算机系统生来就是是不可靠的，它不可能像「算盘」一样在运行期不依赖任何的自然资源。断电了，会引发故障；光纤断了，会引发故障；磁盘满了，会引发故障。。。一系列的不确定因素，导致「分布式系统」架构设计比「主机系统」的架构设计复杂的多，原本不需要操心的事情，都需要从更上层的软件层加以解决了。 所以，当前架构工作的很大一块，都随着分布式系统规模的增大而加大了比重。也许，导致世界上最聪明的一伙人都去解决计算机的问题了。 架构需要作出一系列非技术选择 架构既然是个解决方案，自然有很多可以自由选择的领域，有很多的受限的前提条件。这些外围因素，往往还系统背后的个人、团队、企业的价值观、以及非IT能力有关，这是一个很容易被忽视的点。 与人和团队的关系 架构往往是与个人或者团队的能力有关的，因为架构前一部分是设计工作，后一部分是代码框架的落地工作。可以没有一个十全十美、满足各方需求的方案，架构过程中有很多都是妥协的结果，有的是向需求妥协，有的是向运维妥协，有的是向个人英雄主义妥协。另外，绝大部分的选择都是人作出的，这导致了和人、团队的水平形成了很大的耦合关系。 早在1895年，法国心理学家 勒庞 在他的心理学名著「 乌合之众（The Crowd） 」就早已经说过： 一群精英所作出的群体决定，很有可能是最愚蠢的决定 。有时候，技术团队不能太强调民主；有时候，技术团队中的强强产生的效果是「1 + 1 < 1」。一个良好的、强弱结合的组织结构，才有可能孵化出优秀的工具，再进阶为一个优秀的产品，也有利于成员梯队的培养。 团队越大，一个优秀的架构设计方案被严格执行下去的可能性越小。第一，制定方案的人和落地方案的人大多数情况下都有脱节，很多设计精巧的方案细节到了执行者的手里，会被忽视。第二，为了统一一个团队的认识结构、设计理念，这部分的培训成本往往都是各个雇主不愿意付出的。第三，方案的描述本省是「不精确」的，还很容易存在文档过期的情况，在软件及交付的各个环节，任何参与者都有机会以自己的知识背景作为出发点进行理解，并自豪地加上自己的「杰作」。 与企业的价值观相关 企业的价值观，最直接的体现，就是企业的投资组合。 在大型的企业里，软件产品的采购往往会受制于「采购部」，也会受制于不懂IT的公司级领导所下达的行政干预，有些理由好像听上去也「很有道理」：采购过为什么还要采购，要「保护投资」。往往到了这个层面，程序员、架构师都纷纷表达了无奈。 软件，包含代码和数据。它不是一个简单的能够按照「固定资产折旧」进行的固定资产。它透射的是使用者对客观世界的认识，也需要随着对客观世界认知的变化而变化，因此版本对于软件来说就是一个时刻认知的快照沉淀。 行业的快速发展，企业的快速发展，势必推动企业信息系统的快速发展。对于企业而言，其价值是能够找到感知行业、感知产品、感知用户、感知企业内部运营的触角，每个社会中的实体不管是个人，还是产品都能够在系统中找到它的影子。 对企业主而言，IT是一个长期的投资行为。陈旧的、不符合时代背景的软件，是会变成降低企业生产力的绊脚石。 代码是架构设计的落地实现 现今任何的计算机高级编程语言，例如Java/C/C++，或者更高层的DSL，都是人与计算机之间的「单向语言」。这些「单向语言」，并非自然语言，大多数由程序员编写，再交由计算机进行执行，在很长的一段时间内，信息系统都是以这种方式与人进行交互。 （当然，也可以慢慢的等待「Siri」之类的助手长大成人，成为一名架构师，也许那个时候，广大架构师需要转行了。） 代码是架构实现的核心，通过代码可以完成对现实世界的「虚拟化」： 概念的虚拟化 能力的虚拟化 实体的虚拟化 记忆的虚拟化 协作的虚拟化 通过一些例子，有助于理解： 概念的虚拟化：一个业务概念的类定义 能力的虚拟化：一个方法对多个输入数据进行加工并返回结果 实体的虚拟化：一个类的实例，即具体的数据 记忆的虚拟化：一条关系型数据库的行记录 协作的虚拟化：远程方法调用 是的，代码是计算机的指挥者，代码是把人类智慧「赋能」给计算机的一种语言。 代码到不到位，写的好不好，对设计的落地实现会产生很大的影响。 其实，架构是一种用计算机解决问题的综合能力 很多时候我们看到的「系统架构图」，其实是针对目标问题所设计的「计算机领域的解决方案」，是一种设计图纸。 可以说，「架构工作」不仅要能够交付「设计图纸」，还要能够「建地基、搭房梁」。 宏观层面：对特定问题，进行解决方案的设计 微观层面：对后续的编码工作，形成与解决方案核心相一致的代码框架 做好「架构工作」有很多非技术的「软实力」，比如： 对于团队中成员职能的正确定位，知道他们真正擅长什么 深挖至本质的问题分析 多视角、符合人性的换位思考 舍弃一些力所能及，但影响专注的「杂事」，合理的说「不」 具备一定的投资意识，从更高、更长远的视角，看待投入与产出 发散性思考 在互联网公司出现之前，有没有「互联网公司」呢？他们和现如今的互联网公司的差别是什么？ 其实是有的，例如「电网」、「电信运营商」、「股份制商业银行」、「快递物流公司」。在人类社会中最基本的两个元素，就是「实体」和「连接」，一切和连接有关的行业，都可以认为是「互联」，只不过信息系统在企业中的价值是由「生产关系」决定了其价值。 机器学习能够帮助架构设计吗？ 机器学习很长一段时间之内都停留在参数调优上，而不具备对于一般事物进行建模的能力。前文也阐述过「概念的虚拟化」和「实体虚拟化」之间的关系，实体虚拟化就是数据，而数据本身已经是类的实例了， 互联网公司大谈「大数据」以及「数据驱动DT」的原因是什么？ 前面提到，数据是对客观实体的虚拟化，客观实体并不是无中生有的，他们是自然世界的产物，数据驱动的本质是客观事物驱动，退一步讲，本质仍然是「业务驱动」。当然，打通多个场景化的数据，对客体进行360°的建模，是「大数据」真正价值所在。 需要注意的是，剑总是双刃的，当在计算机系统这个虚拟世界里，找到了360°、包含衣食住行的你，生活是便利了，因为可以预测你的需求，不过你的隐私还存在多少？ 对开源软件实施「拿来主义」是否可行？ 很多开源软件，直接的「拿来主义」，会导致「后患无穷」。很大程度上，开源代码是一个个人、一个团队整体能力的映射，并且和运行这些代码所需要的环境息息相关。开源代码也是挑人、挑环境的，在一个团队没有想匹配的能力进行正确的使用之前，很多时候都是一匹「天生野马」，在驯服之后才会变成自己的「血汗宝马」，驯服的过程其实就是和自己团队以及周边环境相适配、磨合的过程。 重复造轮子真的是浪费吗？ 一个健康的IT团队，应当建立起一套评估「现有轮子」是否产生实际效益的体系，比如能够监控代码在生产环境的实际使用率、故障率，适时的下线一些「低效益」的代码。不要简单的否定和阻止「重新造轮子」，这是与企业内部人的能力对齐、外部大环境对齐的过程，更是企业不断新陈代谢的「投资型基因」。 结构化的数据到底意味着什么？ 所谓结构化，其实是面向数据的下游处理者，可以与其内置的概念（数据模型）进行映射和处理。结构是一种「元信息」。 举个具体的例子，一张bitmap图片，它本身是有结构的。bitmap的图片是标明了每个像素点上的RGB颜色值具体是多少，这个数据结构，对于图片浏览器来说，是可以识别和解析成为一张人眼能够识别的图片的，而浏览器本身只负责每个像素点上的颜色还原。倘若这张图片里是一张「用户」写实头像，那么图片浏览器并不能够分析出这张头像具体是哪个自然人，也无法将这张图片作为一个API的入参，联合其他该用户的入参，进行内部业务逻辑的处理。","tags":"ideas","url":"/articles/arch-is-to-solve-the-problem","loc":"/articles/arch-is-to-solve-the-problem"},{"title":"API不适合做微服务数据同步","text":"API SPI 的调用，有很大的一部分比例，都是为了做数据同步。 API / Application Programming Interface（应用程序接口） SPI / Service Provider Interface (服务提供者接口) 软件要解决的是两部分的事情： 信息的共享 信息的加工 信息的加工时会对信息产生「增值的效果」，最终导致信息在形态上发生「形变」。 API和SPI的设计，如果没有进行任何加工（就是进行了业务逻辑，导致信息在结构上发生改变，变成另外一类的信息），那么之类的数据本质上是应该进行同步的操作。 导致不对数据进行直接同步的原因，有这些： 信息的一侧没有持久化能力 比如，浏览器侧是不提供持久化的能力的，那么就需要另外一方（有持久化能力的）提供API（一般也就是服务端），方便浏览器实时获取信息。 避免出现多份数据的一致性问题 一个数据实体，映射的是一个物理上的实体，物理实体的复制是困难的，但相比之下，数据实体的映射是简单的，特别特别简单的。这也导致了，数据在经过多个处理环节的时候，每个环节都可以对其进行持久化（这里不考虑安全性的问题）。","tags":"ideas","url":"/articles/api-is-not-suitable-for-microservice-data-sync","loc":"/articles/api-is-not-suitable-for-microservice-data-sync"},{"title":"平台运营的关键","text":"平台要服务于内容 「平台」，在感官视觉上是一个「平的台子」，发音也有一部分也来自于英语的「Platform」，不管怎样，时下的平台自身应当包含两个基本能力： 承载内容 平台上承载内容的多样性和时效性，是平台生命力的核心指标。 关联内容 事物是普遍联系的，不同种类的内容之间，会存在潜在的联系。 以内容为核心的多边关系平台 一个健康的平台，应该是三边或者多边的，会包含： 平台运营方 内容供给方 内容需求方 更多的，还会出现第四方，比如： 平台监管方 正因为平台是服务于内容的、平台是由多边参与的，平台能够体现两个维度的关系： 横向上，平台体现的是供给和需求的关系 纵向上，平台体现的是运营和监管的关系 所以，平台本质上应当是多边市场化的。在横向上，供给与需求的在数量上的平衡，是决定某个内容市场能否持续繁荣的决定性因素。 市场犹如天平，架起的是某个内容的「供给」和「需求」两端。 平台运营的核心理念 平台运营首先需要帮助每个用户弥补短板，鼓励每个平台的参与者向平台贡献内容并得到广泛的认可、体现他们的价值，从而重点激发平台上的每个用户的自身潜力，同时也需要严格监管平台上的不良用户，保障一个健康、有序的生态环境。 弥补短板 现如今，任何单个个体的能力是渺小的，向市场上不断提供内容，仅凭一己之力，难以、或者需要耗费大量时间来提供一个完整的内容，慢节奏的内容推陈出新是无法满足这个时代挑剔的眼光，更难以激起波澜，甚至是难以获得注意。 平台运营方，自身要懂得某个领域内容的特点，帮助小微个体使用平台上的综合能力，使其提供完整的内容。 内容价值的多视角 需求方视角 内容需求方，更多的关心市场中的内容与自身状态的匹配程度，合适自身特点的内容，才是主观意识上的「好」。 对于确切的受体A与受体B，两者各自对于「好」的定义是不一致的。 平台需要能够为不同的需求方，尽可能的提供相匹配的内容，减少选择难度。 运营方视角 运营方首先要保障的是其平台运营的市场的公平性，消除由于平台自身能力不足导致不良用户破坏平台生态的行为。 供给方视角 供给方所关心的除了下游目标市场之外，还需要关注上游内容原料或者资源市场的动态，这也对平台运营方提出了需求——能否打通多个市场，为供给方提供一个多入单出，或者多入多出的市场风向标。 监管方视角 监管方更多的是从规范、法律层面，对其他三方的行为进行监管，在必要的情况下动用行政手段进行强制干预。","tags":"ideas","url":"/articles/key-of-platform-operation","loc":"/articles/key-of-platform-operation"},{"title":"DevOps对于企业IT的价值","text":"DevOps 概念的发展历史 现在是2016年5月下旬， DevOps 作为一个IT圈的热词，几乎已经是无人不知，无人不晓。 如果你是一个有心人的话，可能会好奇DevOps这个概念到底是在什么情况下诞生的。 在 Wikipedia: Devops 的词条里，可以发现 DevOps 相关概念已经早在2008年就被提出了。 At the Agile 2008 conference, Andrew Clay Shafer and Patrick Debois discussed \"Agile Infrastructure\". The term \"DevOps\" was popularized through a series of devopsdays starting in 2009 in Belgium. Since then, there have been devopsdays conferences held in many countries worldwide. 即便是在2006年Amazon发布了ECS, 微软在2008年和2010年提出和发布了Azure， DevOps 的重要性似乎没那么强烈。 可是在8年前的那个时候，为什么 DevOps 没有迅速走红呢，第一个很重要的原因是因为那时候 云计算 （ Wikipeida: Cloud computing ） 还是小众产品，更多的与虚拟化相关。 第二个很重要的原因是 Docker 还没有横空出世，直到2013年7月。第三个很重要的原因是，Martin Fowler 在2014年3月提出了 Microservices 。 可以看出，当前 DevOps 概念的深入人心，离不开云计算、容器/Docker、微服务、敏捷等相关概念和实施的成熟发展。 企业IT对于企业的价值 谈到企业IT，就没有办法回避两种迥然不同的企业，一种是以传统制造业或者服务业为基础的，对生产资料进行加工的「传统企业」； 另一种是以「信息互联」为基础的，对「人与人关系、人与物关系、物与物关系」进行信息加工的「互联网企业」。 这两类，是两类极端的企业，一类企业的日常运行，可以没有信息系统；另一类企业，完全离不开信息系统。 一般的信息系统，对于企业的价值，主要有三类渐进过度的典型类型。 第一类，是将信息系统定位于「辅助和支撑」企业的产品制造以及企业运营部门，因为这类企业的生产资料系、生产力、生产关系，都以实体制造为主，不以信息加工和处理作为企业产品核心。 第二类，是将信息系统作为数据加工、传输作为主体，但业务模式来自于传统行业，信息系统主要完成已有业务规则的虚拟化，例如金融、电信行业。这类企业的信息或者数据，主要来自于业务受理，或者说数据的生产者和使用者是企业自身。 第三类，是将信息系统作为企业唯一生产工具，并将企业的客户（个人或企业）所自发贡献的信息、数据，作为生产资料，形成新兴的业务模式。这里企业的典型，就是互联网企业。 随着又一轮「数字化」的概念席卷全球，非互联网企业所面临的更多针对用户和客户的思考和探索，都需要有更快交付能力的信息系统进行支撑，这也是传统企业互联网化，打开企业边界围栏迈出的第一步。 DevOps 对于企业IT的价值 通过前文的分析，可以看到，企业IT对于三类不一样的企业价值体现各有不同。 对于互联网企业，信息系统是企业产品的命脉，企业对于软件的价值观以及投资组合，对于其他两类企业要高出很多。 DevOps 的核心价值，是能够帮助企业快速交付变更，以便于快速响应企业对于市场的变化、用户的需求。 代码 构建 测试 打包 发布 配置 监控 以上7个过程，是 DevOps 站在软件生命周期平台化运营的视角，为企业IT所建立的一个「IT for IT / IT4IT 」的业务平台。 如果说，软件开发、交付、运维是一个传统行业，那么 DevOps 就是映射了这个传统行业的一个软件平台。 通过 DevOps 可以助理企业软件交付的效率提升，帮助企业IT实现数字化运营。 可以用一句话定位以下三者在价值链上的关系 「信息」（数据） 「信息系统」（处理数据的工具） 「DevOps」（制造与维护处理数据的工具的工具） 在「信息」（数据）成为企业「生产资料」一部分的条件下，信息系统快速演进的业务驱动力、DevOps的价值，才能够清晰的得到体现。 企业IT系统的从「业务支撑型」走向「业务驱动型」的转折点，是由企业产品的最终用户，直接以低成本为企业提供生产资料——信息（数据）——并使之成为企业产品的一部分 。 如果信息是企业产品的全部，那么这种类型的企业就是第三类——互联网企业。 DevOps 在企业中的实践 和众多源于互联网的理念一样，在 DevOps 的概念被炒热之前，众多互联网公司其实已经实践了 DevOps 。 其中的原因也正是因为信息系统，是这些公司的生产工具，没有人比互联网公司的人更明白提高自身的办公效率，提高团队、企业的生产力，就是为提高企业产品的生产力进行有效的保障。 除了前文提的 DevOps 覆盖企业软件生命周期中的7个过程， DevOps 在企业落地过程中，传统企业或多或少都已经建设了一部分配套系统，尤其是AAAA与监控系统，其他的代码管理、持续集成工具也或多或少的有所积累。 DevOps 更多的是把IT服务产品化的平台，企业中的任何一个IT能力，都应当能够在 DevOps 中面向其用户提供自服务的的能力。 例如，系统的开发者，能够自主的在 DevOps 上联机分析生产环境的日志，而不必经过层层壁垒，一台台登录生产环境的主机，检索日志。 再例如，项目组的快速变更、员工的快速入、离职，都应当能够在 DevOps 中实现自动化的账号开通和注销。 需要注意的是，相比传统企业尤其是制造业的产品制造工艺和制造流程，软件产品的制造，IT服务的交付，更多的是交付一些无形的软件产品和知识工作。 正因为这些无形产品受制于不同的人认知所产生的多变，其管理复杂度远比制造业来的复杂，企业软件的设计、开发、发布、上线，缺乏标准化的管理过程。 对于如今的非互联网企业而言，能够快速见效的 DevOps 时间，应当从（环境）配置的管理，以及自动化部署。 在实施难度上，配置的管理要低于自动化部署。因为非互联网企业的技术路线由于供应商的竞争（甚至是恶意竞争），变得极其多样，架构离散化程度也很高。 对比互联网企业，（环境）配置管理和自动化部署，由于IT技术从硬件到虚拟化/容器的自主可控，企业整体技术架构的收敛性就比较理想。 当前 DevOps 对于企业架构支撑的不足 从 代码 到 监控 , 可以看出 DevOps 对于企业尚有以下不足（或者说 DevOps 本来就不考虑这些）: 缺少对企业IT战略规划、企业IT业务架构规划、企业IT系统架构设计、企业IT系统需求管理以及IT项目管理进行有效的平台化、数字化支撑。 缺少对企业IT部门、信息系统运营效能的系统性评估和优化模型 缺少对企业不同IT系统供应商的技术架构、IT产品的标准化、基线化管理。 缺少对企业数据类应用的支撑，更偏于交易型应用的交付。 对于第 1,2 两点 任何企业都有这方面的需求，但由于企业在投资组合上对这个领域投资较少，投资规模较大、实施难度较大，企业主更愿意进行面向企业产品「开源」投资。 对于第 3 点，几乎不会在秉承「自主建设」互联网公司存在，但在其他企业中也逐步会通过精益运营的方式进行落地实施。 参考资料 Wikipedia: Devops : https://en.wikipedia.org/wiki/DevOps Wikipeida: Cloud Computing : https://en.wikipedia.org/wiki/Cloud_computing Microservices : http://martinfowler.com/articles/microservices.html IT4IT : http://www.opengroup.org/IT4IT 修订历史 2016-06-01 09:51 补充价值链上的关系","tags":"ideas","url":"/articles/devops-value-towards-enterprise-it","loc":"/articles/devops-value-towards-enterprise-it"},{"title":"数字化的本质和基础","text":"数字化的概念 「企业数字化」是目前媒体、市场上的热点关键词。 很多人都会困惑「数字化」、「信息化」、「自动化」、「标准化」这些概念的相互关系，好像时间又进行了一次轮回。 「数字化」给人直观的感受是与「智能设备」、「物联网」、「移动互联」、「云计算」、「大数据」等等等等，这些强IT概念联系紧密。 企业似乎只要把它们捏在一起，好像就实现了时髦的数字化转型，公司就可以和互联网、物联网联系在一起。 在这里，也许没有办法给出直接的「数字化定义」，个人对于数字化的观点，是把「数字化」理解成一种现象，一种市场语言。 数字化的本质 透过现实看本质，「数字化」战略的表象，其背后实质性的动作是「连接」。 连接产生交换 交换产生交易 交易产生市场 比较实体与虚拟连接 早在大秦帝国，秦始皇做的最了不起的事情是「书同文、车同轨、统一度量衡」。 这几件事情，是在整个国家之内统一了标准，降低了社会的沟通成本、协作成本，促进了社会的发展效率。 实体世界的连接 现实世界的实体连接，已经通过长时间的工业化得到了沉淀，比如把插头插到插座就可以使用电能。 工业标准定义了插头与插座的形状、交流电压的高低和频率。 即便是世界上没有完全统一，依然存在中国标准、美国标准、英国标准等等标准，市场上也提供了各种各样的转换适配器。 软件世界的连接 为了便于理解，对 交流电 这个概念进行展开。如果用 java 来描述一个 交流电 的最基本属性， 比如电的 伏特 ，以及 频率 ，那么两个不同的程序员，会产生两种不同的描述。 概念的代码实现 比如下面这两个代码对 交流电 实现： 我的实现 package wang.yanjiong.electronic ; import wang.yanjiong.electronic.Volt ; import wang.yanjiong.electronic.Frequency ; public interface AlternatingCurrent { Volt getVolt (); Frequency getFrequency () .... } 其他人的实现 package other.people.electronic ; public interface AC { int getVolt (); int getFrequency () .... } 可以看到两者都通过代码描述了 交流电 这个概念，但在IT这个虚拟世界内，是截然不同的两个概念代码实现。 在第一种 wang.yanjiong.electronic 这种实现方法，是对电压 ( Volt ) 和 电流 ( Frequency ) 进行了更为复杂的定义。 连接的代码实现 任何一个连接，都会有两方或者三方以上的出现。在两方的情况下，一般有： 提供方 使用方 在三方的情况下，一般有： 提供方 使用方 监管方 为例了便于表述，以两方为例： 提供方用 java 代码声明了一个接口 (API, Applicaion Programming Interface)， 便于使用方获得全世界的各种 交流电 信息： package wang.yanjiong.connect ; import wang.yanjiong.electronic.AlternatingCurrent ; public interface ProviderAPI { AlternatingCurrent [] getAlternatingCurrents (); .... } 使用方同样用 java 完成了使用代码的编写： package other.people.electronic ; public class ConsumerService { AC [] acs = ProviderAPI . getAlternatingCurrents (); .... } 很显然，使用方的代码，在编译的过程中就会出现错误，因为使用方没有 引用 提供方关于 ProviderAPI 的相关定义。 通过对这个例子的分析，提供方和使用方不在同一个虚拟世界里，两者无法进行「连接」。 进一步的，假设提供方与使用方分属于两个不同的企业，部署于两个完全物理隔离的机房，那这两者要进行一次有效的「连接」是完全不可能实现的。 数字化的基础 分领域统一标准 标准制定 通过上述两个例子的对比，在软件层面实现数字化，第一要务是实现统一「标准」。在前文的例子里，对于 电流 的描述，就应该首先被统一。 「标准」根据个人的实践和理解，包含两个要素： 概念 对于一个现象，给定一个便于理解的名称。 关系 不同概念之间的关联关系。 需要注意的是，概念来自于人的认知，而人的认知又受制于人的知识、人的经历。 标准的建立，应该是根据的目标适用领域以及对外影响范围进行。 领域划分 越是抽象的概念、越是抽象的标准，包容的万物越多，难度也越大。 某种意义下，领域的划分，也是因为一种抽象无法覆盖多个领域。现实的例子，就是社会的行业划分。 对于企业而言，标准的统一是一件相当困难的事，因为短期内效益没有体现，并且使用标准规范企业内部和外部的行为，需要有执行力的保障。 重要性评价 标准的重要性和影响面，可以通过对标准的引用次数来确定。这种模型类似于 Page Rank 。 标准的引用包含两个方面： 领域内部 领域外部 适应变化的机制 变化，来自于人的认知，来自于社会的进步，来自于科技进步对人类产生的影响，来自于对本质的深入理解，来自于方方面面。 企业信息系统，是一个高精度匹配的机器，任何一行关键代码的变更，都可能会导致整个系统无法正常工作。 一旦标准中的概念或者关系发生变化，需要有快速发现影响范围，并迅速制定有效的应对方案。 企业建立一套适应变化的机制，应当包含以下要素： 概念的文字性描述 概念的多语言代码的生成和快速引用 概念代码对应在不同视角、不同领域之间的转换和适配 变化的影响面分析 适应性变更的快速交付 MOF与MTL 概念模型 模型是表述一个领域内部概念之间关系的方法。 概念模型是在一个系统交付过程中，设计的核心之一。 根据 MOF (Meta-Object Facility) 的概念以及 ISO/IEC 19508:2014 的 Object Management Group Meta Object Facility (MOF) Core 国际标准，一个「概念」在信息系统落地的过程，可以包含层结构： 实例 -- 一个概念（在计算机系统中）的具体实例化对象 模型 -- 描述一个概念的结构的定义，类似于上文的 AlternatingCurrent 这个 Java class 元模型 -- 描述模型的模型，例如 UML 元元模型 -- 描述模型的模型的模型，例如 MOF 模型转换 正因为概念是标准的一部分、模型是描述概念的方法，所以模型的转换会同时发生在宏观和微观两个层面： 在宏观层面：当一个模型从一个领域走进另外一个领域 在微观层面：当一个模型从领域中的一个视角转换为另外一个视角 描述模型转换这件事，有专门的语言: MTL ( Model transformation language )。 ATLAS Transformation Language 是 MTL 的一个实现。 扩展阅读 Page Rank : https://en.wikipedia.org/wiki/PageRank MOF : https://en.wikipedia.org/wiki/Meta-Object_Facility MOF 2.5 : http://www.omg.org/spec/MOF/2.5/ ISO/IEC 19508:2014 : http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=61844 UML : https://en.wikipedia.org/wiki/Unified_Modeling_Language Model transformation language : https://en.wikipedia.org/wiki/Model_transformation_language ATLAS Transformation Language : https://en.wikipedia.org/wiki/ATLAS_Transformation_Language","tags":"ideas","url":"/articles/digitization-essence-and-foundation","loc":"/articles/digitization-essence-and-foundation"},{"title":"唯一性标识的生成策略","text":"「主数据」类型的生成策略 主数据是一类和客观对象产生较为紧密映射关系的数据。例如:「客户」，「产品」等等。 这一类的数据会随着时间不但进行完善和修正，整体的数据生命周期较长。 使用ID来表述这一类数据的主要侧重点有: 隐私保护 - 权重5 整体可用容量 - 权重5 单位时间可用量 - 权重2 首次生成简便性 - 权重2 后期录入简便性 - 权重4 后期迁移简便性 - 权重4 人工阅读可预判性 - 权重5 分库分表可路由性 - 权重5 其中，人工阅读可预判性包含 包含分类特征 使用定长编码 例如, 身份证号「310109190001011235」,18个数字字母字符（18字节=144bit）, 最后一位为校验位 前6位为地域分类，7至14位为生日。 「交易数据」类型的生成策略 交易数据是一类和某个活动或者行为对象相关的数据。例如「订单」，「消息」。 这一类的数据会随着时间不但进行完善和修正，整体的数据生命周期较长。 使用ID来表述这一类数据的主要侧重点有: 隐私保护 - 权重4 整体可用容量 - 权重5 单位时间可用量 - 权重5 首次生成简便性 - 权重4 后期录入简便性 - 权重3 后期迁移简便性 - 权重2 人工阅读可预判性 - 权重2 分库分表可路由性 - 权重5 其中，人工阅读可预判性包含 包含时间特征 包含源与目标特征 例如, 淘宝订单号「1799508888858080」,16个数字（16字节=128bit）, 后四位数字为分库分表策略, 前12位与时间相关。","tags":"ideas","url":"/articles/UniqueIDGenerateStrategy","loc":"/articles/UniqueIDGenerateStrategy"},{"title":"IETF HTTP 规范概览","text":"基于HTTP的RESTFul风格，是对HTTP协议的一次功能挖掘。 Infomation类 Infomation (include all kinds of information about the Internet including historical data, tutorials, etc. A standards group or individual outside the IESG produces these informational RFCs.) 一定程度上是一类「还债」类的 RFC RFC-1945 Hypertext Transfer Protocol—HTTP/1.0, May 1996 Obsoletes类 Obsoletes 是一类被新的 RFC 替换了的 RFC ， 被替换不代表已经根据这些 RFC 所实现的软件按照新的 RFC 都进行了更新升级。 RFC-2068 : Hypertext Transfer Protocol -- HTTP/1.1, January 1997 RFC-2616 : Hypertext Transfer Protocol -- HTTP/1.1, June 1999 Standards Track类 Standards Track (expected to become Internet standards ) 是一类被期待成为互联网标准的 RFC RFC-6265 HTTP State Management Mechanism, April 2011 RFC-6797 HTTP Strict Transport Security (HSTS), November 2012 RFC-7230 HTTP/1.1 : Message Syntax and Routing, June 2014 RFC-7231 HTTP/1.1 : Semantics and Content, June 2014 RFC-7232 HTTP/1.1 : Conditional Requests, June 2014 RFC-7233 HTTP/1.1 : Range Requests, June 2014 RFC-7234 HTTP/1.1 : Caching, June 2014 RFC-7235 HTTP/1.1 : Authentication, June 2014 RFC-7236 Initial HTTP Authentication Scheme Registrations, June 2014 RFC-7237 Initial HTTP Method Registrations, June 2014 RFC-7469 Public Key Pinning Extension for HTTP, April 2015 RFC-7540 Hypertext Transfer Protocol Version 2 (HTTP/2), May 2015 RFC-7541 HPACK: Header Compression for HTTP/2, May 2015 RFC-7725 An HTTP Status Code to Report Legal Obstacles, February 2016 参考 List of RFCs IPv6.com - The role of the Internet Engineering Task Force in IPv6 development.","tags":"ideas","url":"/articles/HTTPSpecsOverview","loc":"/articles/HTTPSpecsOverview"},{"title":"唯一性标识的矛盾","text":"唯一性标识 (Identity) 的缩写有「ID/Id/id/I.D.」目的是在一定的范围内，标识一个对象的唯一性。 唯一性标识的生成方法众多，典型的有 算法生成类 数据库的自动生成，例如MySQL的Auto Increment自增特性 分布式的生成算法，例如Twitter的64bit自增 SnowFlake2010 128bit长的 UUID 基于具体场景，设计相关算法，在使用时自动生成 人工输入类 纯字母 字母数字组合 唯一性标识的生成结果有两种 可转换为全数字，例如SnowFlake 16进制字符，例如UUID 唯一性标识的可用性评价维度 隐私保护 整体可用容量 单位时间可用量 首次生成简便性 后期录入简便性 后期迁移简便性 人工阅读可预判性 分库分表可路由性 一些具体的潜在的易用性维度 最好能够反映一些和具体使用场景有关的信息，例如身份证的前14位。 尽可能的短 简便的键盘输入，比如纯数字或纯小写字母","tags":"ideas","url":"/articles/TheConflictionOfID","loc":"/articles/TheConflictionOfID"},{"title":"变是永远不变的现实情况","text":"系统的上线就意味着给业务带上了手铐。（已经忘了是从哪听来的这句话了） 变是永远不变的现实情况，因为变是源自于认知的升级。 变有哪几种类型呢？假设以纯人工方式进行一项业务： 个体变了（单个职责 [ 功能 ] 变了，不影响他人） 流程变了（分工界面 [ 接口 ] 变了，会影响他人） 流量变了（功能分工都没变，就是要多安排人手 [ 水平扩容 ] ） 一般来说，一个信息系统的交付，一定是以整体需求为基础，按照瀑布或敏捷方式进行交付的。 在这个交付过程中，工程师们在落地形态上，会把一些「功能」和「接口」在物理形态上进行集成。 这样高聚合的实现设计，一方面是由于过往硬件成本过高，另一方面也是由于担心跨进程所引起的不必要性能开销。 高聚合的设计，为将来系统进行业务进化，种下了许多「技术债务」的种子。 技术债务中的很大一部分，来自于后人对「业务逻辑」的不理解，没有文档，晦涩难懂的接口名称，一团乱麻的逻辑...... 在微服务落地的过程中，当系统落地方，接手一个完整的、冗长的业务需求说明，就意味着99%的场景下，微服务不太可能实现，因为很有可能看不见拆分的原则。 也许有一种视角，就是能够知道一个企业中的全部业务流程，并对业务流程进行优化和缩短，也许这种方式是业务和技术都愿意看到的情况。 一个微服务 ( Actor ) 应该是一个职能在虚拟世界中的投影，一组微服务构成的能力域 ( Domain ) 就应该是一个部门在虚拟世界中的投影。 一个职能对应于一个微服务 ( Actor ) ，是合理的。 微服务有多少种不同结构上的拓扑形态，应该是取决于自然社会的业务形态。","tags":"ideas","url":"/articles/Changing","loc":"/articles/Changing"},{"title":"信息系统和平行宇宙","text":"信息系统（软件和硬件）就是从自然世界向虚拟世界的映射。 每个企业，每个行业，都以唯心的方式（意识决定形态，用自己的意识决定自己虚拟世界的形态）向虚拟世界映射。 于是，这个自然世界形成了若干个、无数个虚拟世界，也就是自然世界的若干个平行宇宙。 每个IT系统的所有者，都在想尽办法，更快、更精准的去刻画自己的平行宇宙，并在自己的宇宙里，分析自然世界，并把结果反作用于自然世界。 任何一种依靠人类体力劳动和脑力劳动的方式，最终都会比不过以「智能信息系统」自己作为映射工具的方式。 也许，正在打开的是一扇门，通往平行宇宙的一扇门。","tags":"ideas","url":"/articles/ITTheMirrorOfParallelUniverses","loc":"/articles/ITTheMirrorOfParallelUniverses"},{"title":"好的架构师，挖空心思偷懒","text":"架构，是解决问题的模式。 架构师，是这个模式的设计者。 问题的出现，是因为人的贪婪。 架构的出现，是因为人的偷懒。 机器的出现，是人不想劳动。 软件的出现，是人不想思考。 架构的多变，是因为万物多变。 架构的不变，是因为万物相通。 好的架构，以不变应万变。 好的架构，省时省力省心。 好的架构，折射人的贪婪。 好的架构师，挖空心思偷懒。","tags":"ideas","url":"/articles/ArchitectArchitecture","loc":"/articles/ArchitectArchitecture"},{"title":"从元宵节煮汤圆看架构的识别与设计","text":"架构定义 所谓架构，就是解决「人所遇到的问题」(简称问题)的办法。 采用什么办法解决问题，和客观的条件有关，也和当事人有关。 因此，办法会有很多种，背后所体现的理念会有不同，折射出的是不同的价值观。 好架构的定义 「好」架构，应当是对架构使用人「简单」并且「通用性强」，可以解决「很多」人的类似问题。 「好」架构，应当因地制宜，不要求额外的增加使用人的负担（比如额外采购设备，学习新的知识），增加使用人的使用成本。 煮汤圆的传统架构 煮汤圆的传统架构就是老一辈交代的煮汤圆方法。 这里所描述的煮汤圆的方法，可能只是传统煮汤圆的方法之一，大致过程描述如下 取一锅干净的冷水 把冷水煮开 把适量的汤圆放入锅中 等水再次烧开 加入冷水，以保持汤圆不被煮破 重复第4/5步若干次 汤圆变熟，捞出享用 一定还有更多方法，因为煮汤圆的过程，和锅有关，和水有关，和火力有关，和被煮的汤圆数量和大小有关，不可避免的煮汤圆的人有关，等等等等。 煮汤圆的传统架构好不好 好。理由是： 对于汤圆怎么被熟的质变过程不需要了解（不需要了解物理原理） 可视化的温度，水煮沸了，就说明温度到达100摄氏度（一个标准的大气压条件下） 对于煮汤圆的设备不需要额外添置（常见的水、锅、煤气灶就可以） 整体过程容易理解，实际操作性强（烧开加水的重复过程，三岁小孩也许都会） 好吃有卖相是煮汤圆的目标 直接目标是煮熟（基本前提） 问题是，熟是一个定性非定量的修饰词。熟，需要能够被量化，量化之后才能被管理。 于是熟的量化标准之一常常会被提及：汤圆至少要浮于水面之上。 可问题又来了，浮在水面之上的汤圆不一定能保证在咬开之后，里面的馅料也是熟的。 于是前辈们，还会告诉我们，等待汤圆略微发胖，这是提高汤圆馅料变熟的有效量化标准之一。因为胖，是肉眼可见，是可被量化管理的对象。 间接目标是不煮破不煮糊（还得有卖相） 由于汤圆的外部材料主要是糯米，糯米遇到水之后，尤其是沸水，会发生结构分解（是不是分子，因为作者不是食品和高分子学专家，不能细讲，也不能乱讲），其最终结果就是煮糊了，也就是糯米和水完全融合了在一起，汤圆已经没有了型。 因为怕煮烂，所以老一辈会特别强调，加入反复加入冷水，让水保持在似开非开的状态。 这种方法，一方面是保持煮汤圆所需要的温度，一方面是降低沸水所造成的汤圆不必要的翻动，避免加速汤圆煮烂。 把煮熟汤圆「好吃」的关键要素（根据现象看本质） 热能 热能，是使汤圆从生到熟发生变化的核心、必要条件。没有变熟所需要的热能，并保持在合理的温度，汤圆静静的放在那里，永远不会变熟（但可能会变质）。 时间 时间，是控制汤圆发生质变的必要条件。时间需要和温度配合，才能达到让汤圆变熟的目的。 潜意识的基本假设 不管多少类型的汤圆，大小基本固定，一般条件下，手工汤圆的大小，要比速冻机械制作的汤圆大一圈。 被忽视的核心要素 汤圆在被煮前的基本物理条件，是直接从冷冻室内取出，还是常温。 需要注意的是，沸水和汤圆糯米外皮的物理接触，是热能的第一道传导方式。汤圆的糯米外皮和馅料，是第二道传导方式。 糯米外皮与馅料的热传导方式相比把水煮沸是缓慢的，换句话说，糯米皮和馅料，是热的不良导体，导热性能比水差。 同时，冰冻的馅料变熟所需要的热能要比常温馅料的多，但热传导的效率基本不变。 在冰冻的状态下进行直接加热，势必造成加热的时间变长，这样一来，汤圆的糯米更容易发生煮烂，如果还采用翻滚的沸水煮，很难避免汤圆煮烂、馅刚熟的情况发生。 所以，在煮汤圆之前，最好把冰冻的汤圆从冰箱取出，在室温下放置一段时间。 到底要如何煮汤圆 煮汤圆的基本概念 汤圆本身、一次煮汤圆的总体数量、锅的容量、热源功率、热源功率的可条件范围。 煮汤圆的领域分解 原材料供应商（汤圆） 煮汤圆平台-热能供应商（天然气灶、煤气灶、电磁炉、电陶炉、煤球炉、煤油炉、烧柴火的灶等等） 需要注意的是：这些热提供商的性能指标并不相同。比如，热功率（单位时间所提供的热能）提供热能可调节的范围。 作者直观感受是：现代化的天然气灶、煤气灶、电磁炉，热功率可调节范围要大于煤球炉和烧柴火的灶。 煮汤圆平台-恒温水容器供应商（水和锅） 高中物理，告诉我们，水的比热容是很高的。所谓比热容，说的通俗一点，就是温度升高一度，所需要的（热）能量。 所以，一个大锅里盛满的沸水，要比一个小锅盛满的沸水，所储藏的（热）能量多。 煮汤圆平台-熟汤圆交付集成商（煮汤圆的人） 煮汤圆的人，首先要评估要煮的汤圆有多少，热能的获得方式是什么、可调节性有多强，锅有多大、里面可以放多少水。 煮汤圆的基本流程 用锅把水烧开 下生汤圆，以最快的速度把水加热并接近沸点（接近水的沸点） 在一段时间，保持一定的水温（接近沸点，避免沸水翻滚以保持汤圆卖相），直至变熟（汤圆上浮和变胖） 又快又好把汤圆煮熟（最佳实践） 找尽可能大的锅 大锅，意味着可以放更多的水。在把一批汤圆放入到沸水中之后，由于汤圆和水会直接发生热交换，导致水温降低，水的温度直接从沸点下降。 举个极端的例子，在正在煮沸的一锅沸水中加入一滴常温的水，那么整个锅里的水，还将是煮沸的状态。原因是： 一滴常温水，变成沸水的所需要的热量，热能提供商（比如煤气灶）可以快速提供。 沸水的流动性，使得沸水和常温水的物理接触面增多，热交换速度变快。 这个极端的例子告诉我们，由于一滴水加热至沸点的能量，远小于蒸锅沸水的能量，所以蒸锅水在此过程中，水温基本不变。 回到煮汤圆的场景，大锅意味着加入常温的汤圆水温下降会变少。 持续的高水温，有利于提高热传导的进行（势能差越大，能量交换越快），有利于缩短煮熟汤圆的时间，保持汤圆的卖相。 把热源的功率发挥到最大 快速提供热能，使放入生冷汤圆的之后水温迅速提高，需要两方面的配合: 把热源开到最大（例如，把煤气灶开大火） 增加火和锅的接触面积（选择平底锅和煤气灶，并把锅底放在煤气灶的火焰温度最高的外焰位置） 保持准沸水的水温 保持略接近于沸水的水温，获得最高效率的热传递同时，避免水的翻动导致汤圆解体。 煮汤圆的锅，自身是具备一定散热功能的（在没有热源加热的情况下，水会停止沸腾和逐渐冷却至常温） 在热源最小输出热能的情况下，需要加入冷水，才能保持水温在沸点以下，避免不必要的水沸腾动能释放，引起汤圆破相。 非常规的花式煮汤圆秘籍（聪明人秀才艺） 在家煮汤圆不反复加水 前文所提到的，保持水温似开非开，是达成快速、不破相煮汤圆的必要条件。 在当煮汤圆的装备得到技术革新之后，我们可以做到把热源功率变小，平衡锅自身散热和热源供给的平衡。 同时，可以把锅容器，替换为玻璃材质，例如采用全玻璃锅，采用热功率无级可变的燃气和电气炉具。 这样整个煮汤圆过程全程关上盖子，水蒸气蒸发所带走的热能，也能看到水是否被煮开。 在实际操作过程中，只要保持水微微有些被煮沸，不对汤圆产生结构性破坏力。温度的用肉眼量化，结合控制火力大小的闭环控制。 这样做的好处是，增加了煮汤圆的机械化可能，减少了过程中，对于加水这一环节的依赖，减少了对水的需求，增加了能源利用率。 饭店煮汤圆「生熟混煮」 当然，控制水温的另外一个方法是，把加水，替换为加「生」汤圆。 这种方法，对于执行人的个人素质和能力要求更高，需要相当的实际操作经验。 其实，笔者相信，摄氏99度煮出来的汤圆，也是「熟」的。 智能煮汤圆产品设计（延伸阅读） 这里要表达的是，技术其实是可以给业务带来革新。 煮了一辈子汤圆的人（业务方），可能一辈子都不会提出「智能」煮汤圆的技术需求。 设计理念: 煮汤圆应该是不需要操心的，我只要「好吃」和「卖相好」的汤圆。 食客（吃汤圆的人）只要买来汤圆，把汤圆投进煮汤圆机里，在汤圆被煮好的情况下会自动提示食客来享用，甚至自动放到碗里。 突破技术限制 技术限制: 识别汤圆馅变熟 目前被传承的量化方法是「上浮」和「变胖」 目前需要最佳实践帮助和知道的是：上浮之后再煮多久 技术突破: 数字化汤圆馅变熟的技术指标 定位汤圆（因为水和汤圆的混合物，密度不一样） 判断汤圆馅料的温度（在前一步的基础上，采用热感应?超声波频谱?的方式(请原谅作者对于这一领域缺乏了解)） 恒温控制，保持水温接近于沸点但未到达沸点，避免由水的沸腾导致破相（笔者相信「99度」也能煮「熟」汤圆，当然这是在一个标准大气压的条件下） 降低数字化成本，以控制产品的整体成品，使其变为消费品而不是概念产品或者奢侈品。 口碑营销 消费者惊奇的发现，「智能煮汤圆机」其实还能煮馄饨、煮饺子...","tags":"ideas","url":"/articles/TangYuanInsightArchitecture","loc":"/articles/TangYuanInsightArchitecture"},{"title":"用Atom在Mac OS X 下编辑PlantUML","text":"Atom的插件: plantuml-viewer 它支持 对 plantuml 文本直接进行进行预览，不需要依赖 plantuml.jar 支持另存为 svg , eps , png 基础环境 brew cask brew install caskroom/cask/brew-cask pandoc brew install graphviz 编写与预览 Atom brew cask install atom Atom 插件 plantuml-viewer language-plantuml 不推荐的Atom插件 plantuml-preview 理由: 还需要依赖 plantuml.jar , 它在这里 其他相关 Chome Extension: PlantUML Viewer ，它实际上使用的是 PlantUML Server 进行图片的实时生成 支持中文，但字体渲染不够好 首行必须是 @startuml ，否则无法阅览 Firefox Add-ons: 暂时未找到 基于IntelliJ IDEA的扩展: PlantUML integration Eclipse Plugin 效果","tags":"experiences","url":"/articles/PUMLMacOSXAtomEditor","loc":"/articles/PUMLMacOSXAtomEditor"},{"title":"从「差评级汽车4S店维修服务」看汽车服务行业的企业软件发展空间","text":"汽车已经成为中国大城市家庭出行主要方式之一，随之出现的大大小小事故，可能每位车主都会经历。 如果出现一次多方事故，责任方，交警，保险公司，一定会成为事故处理的必要成员，很多时候定损中心也是大概率出现的主角。 一站式修车（定损，维修，理赔），目前对于无责方而言，仍是困难重重。 差评级汽车4S店维修服务 这里，只聚焦维修过程，来看看「差评级汽车4S店维修服务」,背后折射出多少汽车服务行业管理水平与汽车服务企业软件的支撑力不足。 首先，来体验一下一次真实的「差评级」的维修服务，涉及的汽车品牌则是德国三大汽车制造商巨头之一： 车主在送车维修（维修部位为倒车雷达）过程中，在4S店的等待时间过长。 车主在根据维修服务合同，准备取车前，2次主动电话联系4S店以确认准确的提车时间，都无法直接联系到接待专员。 在上述每次沟通过程中，4S店接线员都需要询问车主姓名、被修车辆车牌号、联系电话以及接待的维修服务顾问姓名。 当车主提车之后，车主以绝对信任的心态直接把车开走（没有对维修部位做复查），但在上路之后，发现需要更换新的倒车雷达竟然没有安装。 车主返店再维修过程中，店方无人主动接待，依靠车主自己根据回忆服务专员脸部特征、体貌特征，人肉找到服务专员，进行投诉。 以上几点，处处都体现了企业的管理水平不到位，企业软件支撑不到位。 要强调的是，软件对于传统企业来说不是技术，而是帮助企业业务运营和流程管理的有力工具。对于汽车制造商、服务商而言，软件使用成本则占企业运营总成本的一小部分。 企业软件架构升级方向 对于各大品牌的汽车4S店来说，改进客户体验，保证乃至品牌形象，已经成为企业经营不可或缺的一环。从企业软件角度，至少可以有以下改进： 汽车品牌商，以公有云为基础，统一各个4S店的各个内部信息系统，例如电话语音、客户管理、维修管理等等。每个4S店都将成为公有云的租户。 打通内部信息系统，例如IVR(Interactive Voice Response, 互动式语音应答)系统、CRM(Customer Relationship Management, 客户关系管理系统)、车辆维修系统，实现对客户身份的即时识别。 增加手持移动设备（例如智能手机、平板电脑）的支撑（如喷漆钣金之类的维修项目）需要做到接待专员的（维修前before，维修后after）拍照存档，提高向客户交车前的质量保障水平。这也是移动化改变业务流程的典型场景。 打通内部系统与互联网公众账号运营，增加客户自服务能力。例如，客户不需要打电话查询维修车辆的维修进度、提车时间，减少客户与服务商的无效沟通成本。 汽车服务企业，可以通过与互联网社交平台的对接，实现修理过程透明化，每个关键环节都可以有数字照片直接通过社交平台推送给客户。 与互联网消费者服务评价平台对接，实现客户满意度向企业运营决策层的消息直达，减少满意度由第三方转述的信息丢失与走样。 可以看出，传统服务行业，在移动互联时代，传统服务性行业的企业软件已经滞后于社会信息化发展。 云计算与移动化，企业内部多系统实时数据互通，内部系统与互联网社交平台的集成，已经成为改善传统服务行业客户体验的必然之路。 传统企业的软件架构，背后折射的是企业整体的业务管理水平；企业业务的升级，需要背后企业软件架构的升级。","tags":"ideas","url":"/articles/AutoRepair4SEnterpriseSoftwareEvolution","loc":"/articles/AutoRepair4SEnterpriseSoftwareEvolution"},{"title":"可运营的企业IT平台","text":"平台生产力 技术成本 学习成本 使用成本 维护成本 沟通成本 业务与技术团队沟通 技术团队内部沟通 业务价值 业务需求交付速度 业务创新力支撑 平台可运营评价维度 人员素质可发展 技术架构自主性 业务支撑连续性 上下游协作友好 管理制度平台化 平台产力提升途径 平台自动化程度 代码生成 文档生成 上下游协作流程 协作自助化程度 生产资料获得方式 社会化提问与答疑，质量与影响范围量化评估","tags":"ideas","url":"/articles/TheOperationableEnterpriceITPlatform","loc":"/articles/TheOperationableEnterpriceITPlatform"},{"title":"用Atom在Mac OS X 下编辑reStructuredText","text":"基础环境 brew cask brew install caskroom/cask/brew-cask pandoc brew install pandoc 工具 Atom brew cask install atom Atom 插件 language-restructuredtext (预览首选) rst-preview-pandoc (预览备选) rst-preview 设置 rst-preview-pandoc 设置 pandoc path , 通过 brew install 的工具，一般都位于 /usr/local/bin 采用 rst-preview-pandoc 时，可以忽略 Bugfix 1 在设置 pandoc path 后，应当不会出现 Bugfix 2 Bugfix rst-preview Live preview not working Atom 1.0.11 ~/.atom/packages/rst-preview/lib/rst-preview.coffee # line 76-77 # grammars = atom.config.get('rst-preview.grammars') ? [] # return unless editor.getGrammar().scopeName in grammars Workaround on OSX for pandoc could not be spawned error ~/.atom/init.coffee process.env.PATH = [\"/usr/bin\", \"/usr/local/bin\", ].join(\":\") 效果","tags":"experiences","url":"/articles/RSTMacOSXAtomEditor","loc":"/articles/RSTMacOSXAtomEditor"},{"title":"传统企业与互联网企业的软件价值观","text":"从单个计算机到互联网 在中国大陆，计算机有一个更为形象的名字，电脑。从字面可以看出，它是一件帮助人类进行思考的机器。但决定计算机思考什么，如何进行思考的，就是程序。 把人类脑袋中的可重复的、机械性的脑力劳动，变为机器可重复执行的程序，这个过程就是软件过程。 在计算机诞生之初，它所要解决的问题是科学计算，也因此得名计算机。可以想象，一个计算机的计算能力是有限的，但有了计算机网络，使得成千上万，乃至上亿的计算机可以协同工作，并形成更大的计算能力，也就为解放人类机械性脑里劳动，带来了想象空间。计算机也从科学家手里，走进了如今的平常百姓家。 要让计算机为普通百姓服务，从衣食住行医多方面提高人们的生活质量，其先决条件是信息化。信息化，是将一件事情或者一个物品或者一个时间或者定量货币，以数字化的方式精确量化下来。随着计算机硬件的不断发展，整个社会的信息化成本逐步降低。从而，人与人的通信、交易过程方便的可以信息化，并在此基础之上形成如今的各种面相个人的互联网产品：例如，社交应用、电子商务、第三方支付、个人信贷平台。 ### 现今的互联网特征 现在的互联网公司是以轻资产行业——除了计算机及网络本身，不需要其他生产工具的行业——为切入点，以数字化逐步改变了人的沟通方式、人的消费方式，乃至生活方式。 如今互联网公司普遍具有以下三个特征： 面向个人消费者（B2C） 由于用户基数大，以计算机（含网络和存储）为生产工具的互联网公司，为单个用户服务的边际成本低，并且规模效应大。 轻资产距离实体经济较远 无论是蓬勃发展的社交应用（微信、微博），电子商务平台（淘宝、京东），还是个人金融（P2P金融），都远离消费品制造本身。即便是电商平台，与实体密切相关的是自身仓储信息化，物流环节则是和合作伙伴公司进行信息系统对接。电商平台，绕开了消费品诞生最为复杂的生产制造环节。 经营虚拟对象 无论是淘宝、或者大众点评，在显而易见的商业交易背后，有着对个人主观感受、人际关系这些虚拟概念的经营，并将其与商业过程进行良好无缝的融合，促进个人消费市场生态的良性发展。即便像是百度、谷歌这样的搜索行业寡头，也是以广告、产品推广作为盈利模式，根本上还是通过技术手段尽可能拉近买卖双方的距离。 所以，互联网公司的生产资料是一些看不见、摸不着的\"关系\"，这也导致了互联网所极力倡导的用户体验，快速交付。因为这些生产资料，任何一家公司都可以触手可及，唯有与众不同和贴心，方能获得用户的长期青睐。 传统行业的企业信息系统 在传统行业里，有三大社会基础设施类行业的系统建设规模较大，它们是金融、电信、能源行业，每个企业所拥有的应用系统数量是成百上千，单个企业所使用的计算机规模也在数万至百万，或者更多。 放眼传统金融行业，例如银行、证券、保险等细分行业，信息系统也是企业的核心生产工具。与第三方支付平台不同，商业银行有着社会基础设施的不可替代性，导致了其信息系统建设理念与互联网公司有着天壤之别，因为数据既是货币，所有交付行为都通过系统完成，所以其宗旨是在以账务为核心的会计准侧下，确保稳定、可靠零差错。 电信、能源，都是以国家级重资产投资为核心的基础行业，其业务模式较为稳定，行业竞争性弱，主要受国家政策影响大。这类行业的信息系统主要解决两个方面的问题，重资产（数亿计的电信设备、电力设备）的信息化管理维护，面向个人与企业的业务营销，账务核销。 为什么其他诸如工业制造行业的大公司（比如美国通用电气，德国西门子，德国大众汽车）信息系统并没有得到普通大众的关注呢？一个重要原因就是实体本身对一个行业业务模式变化的牵制作用。以汽车制造为例，其主营业务是设计和制造整车，信息系统的主要作用是一方面对物料、排产、供应链进行管理，另一方面对主营业务起支撑或者提高跨部门、供应商协作效率的作用。可以想象，并不会因为IT系统的一次变更上线，就直接诞生一个汽车的新产品，但很有可能是打通了来自于最终用户的个性化订单这个渠道。但在如今的互联网行业，一次IT系统变更上线，就可能具有行业的颠覆性。 面对实体经济，面对工业制造行业，信息系统并不能像互联网一样，具备核心生产工具的地位。工业4.0和物联网，所涉猎的信息系统变革，其效果是加快企业对市场、对最终用户使用效果的感知，加快企业内外部实体多维度状态的感知，提高企业内部和上下游厂商的协作效率，从而整体提高社会实体经济的生产效率。 ### 重视软件交付过程 通常一个具有人机交互功能（也就是带可视化操作界面）的企业信息系统，称之为应用系统。一个最简单的应用系统会包含前端可视化操作界面（Web）、后端业务逻辑（Service）、底层数据库（Database）以及存储（Storage）三个组成部分。将这样一个应用系统交付给企业内部的员工进行使用，以传统的软件工程方式进行建设，需要经过软件生命周期的六大阶段：需求分析、架构设计、编码实现、测试验证、上线运行、后期维护。 对于复杂的应用系统，架构会变得更加复杂。这两者之间的差异，有着类似单间平房与摩天大楼的区别。其建设方法，制造工艺，也有显著区别。 对于一个复杂应用系统，可能由不同的团队协作完成。这和建筑行业有负责基建、负责内部装修的不同工程承包商类似。每个工程分包团队只完成其专业领域的那部分，工程整体由总承包商进行统筹管理。 对于一个复杂应用系统，可能采用一些通用的技术组件。这和建筑行业有不同标号的水泥，螺纹钢筋、光圆钢筋等不同规格类似。物料供应商则根据国际国家标准进行批量标准生产。在IT行业，这种通用组件则被称为中间件或基础软件。它的通用性并没有国际国家的强制标准，一般都以某一产品领域寡头的实施标准作为参考依据。 而被非IT行业所广为熟知的程序员，则是编码实现这一环节的生力军，这一环节负责把业务需求变为代码，从而实现系统的业务功能。鲜为人知的架构师，则需要从业务需求、功能开发、测试验证、后期运维等多角度确定系统的基本框架，犹如确定一幢高楼大厦的主体结构。 可以发现，人是信息系统的制造者，不同资历的从业人员，所交付的信息系统质量会有所不同。这类似实木家具的手工制作过程，不同技艺的工人，所制作的家具精致程度不一。 虽然可以有方法论、软件工程学来指导和规范软件交付的过程，但软件最终是为一个企业或者组织提供相匹配服务，不同的行业特征、不同的信息技术发展时期、不同的组织结构、不同的系统建设方式，导致了世界上找不到两个一模一样的最终交付使用的信息系统，就好比世界上找不到两片一模一样的树叶。 软件价值观 互联网公司 互联网公司的系统作为生产工具，一般都由自己员工进行开发、测试、维护。对外采购行为大多集中于主机、网络、存储等硬件设备。对于系统建设的理念是自主可控，为的是拥有极佳的业务变更适应性。另外，从互联网公司的业务视角出发，其信息系统可以根据行业特征进行优化，一般不采购上文所提到的中间件或者基础软件，大多使用免费开源的软件框架。 传统行业 传统行业的信息系统，作为业务支撑平台，一般都以自有信息化部门牵头招标，以对外采购软件产品配合系统集成商服务，对中间件产品进行二次开发，从而实现业务功能的交付。企业主体通常不具备自开发能力，依赖于外部资源。从软件生命周期角度，开发、测试、运维三大团体也很有可能分属不同的集成商，甚至是外包人员。 投资构成比较 以同样的投资成本，互联网公司愿意使用零成本的开源中间件和100%的人力成本，进行系统建设。而传统企业，则会使用90%以上的投资进行对外产品和服务采购，余下的10%则作为甲方的信息化办公室团队人员成本。 即便是互联网公司所提出的去IOE（IBM, Oracle, EMC）口号向传统行业蔓延，但传统行业所需要的人才储备却远远跟不上转型需要。 信息技术的社会价值 互联网＋／ 工业4.0 对于传统行业，\"互联网＋\"或者\"工业4.0\"更多层面是引导以信息化优化生产过程，提高生产效率，不可能也不能照搬互联网以计算机系统作为生产工具的行业模式。 \"大众创业，万众创新\" 轻资产的互联网经济，已经被发展十余年拥有雄厚资金实力的互联网公司所操控。新想法，新创意可以被他们轻易复制和超越。 创业和创新的社会环境，面对普通大众，也许成功的只有彩票级的概率吧。 社会老龄化与延迟退休 中国社会老龄化已经是一个不争的事实，其导致的问题是社会青壮年所创造的社会财富无法供养不参与社会劳动的老年人。 直观的做法是以劳动人口数量直接来弥补社会劳动力的缺失，以创造足够的财富供养老人。 中国劳动人口基数庞大，如果信息化手段能够提高社会生产效率，也许能够降低延迟退休政策所引起的群体排斥心理。","tags":"ideas","url":"/articles/TraditionalVsInternetEnterpriseSoftwareValues","loc":"/articles/TraditionalVsInternetEnterpriseSoftwareValues"},{"title":"Mac OS X环境","text":"Mail Mail.app Browser Chrome (Extensions) SwitchyOmega 1Password AdBlock Plus Evernote Chrome (App) Postman Gliffy ProcessOn Firefox (Adds-on) Firebug FoxyProxy Firegesture 1Password AdBlock Plus Evernote RSS Reeder 3 Editor & IDE Sublime Text Atom Mou / MacDown BBEditor IntelliJ IDEA PyCharm Version Control SourceTree Cornerstone DataBase Navicat Notebook Evernote Security 1password Efficiency Alfred Powerpack Spectacle iTerm2 zsh + oh-my-zsh Homebrew + homebrew cask RamDisk Automator Shell Socks5 socat / netcat Synchronize Dropbox Calendar LunarCal Fantastical Remote SecureCRT CoRD","tags":"experiences","url":"/articles/MacOSXEnvironment","loc":"/articles/MacOSXEnvironment"},{"title":"Pelican TOC Plugin","text":"插件准备 使用 extract_toc 执行 git clone https://github.com/getpelican/pelican-plugins.git 修改配置文件 文件： pelicanconf.py 指定插件目录 PLUGIN_PATHS = ['<your_path>/getpelican/pelican-plugins'] 启用插件 PLUGINS = ['extract_toc'] Markdown标记 插入 [TOC] 标签，例如： title: Pelican TOC Plugin date: 2015-10-16 modified: 2015-10-17 tags: pelican category: pelican [TOC] ### 插件准备","tags":"experiences","url":"/articles/pelican-toc-plugin","loc":"/articles/pelican-toc-plugin"},{"title":"把时间当做朋友","text":"李笑来：《把时间当做朋友》 能力： 我们要努力，我们要坚持，我们要学习，我们要有志向，即使不是那么远大 欲望：守住自己的心 幸福=能力-欲望 我要的幸福： 我曾经历了许许多多，现在，我似乎明白了什么是幸福，在乡下恬静的隐居，尽可能对人们做些简单而有用的善事，尽管那些人们并不习惯我为他们做了这些，做一份真正有用的工作，最后休息，享受大自然，读书，听音乐，爱周围的每一个人。这就是我对幸福的诠释。在这些之上，有你为伴，也许还有我们的孩子，一个男人还能再渴望些什么呢？ ——列夫 托尔斯泰《家庭幸福》 I have lived through much, and now I think I have found what is needed for happiness. A quiet secluded life in the country, with the possibility of being useful to people to whom it is easy to do good, and who are not accustomed to have it done to them. And work which one hopes may be of some use. Then rest, nature, books, music, love for one's neighbor. Such is my idea of happiness. And then, on top of all that, you for a mate, and children perhaps. What more can the heart of a man desire? — Leo Tolstoy 《Family Happiness》 \"要管理的不是时间，而是自己。人们生活在同一个世界，却又各自生活在自己的那个版本之中。改变自己，就意味着属于自己的那个版本的世界将随之而变，其中也包括时间的属性。开启自己的心智，让自己能够用最可能准确的方式思考、观察、记录、总结、分享和行动，那么自己的时间就会拥有不同的质量，进而整个生活都必然因此焕然一新。\" //#心声#，对自己不满首先要做的是改变自己。 苏格拉底揭示所谓的思考过程不过是\"提问和回答\"。 而千百年后培根说得更加全面：\"读书使人完整，讨论使人完备，写作使人完善\"。 //#心声#现在真正读书的人比例不高，进而真正\"讨论\"而不是\"争论\"的人更少，能总结写博客的少之又少。\"微时代\"是个机器浮躁的时代，没多少人能够沉下心做大事。 \"没时间了\"，其可怕程度几乎无异于死亡。死亡是所有人都要面临的终极困境——没有解决方案的困境。...... 死亡本身其实并不可怕，面临死亡的过程才真正可怕。如此，就很容易地体会那些\"既勤奋又懒惰\"的学生，面临的是怎样的悲惨境遇了。......但是生活中明显有另外一些人——尽管数量上并不占优——在用另外一种状态生活。他们从容，他们优雅，他们善于化解各种压力，安静地去做他们认为应该做的事情，并总能有所成就。他们甚至可以达到常人无法想象的境界——不以物喜，不以己悲。 总的来说，一方面是自己的欲望无限，一方面是要完成的事情太多，一方面是自我满意度的不断下降——这就是人们总是不由自主地期望速成的根源。出路肯定存在，但这出路只有一个起点——接受现实。告诉自己：我有不足，我需要时间，我没办法一蹴而就。 积累多的人之所以稳健，是因为对他来说，\"我要\"的欲望可以用\"我有\"的东西来满足。即便\"我有\"暂时不够，他也能借助已经拥有的足够努力和勤奋（抑或投机取巧的方法和经验），只需假以时日，定能如愿以偿。一旦得偿所愿，不仅\"我有\"的更多，\"我要\"的也更容易获得，如此形成良性循环。 //#心声#，其实抑或投机取巧的方法和经验，我并不赞同。 尽管天分确实很重要，但一个人的能力主要靠积累获得。从一个人开始从事一个职业的那一瞬间起，只要足够认真、努力，他的能力就会不停地积累。如果这个人实际上向往的是另一个职业，那么他的所谓\"梦想\"几乎必然是他在当前这份职业上心不在焉、无甚积累。其实，世界上80%以上的职业并不过分依赖天分，更可能甚至几乎只依赖积累。天长日久，这个人的当前的职业中将逐渐落后于那些认真做事的人。但此时他不会因为自己的落后而奋起直追，反过来，更可能的是把\"反正我的梦想不是这个\"当做借口。 //#坚持·勤奋·认真# 越是不满现状，摆脱现状的欲望就越强烈，而这种欲望会让一个人最终迷失方向，因为无论是谁，从本质上看都无法摆脱现状——每一时刻的现状都是过去某一或者某些时刻的结果，而每一时刻的现状都是未来或者某些时刻的原因。没有人能够逃脱现实的束缚。 从某种意义上理解，\"逆境造就成功\"、\"磨难令人成熟\"之类的话纯属胡说八道。显然，在顺境中更容易成功，而且很多磨难根本没有必要——这更可能是失败者对他们自己一生都未曾有机会体验的成功及成功者\"意淫\"式的猜想而已。失败者永远没有机会了解成功的真相，因为人最容易受自身经验的限制，而不曾有哪怕一点点成功经验的人更无从摆脱自身的局限。 //引申到我的个人观点：没有必要去刻意吃苦，但绝对有必要能吃得起苦。 几乎一切愚蠢的欣慰都来自否定现实、逃避现实，只有接受现实，才可能脚踏实地，避免心浮气躁、好高骛远。如果我们把成功朴素的定义为\"用正确的方法做正确的事情，并在最后期限之前漂亮地完成\"的话，那么，大多数所谓的\"时间管理技巧\"实际上发挥不了多大的作用，只不过是花拳绣腿。真正有用的往往是简单而又朴素的道理，例如\"现实只能接受\"。 怎样判断所做的事情是否正确？核心只有一个：看它是否现实。 很多人一生都不知道自己究竟有多么不现实。之前提到的\"勤奋又懒惰\"的人群，基本上都是把这些现实当做老生常谈的道理——视而不见、听而不闻、从不记录、从不反省，才常常作出荒唐的决定，最终堕落到那分田地。 //现实——脚踏实地，稳扎稳打，步步为营 两点之间的最短距离是恶性循环。——墨菲拓扑定律 //这句话，也许对我曾经对很多人举过的一个例子的反面高度抽象。 为了实现一个目标A，可以借助旁人的力量，直接获得A。也可以通过自己的实践获得A，同时在这过程中收获方法B，副产品结果C。 这是实现自我价值提升的良性循环。#技多不压身# 事实上，那些真正能够做对、做好的人，绝不会随意嘲弄、打击别人，因为他们是做对过、做好过的人，他们一路走过来，心里非常清楚做对、做好有多么不易，所以，他们会不吝一切机会去鼓励那些尝试做事情的人。这甚至可以当做一种测试方法：如果一个人经常嘲弄他人，那只能说明他自己不怎么样；否则，他会想那些极少数已经做对、做好的人一样，给予别人真诚的鼓励而非嘲弄。尽管那些能做对、做好的人又是也会给出负面评价，但这些评价通常是\"建设性的负面评价\"，并不是为了获得优越感而发出的嘲弄。 所以，我们没有必要在意来自他人的、非建设性的负面评价。没有谁从一开始就能做对、做好。所有做对、做好的人都是一路磕磕碰碰走过来的，这就是生活常态。而动辄给出非建设性负面评价的人，往往不是正经做事的人，他们和那些正经做事的人身处不一样的世界，这也是生活常态。 //只见贼吃肉，不见贼挨打的现象的是非常普遍的；那些尝试做事情的人，是孺子可教的人，他们在努力，需要被鼓励，需要被肯定。 更重要的是，人在小时候没什么事情可做，就愈发感觉时间过的慢；随着年龄的增加，要做的事情越来越多，当然就愈发觉得时间过得飞快，稍纵即逝。由此看来，小孩子的感觉自然是\"那时候天总是很蓝，日子总过的太慢\"，而\"人生犹如白驹过隙，瞬间而已\"大都是老年人的慨叹，也是他们的切身感受。 //时间有限，精力有限，我们不能什么都想要。幸福=能力-欲望。 所有真正做事的人都知道，任何任务的绝大部分都是枯燥而又无趣的，所谓有创意的部分，可能连1%都不到。对此，我有切实体会。 //就像爬山，枯燥而无趣地拾阶而上，为的只是站在最高点欣赏一览众山小的壮丽美景。 但不是每个人都有毅力坚持到最后，也不是每个人都有能力坚持到最后。毅力需要培养，能力需要积累。 而培养和积累的过程会很漫长，会很艰苦，会感觉到累，这就对了，说明在向上走。 //往上走，即便是一小步，也有新高度。 //我也会向众人提起，\"我喜欢做有创意的事情\"，但，我会为了这1%去做99%的枯燥的事情。 实现目标之后，再设定下一个1%。这样，人生就丰富了，并且不是简单的丰富了。 做任何事情，学会思考方式最为重要。要学着像一个项目管理者那样思考——他们更多关注\"方法\"，他们会花费比别人多（多出许多倍）的事件去落实每一个步骤。 在做任何事情之前，通过关注\"方法\"去反复拆分任务，最终确认每个子任务都是可完成的，这是一个人不可或缺的功课。 这样的习惯，会使得一个人变得现实、踏实。 这既是一种习惯，也是一种后天习得的技能。这种技能无比重要，却常常被忽视，业务掌握这种技能的人总是默默地应用它，而忽视这种技能的人从未看到过它的具体实施过程和巨大好处。 //#授人以鱼不如授人以渔#，珍惜每一次被授人以渔的机会，好的方法是节省时间的方法。书是前人对思考的系统总结和归纳，书传授的是方法。从小我们就被熏陶\"书是人类进步的阶梯\"，但不一定真真理解。（这里的书不是指小说，虽然它有时候也具备一定这样的功能，但需要自己具备归纳总结的能力） 与所有人一样，从小自命不凡的我当然也给自己贴过各种各样的标签。我崇尚公正，向往自由，渴望平等，憧憬希望。在相当长的一段时间里，我感受到的是禁锢，体会到的是差距，意识到的是失望。我现在猜想，或许所有人都必然要经历这样一个阶段，不过只有少数人能够度过这一阶段。 直接来自感官的认识很容易与他人分享，而思想上的体验却往往难以用语言表达。 //#心声#，何况我语文又那么差。 在与计划相关的格言中，我最喜欢的是：\"我们不是计划着去失败，而是失败地计划\"。 所有真正执行到底的计划，都是因为其目标现实可行。 有人说\"计划总是没有变化快\"。这句话听上去挺现实，缺没说到点子上。计划总是被变化打乱的深层次的原因在于：计划过于长远。事实上，无论变化多快，计划总是要有的，只是在制定计划的时候，应该考虑到变化，应该以自身的情况分析自家究竟适合制定多久的计划。 做长期计划显然是正确必需的，但是，并非每个人都有制定长期计划的的能力。这种能力可跻身最重要的能力之位，拥有它需要挣扎、需要努力、需要从一点一滴做起。 不要上来就制定过长的计划。 哪怕制定一个星期的计划，都不是很容易的事情——实际做一下就知道了。 //当每本书看到接近于一半位置的时候，是最惬意的。因为可以把书妥妥的平放，不用手压，全神贯注地与作者交流。翻书的声音很悦耳。 计划固然重要，行动更为重要。 如果想做事，当然要行动。行动是改变自己的众多方法中最有效、最直接的方法。很多时候，只要开始行动，哪怕实现并无计划，往往也会有收获。但是反过来，缺乏行动的计划肯定没有任何意义。 如果想要改变自己，或者对自己目前的处境不满意，那就一切从简——找一个你觉得应该会带来改变的任务，然后去做就是了。不要怕碰壁，不要怕失败，那是必须经历的过程。失败并不可怕，因为人总是要失败许多次才会得到结果，况且全天下又不是只有你会失败，怕什么？达成目标的关键在于每次受到挫折之后能否汲取教训。只要能汲取教训，然后自我调整，那就是进步。我们一生所做的事，大都是在试错，对于人生，没有人能像解释数学或物理学那样给出普适的公式。 永远记住，马上行动是最重要的——尽管这句话已经被无数人所过无数次。 //有多少人，其实是被自己拖死的。如果没有勇气去接受失败，那么也没有机会去获得成功。曾几何时，有人对我的评价是执行力强，雷厉风行。 很多人常常拒绝学习，他们拒绝学习的理由和那些痴迷学习的人一样——不知道它有什么用。 如果说，车是人类腿脚的延伸——使人们走得更远，望远镜是人类眼睛的延伸——使人们看得更清楚，计算机是人类大脑的延伸——使人们算的更快......那么，学习就是人类所有能力的延伸——使人们拥有更多的能力，并且往往主要取决于你花费的时间与精力。 事实上，学习是投资回报率最高的行为。 //确实如此，每当觉得无所事事的时候，看看大家的文章，或者动动手写写与工作无关的程序，吸收营养，不管是经济、历史、传记、管理、经营还是其他等等。——我的理由是：不知道它现在有什么用，但一定会有发挥作用的时候。有很多例子在自己身上不断应验。 \"拒绝学习\"的例子。我曾多次劝我的一个朋友花20分钟学习一下命令行下的批处理方法，未果。他拒绝的理由是：\"现在谁还用命令行啊？早就是可视化操作系统的时代了！\" 我曾经多次劝我的另一个朋友花10分钟学习一下Google通配符的使用，未果。她说\"不用那东西也一样能找到自己想要的啊！\" 我曾替他们着急，可是后来却发现这是个\"死结\"。为什么呢？第一，拒绝学习就不可能有机会知道学习之后的收获；第二，由于不知道学习之后的收获是什么，也就不可能知道那收获有多好、多大；第三，既然对学习的好处无从了解，自然就没有学习的动力...... //这是一个恶性循环。未果，说明，人和人的沟通，有时候真的没有用。子非鱼安知鱼之乐。大家的知识背景不同，所能看到的视野不同，所得出的结论不同，总之，价值观不同。 \"学习\"的重要起点是：起码学会一种技能。无论这中技能多简单、多普遍，学会之后总是可以让学习者了解\"习得\"带来的大不同。一旦拥有了一个起点，学习的欲望就会像发芽的种子，无论多大的石头都压不住——它会越来越茁壮，越来越坚强。 其实，那些拒绝学习或者一不小心受了影响而把\"学习\"两个字妖魔化了的人真的非常可怜，他们每天都在挣扎着想要\"管理时间\"、\"珍惜生命\"、\"提高效率\"，却不知道他们因为当初不肯花十几分钟学习而导致其后少做了很多事情、错过了很多机会，并且连只有一次的人生都没有过好。 千万不要拒绝学习。 //不学习是多么的可悲！ 观察一下就会发现，日常生活中主要的\"沟通障碍\"本质上几乎都是由于沟通双方无法让对方理解与他们的经验相悖的知识或信息造成的。 不夸张的讲，目前几乎所有关于沟通技巧的书中提供的解决方案都没有真正说到点子上。 这种知识和信息传递中的问题，不是仅仅通过\"站在对方的立场上考虑问题\"就可以轻松、彻底地解决的。 尽管\"站在对方的立场上考虑问题\"确实是很有用也很难掌握的技巧，可当我们面对（或者说\"背对\"可能更准确一些）\"站在双方立场都无法考虑到的问题\"时呢？ 尽管这时我们甚至可能不知道问题究竟是什么，但有一点是确定无疑的——这种问题不仅确实存在，而且往往至关重要。 在我看来，所有教育失败的症结也在于此。在人们探索未知、寻求真理的时候，困难大都来自如何正确地理解\"与现有经验相悖的知识\" //如何正确理解\"与现有经验相悖的知识\"对我来说是个难题，对于我来说，现有经验=对，与现有经验相悖=错，除非能证明这个相悖的知识确实是对的，我才能接受。可是，在我不轻易放弃现有经验的情况下，怎么证明？（但不要忘了我是讲道理的） 自学能力的打造就是从我们认真对待它开始的。它就像恋人一样，你对它好，它才对你好。完全靠自己学一样东西吧——管它是什么，并且一定要学好，学到比相当数量的人都好。如果真的做到这个地步，那你就不仅是一个完整的人了，还是一个相当优秀的人。这时，你完全可以对自己说：\"你太有才了！\" 我个人的建议是去自学一门计算机程序语言，因为计算机程序语言的相关资源在互联网上分布广泛、极易获得，而且优秀的资源使用的语言往往是英语，这又顺带练习了英文阅读理解能力——想想吧，肯定不仅是一举两得。 //借用某人的一句话，程序员的语言只有英语，不服来辩。同时，作为一个可以改变生活，梦想改变世界的程序员，对这职业感到深深自豪。 很多人就是这样，坚持拒绝思考，然后用天下最累的生活方式而不自知。大哲学家罗素曾观察到这个现象，他为之奇怪并慨叹，\"很多人宁愿死也不愿思考\"，然后戏谑道，\"实际上，他们确实死得很快。\" //脑子不用跟没脑子有什么区别 一个人的强与弱，实际上相当于他的勇气减去他的恐惧之后的分值——如果是正数，那么他是强的；如果是负数，那么他是弱的。所有人的起点都是负数。但凡是人，都要经过很多的挣扎才能使这个算式的结果变成正数。并且无论是谁、无论这个人有多强，都不可能完全消除恐惧。勇气可能等于零，恐惧却永远大于零。 //人贵自知，勇气需要积累。 之所以在遇到尴尬时会冒出这样的念头（后悔），是因为太多人早就朴素地明白一个简单的道理：我们所面临的今天很大程度上取决于我们的过去。 //哈佛校训：你所浪费的今天，是昨天死去的人奢望的明天；你所厌恶的现在，是未来的你回不去的曾经。 //你珍惜今天了吗？ 读书，其实不见得一定要有目的，随意翻同样有益——有用的知识经常是偶然获得的。时间久了，我们就会发现，读书偶得的知识不仅多，而且非常重要，只不过因为很多人因为片面而又肤浅地理解\"人生应该有目标\"而失去了这些机会。 //观察，阅读，思考，总结，是提升自我的\"捷径\"。知识是眼界之基石。 方法固然重要，但是比起\"用过\"来说，方法几乎可以忽略不计。 //\"用功\"是一种坚持，一种质朴的力量，它可以使人抛开一切杂念，享受心灵的宁静。 所有学习上的成功，都只依靠两件事——策略和坚持，而坚持本身就是最重要的策略。 坚持，其实就是重复；而重复，说到底就是时间的投入，准确的说，是大量的投入。 //策略中还包含一项重要的内容：专注。三天打鱼两天晒网是万万不行的。而重复，也不是指简单的机械性重复，而是经过归纳总结的螺旋式上升。如果在一次又一次地重复的过程中，没有缩短时间，那么就是在浪费时间；而缩短时间的过程，就是找到方法，并不断优化。 其实，比成功更重要的是成长。如果\"成功\"是与他人比较的话，那么\"成长\"则是与自己比较——今天的我和昨天的我、明天的我和今天的我之间的比较。后一种比较显然比前一种对个体来说意义更大，也能够带来更加踏实的幸福感。 //每天成长一点点，时间会给出答案。不信？回头看看。 浪费时间、虚度年华的人，有一个共同的特征——拼命想控制自己完全不能控制的事物，却在自己真正能掌控的地方彻底失控。 相信运气其实是缺乏自制力的表现。 //我越来越相信，所谓的\"运气好\"，本质上是自身能力以及对周围控制力的综合作用的结果。使自己避免处于不确定因素中，以至于失去控制，听天由命，这本身就是获得\"好运气\"的必要条件。 \"相信我，所谓的人脉就算重要，也根本没他们说的那么重要。\" 这些公认为优秀的人，往往并不\"低调\"，也不\"平易近人\"。他们不是故意这样做的。他们无意去惹恼那些在他们看来\"平庸\"的人，只不过他们无形中有这样的体会：与这些人交流，沟通成本太高。这些人当中不多见的那些心态平和者，一般都是经历了波折，才终于意识到自己应该保护自己。他们发现，有些误会根本没机会解释。于是，他们开始\"谦虚\"，他们学会\"低调\"，他们显得\"平易近人\"。 //懒得解释 承认自己能力有限，是保持心理健康的前提。 \"量力而行\"是如此高难度的行为模式： 第一，承认自己能力有限； 第二，不怕在别人面前露怯； 第三，敢于不去证明自己是\"好人\" 从这个层面上讲，的确往往只有优秀的人，才会拥有有效的人脉。 而且，正因为这些人随时随地都可能要回避\"不公平交换\"的企图，他们会更加注重自身的质量，知道\"不给他人制造麻烦\"、\"独善其身\"是美德，这也体现了常言说的\"事多故人离\"。 //还记得那个公式吗？幸福=能力-欲望。独立，是立身之本。#不求人格自高# 有些资源很难靠白手起家获得，例如金钱、地位、名誉。然而，有些资源缺可以轻易从零开始积累，例如一个人的才华与学识。才华与学识，是一定可以通过努力获得的。一个人的心智能力一旦开启，只要正常地努力，并且有耐心和时间做朋友，很容易就能成为至少一个领域的专家。 努力并不像传说中的那么辛苦，说出来只不过是——每天至少专心学习、工作6小时。可是努力需要的耐心，却远比多数人想象中来得巨大，\"要与时间相伴短则5年，长则20年\"。 //在这个浮躁的年代，什么都急于求成，能坚持5年，10年，20年，潜心、专注、努力，凤毛麟角。而在此过程中所得到的感悟，并不是周围人能够理解的。#人需要信仰# 专心打造自己，让自己成为一个优秀的人、一个有用的人、一个独立的人，比什么都重要。打造自己，就等于打造自己的人脉——如果人脉真像传说中那么重要的话。 其实，我总觉得关于人脉导致成功的传说虚无缥缈，不过是些不明真相的人的臆造出的幻想罢了。 //每天晚上8点至10点——每天的黄金时间，在这个时间做的事情，决定了你的一生。 想做到\"不以物喜，不以己悲\"的健康状态，要迈出的第一步就是——停止嘲弄他人。嘲弄者必被嘲弄——这件事就是一个恶毒的魔咒。另一个比较\"技术\"一点的手段就是\"忘记自己的有点\"。很多时候，所谓\"谦虚\"和\"低调\"其实是一种自我保护的优化策略。 //要经常对自己说，别把自己太当回事，其实你什么都不是。 如果一个人把大部分的时间花在工作和学习上，那么他是以工作成就为导向的人；如果一个人把大部分的时间花在享受欢乐上，那么他是以生活满足为导向的人。每个人都不相同，有些人可以在工作和学习上获得更多的乐趣，有些人则会在生活琐事中获得更多的幸福。 所以，你需要确定自己是一个什么样的人。很多时候，鱼和熊掌缺失不可兼得——你必须选择。这也会使你非常清楚一个简单的事实：选择意味着放弃。选择做某件事情，可能就不能去做另外一件事情——哪怕你觉得可以一起做两件事情，实际上你已经不可能同时做第三件事情了。 这时候，黄金分割率可以作为一件趁手的工具。如果一天你可以规划的时间有10小时，并且你确定自己是以工作成就为导向的人，那就这也规划吧：用大约6.18小时去工作和学习，而用剩下的大约3.82小时去享受欢乐——毕竟你是一个正常人。反过来如果你确定自己是以满足生活为向导的人，那就这样规划吧：用6.18小时去享受欢乐，而用剩下的大约3.82小时去工作和学习——你毕竟还要想办法养活自己。 每个人专注的重点是不一样的。少数情况下，一个人可以专注到无以复加的地步——看看那些几天几夜打麻将的人，那些每天除了吸毒什么都不做的人，那些长时间坐在计算机前玩游戏的人就知道了。不过这些都是负面的例子。 某种意义上，我们不得不说，这也的人心智发育不是很健全，因为他们太容易满足并且仅仅满足于简单的感官刺激，而很少甚至无法感知那种需要通过复杂的劳动才可以获得的心灵上的愉悦。 //两种不同的生活导向，并不是一成不变的。两者存在相互转换，目的是使漫长的人生处于良性循环通道中。另外，可以注意到的是，不管是那种导向，都需要去学习，尤其是在当下，逆水行舟不进则退的时代。 很有可能，我们不知不觉就被这个社会抛弃了。我也十分赞同不能同时做很多事情的观点，即使可以并行做很多事情，那也是短暂的，毕竟能力有限、精力有限。 很多人半途而废，往往是因为把目标设定得太高，同时又对达成那么高的目标要付出的代价缺乏清楚的认识。这足以体现\"自知之明\"的重要性。我常常觉得，很多快乐是建立在\"自知之明\"上的。我知道自己的优点是什么，同时也知道自己的缺点是什么，所以，通常情况下，我不大可能做白日梦。 //我至今依然以为我是一个有自知之明的人，所以在做一个重大的决定前，我会花一定的时间去考察目标的高度，评估自身的能力，以及对周围的影响，从而找到一个平衡点。即便在外人看来，这个目标不是最高的，但也许是最合理的。 我们应该把自己的生活节奏调整的慢一点。 在一个所有人都匆匆忙忙的世界里，想放慢节奏实在是一件非常难的事情。但是我们应该记住的是：凡是值得做的事情，都值得慢慢去做，做很久很久。 //慢是一种奢侈，快是一种浮躁。不要想法太多却不切实际了，我们不能什么都想要。人生需要规划，人无远虑必有近忧。 真正的成功者，在关注\"开源\"的时候，会不吝惜金钱合理地\"节流\"；在关注\"开源\"的时候，也不会忘记\"开源\"的重要性。道理很简单：任何事情都可能\"物极必反\"。 //还记得正弦曲线sin(x)吗？大部分的事情都会有周期，我们也不可能一直得意向上，总会有失意的那一天。我们要做的只是储备能力，前进，向前，期待下一个顶点。不慌，不忙，笃悠悠，按照节奏来。 相信积累的力量，本质上就是相信复利的力量。 常言道\"习惯决定命运\"，说的就是这个道理。有些好习惯，养成得越早，一生的收益就越大。同理，坏习惯也是收复利的\"高利贷\"。 举一个很重要的例子：\"怕麻烦\"就是一种害死人的坏习惯。学习效果差，就是因为\"怕麻烦\"而造成了疏漏；工作成绩差，也不过是因为\"怕麻烦\"而偷懒所导致的。 甚至，可以说，只要仔细观察一下，我们就会得出这样的结论：很多人生活不幸，其实只不过是在作关键决策时因为\"怕麻烦\"而产生了失误...... 养成不怕麻烦的性格，才可能拥有耐心。耐心则是在任何工作、学习上获得成功的前提。 //事实上，性格决定命运。坏习惯就像慢性病一样，暂时看起来没什么事，等到并发症来的时候，无药可救。 //当然，很多人不怕死，因为他们无所谓，也不存在对未知的恐惧，觉得得过且过已经不错了。那这日子过的跟动物有啥区别呢？ 表情和神态是一个人内心的折射，几十年积累足以是一个人的内心变得\"不俗\"，于是，表情跟着\"从容\"、神态跟着\"睿智\"。 //所以，与新人接触，第一要看面相。#面相很重要#","tags":"ideas","url":"/articles/TakeTimeAsAFriend","loc":"/articles/TakeTimeAsAFriend"}]};